{"/home/travis/build/npmtest/node-npmtest-tchannel/test.js":"/* istanbul instrument in package npmtest_tchannel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tchannel/lib.npmtest_tchannel.js":"/* istanbul instrument in package npmtest_tchannel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tchannel = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tchannel = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tchannel/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tchannel && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tchannel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tchannel\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tchannel.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_tchannel.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tchannel.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_tchannel.__dirname + '/lib.npmtest_tchannel.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/channel.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar process = require('process');\nvar version = require('./package.json').version;\n\n/*global global*/\nif (typeof global.tchannelVersion === 'string' &&\n    version !== global.tchannelVersion\n) {\n    assert(false,\n        'Must use only a single version of tchannel.\\n' +\n        'Found two versions: ' + version + ' and ' +\n            global.tchannelVersion + '\\n'\n    );\n} else {\n    global.tchannelVersion = version;\n}\n\nvar extend = require('xtend');\nvar globalTimers = extend(require('timers'), {\n    now: Date.now\n});\nvar setImmediate = require('timers').setImmediate;\nvar globalRandom = Math.random;\nvar net = require('net');\nvar format = require('util').format;\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\n\nvar HostPort = require('./host-port.js');\nvar nullLogger = require('./null-logger.js');\nvar EndpointHandler = require('./endpoint-handler.js');\nvar TChannelRequest = require('./request');\nvar TChannelServiceNameHandler = require('./service-name-handler');\nvar errors = require('./errors');\nvar EventEmitter = require('./lib/event_emitter.js');\nvar ObjectPool = require('./lib/object_pool');\nvar RetryRatioTracker = require('./lib/retry_ratio_tracker');\n\nvar TChannelAsThrift = require('./as/thrift');\nvar TChannelAsJSON = require('./as/json');\nvar TChannelConnection = require('./connection');\nvar TChannelRootPeers = require('./root_peers');\nvar TChannelSubPeers = require('./sub_peers');\nvar TChannelServices = require('./services');\nvar RetryFlags = require('./retry-flags.js');\nvar TimeHeap = require('./time_heap');\nvar CountedReadySignal = require('ready-signal/counted');\nvar BatchStatsd = require('./lib/statsd.js');\nvar PeerFileWatcher = require('./peer-file-watcher.js');\n\nvar TracingAgent = require('./trace/agent');\n\nvar CONN_STALE_PERIOD = 1500;\nvar SANITY_PERIOD = 10 * 1000;\n\nvar DEFAULT_RETRY_FLAGS = new RetryFlags(\n    /*never:*/ false,\n    /*onConnectionError*/ true,\n    /*onTimeout*/ false\n);\n\nvar MAXIMUM_TTL_ALLOWED = 2 * 60 * 1000;\nvar MAX_TOMBSTONE_TTL = 5000;\n\n// TODO restore spying\n// var Spy = require('./v2/spy');\n// var dumpEnabled = /\\btchannel_dump\\b/.test(process.env.NODE_DEBUG || '');\n\nvar DEFAULT_ENABLE_MAX_RETRY_RATIO = false;\nvar DEFAULT_MAX_RETRY_RATIO = 0.1;\n\n/*eslint-disable max-statements*/\nfunction TChannel(options) {\n    if (!(this instanceof TChannel)) {\n        return new TChannel(options);\n    }\n\n    var self = this;\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.listeningEvent = this.defineEvent('listening');\n    this.connectionEvent = this.defineEvent('connection');\n    this.statEvent = this.defineEvent('stat');\n    this.peerChosenEvent = null;\n    this.peerScoredEvent = null;\n\n    this.options = extend({\n        useLazyHandling: false,\n        useLazyRelaying: true,\n        timeoutCheckInterval: 100,\n        timeoutFuzz: 100,\n        connectionStalePeriod: CONN_STALE_PERIOD,\n        maxTombstoneTTL: MAX_TOMBSTONE_TTL,\n\n        // TODO: maybe we should always add pid to user-supplied?\n        processName: format('%s[%s]', process.title, process.pid)\n    }, options);\n\n    this.logger = this.options.logger || nullLogger;\n    this.random = this.options.random || globalRandom;\n    this.timers = this.options.timers || globalTimers;\n    this.initTimeout = this.options.initTimeout || 2000;\n    this.requireAs = this.options.requireAs;\n    this.requireCn = this.options.requireCn;\n    this.emitConnectionMetrics =\n        typeof this.options.emitConnectionMetrics === 'boolean' ?\n        this.options.emitConnectionMetrics : false;\n    this.choosePeerWithHeap = typeof this.options.choosePeerWithHeap === 'boolean' ?\n        this.options.choosePeerWithHeap : true;\n    this.connectionAttemptDelay = this.options.connectionAttemptDelay;\n    this.maxConnectionAttemptDelay = this.options.maxConnectionAttemptDelay;\n    this.refreshConnectedPeersDelay = this.options.refreshConnectedPeersDelay;\n\n    this.setObservePeerScoreEvents(this.options.observePeerScoreEvents);\n\n    // Filled in by the listen call:\n    this.host = null;\n    this.requestedPort = null;\n\n    // Filled in by listening event:\n    this.hostPort = null;\n\n    // name of the service running over this channel\n    this.serviceName = '';\n    if (this.options.serviceName) {\n        this.serviceName = this.options.serviceName;\n        delete this.options.serviceName;\n    }\n\n    this.topChannel = this.options.topChannel || null;\n    this.subChannels = this.topChannel ? null : {};\n\n    // for processing operation timeouts\n    this.timeHeap = this.options.timeHeap || new TimeHeap({\n        timers: this.timers,\n        // TODO: do we still need/want fuzzing?\n        minTimeout: fuzzedMinTimeout\n    });\n\n    function fuzzedMinTimeout() {\n        var fuzz = self.options.timeoutFuzz;\n        if (fuzz) {\n            fuzz = Math.floor(fuzz * (self.random() - 0.5));\n        }\n        return self.options.timeoutCheckInterval + fuzz;\n    }\n\n    // how to handle incoming requests\n    if (!this.options.handler) {\n        if (!this.serviceName) {\n            this.handler = TChannelServiceNameHandler({\n                channel: this,\n                isBusy: this.options.isBusy\n            });\n        } else {\n            this.handler = EndpointHandler(this.serviceName);\n        }\n    } else {\n        this.handler = this.options.handler;\n        delete this.options.handler;\n    }\n\n    // populated by:\n    // - manually api (.peers.add etc)\n    // - incoming connections on any listening socket\n\n    if (!this.topChannel) {\n        this.peers = new TChannelRootPeers(this, this.options);\n    } else {\n        this.peers = new TChannelSubPeers(this, this.options);\n    }\n\n    // For tracking the number of pending requests to any service\n    this.services = new TChannelServices();\n    if (this.options.maxPending !== undefined) {\n        this.services.maxPending = this.options.maxPending;\n    }\n    if (this.options.maxPendingForService !== undefined) {\n        this.services.maxPendingForService = this.options.maxPendingForService;\n    }\n\n    // TChannel advances through the following states.\n    this.listened = false;\n    this.listening = false;\n    this.destroyed = false;\n    this.draining = false;\n\n    // set when draining (e.g. graceful shutdown)\n    this.drainReason = '';\n    this.drainExempt = null;\n\n    var trace = typeof this.options.trace === 'boolean' ?\n        this.options.trace : true;\n\n    if (trace) {\n        this.tracer = new TracingAgent({\n            logger: this.logger,\n            forceTrace: this.options.forceTrace,\n            serviceName: this.options.serviceNameOverwrite,\n            reporter: this.options.traceReporter\n        });\n    }\n\n    if (typeof this.options.traceSample === 'number') {\n        this.traceSample = this.options.traceSample;\n    } else {\n        this.traceSample = 0.01;\n    }\n\n    // lazily created by .getServer (usually from .listen)\n    this.serverSocket = null;\n    this.serverConnections = null;\n\n    this.TChannelAsThrift = TChannelAsThrift;\n    this.TChannelAsJSON = TChannelAsJSON;\n\n    this.statsd = this.options.statsd;\n    this.batchStats = null;\n\n    this.requestDefaults = this.options.requestDefaults ?\n        new RequestDefaults(this.options.requestDefaults) : null;\n\n    if (!this.topChannel) {\n        if (this.options.batchStats) {\n            this.batchStats = this.options.batchStats;\n            this.batchStatsAllocated = false;\n        } else {\n            this.batchStats = new BatchStatsd({\n                logger: this.logger,\n                timers: this.timers,\n                statsd: this.statsd,\n                baseTags: this.options.statTags\n            });\n            this.batchStatsAllocated = true;\n\n            this.batchStats.flushStats();\n        }\n\n        this.sanityTimer = this.timers.setTimeout(doSanitySweep, SANITY_PERIOD);\n    } else {\n        this.batchStats = this.topChannel.batchStats;\n    }\n\n    if (this.batchStats) {\n        ObjectPool.bootstrap({\n            channel: this,\n            reportInterval: 5000,\n            timers: this.timers,\n            debug: this.options.objectPoolDebug ? true : false\n        });\n    }\n\n    this.maximumRelayTTL = MAXIMUM_TTL_ALLOWED;\n    this.watcher = null;\n\n    function doSanitySweep() {\n        self.sanityTimer = null;\n        self.sanitySweep(sweepDone);\n    }\n\n    function sweepDone() {\n        if (self.destroyed) {\n            return;\n        }\n        self.sanityTimer = self.timers.setTimeout(doSanitySweep, SANITY_PERIOD);\n    }\n\n    // for client retry budget\n    this.enableMaxRetryRatio = this.options.enableMaxRetryRatio || DEFAULT_ENABLE_MAX_RETRY_RATIO;\n    this.maxRetryRatio = this.options.maxRetryRatio || DEFAULT_MAX_RETRY_RATIO; // retries to requests\n    assert(this.maxRetryRatio >= 0.0, 'maxRetryRatio must be non-negative');\n    this.retryRatioTracker = null;\n    if (this.enableMaxRetryRatio && this.topChannel) { // only track ratio in sub channel\n        this.retryRatioTracker = new RetryRatioTracker({\n            rateCounterInterval: this.options.rateCounterInterval,\n            rateCounterNumOfBuckets: this.options.rateCounterNumOfBuckets,\n            timers: this.timers\n        });\n    }\n}\ninherits(TChannel, EventEmitter);\n/*eslint-enable max-statements*/\n\nTChannel.prototype.setMaximumRelayTTL =\nfunction setMaximumRelayTTL(value) {\n    var self = this;\n\n    self.maximumRelayTTL = value;\n\n    var keys = Object.keys(self.subChannels);\n    for (var i = 0; i < keys.length; i++) {\n        var subChan = self.subChannels[keys[i]];\n\n        subChan.maximumRelayTTL = value;\n    }\n};\n\nTChannel.prototype.toString =\nfunction channelToString() {\n    var self = this;\n    if (!self.topChannel) {\n        return 'TChannel(' + self.hostPort + ')';\n    }\n    return 'TSubChannel(' + self.serviceName + ',' + self.hostPort + ')';\n};\n\nTChannel.prototype.inspect =\nfunction tchannelInspect() {\n    var self = this;\n    return 'TChannel(' + inspect(self.extendLogInfo({})) + ')';\n};\n\nTChannel.prototype.setPreferConnectionDirection =\nfunction setPreferConnectionDirection(direction) {\n    var self = this;\n\n    self.peers.preferConnectionDirection = direction;\n    var peers = self.peers.values();\n\n    for (var i = 0; i < peers.length; i++) {\n        peers[i].setPreferConnectionDirection(direction);\n    }\n};\n\nTChannel.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    info.hostPort = self.hostPort;\n    info.channelListened = self.listened;\n    info.channelListening = self.listening;\n    info.channelDestroyed = self.destroyed;\n    info.channelDraining = self.draining;\n\n    return info;\n};\n\nTChannel.prototype.eachConnection = function eachConnection(each) {\n    var self = this;\n\n    var peers = self.peers.values();\n    var i;\n    for (i = 0; i < peers.length; i++) {\n        var peer = peers[i];\n        for (var j = 0; j < peer.connections.length; j++) {\n            each(peer.connections[j]);\n        }\n    }\n\n    if (self.serverConnections) {\n        var connKeys = Object.keys(self.serverConnections);\n        for (i = 0; i < connKeys.length; i++) {\n            each(self.serverConnections[connKeys[i]]);\n        }\n    }\n};\n\nTChannel.prototype.setObservePeerScoreEvents =\nfunction setObservePeerScoreEvents(obs) {\n    var self = this;\n\n    if (obs) {\n        self.peerChosenEvent = self.defineEvent('peerChosen');\n        self.peerScoredEvent = self.defineEvent('peerScored');\n    } else {\n        self.peerChosenEvent = null;\n        self.peerScoredEvent = null;\n    }\n};\n\nTChannel.prototype.setWriteBufferMode =\nfunction setWriteBufferMode(mode) {\n    // No-op for back-compat\n};\n\nTChannel.prototype.setChoosePeerWithHeap =\nfunction setChoosePeerWithHeap(enabled) {\n    var self = this;\n    self.choosePeerWithHeap = enabled;\n    if (self.topChannel) {\n        self.peers.setChoosePeerWithHeap(enabled);\n    }\n};\n\nTChannel.prototype.setLazyHandling =\nfunction setLazyHandling(enabled) {\n    var self = this;\n\n    if (self.topChannel) {\n        self.topChannel.setLazyHandling(enabled);\n        return;\n    }\n\n    self.options.useLazyHandling = enabled;\n    self.eachConnection(updateEachConn);\n\n    function updateEachConn(conn) {\n        conn.setLazyHandling(enabled);\n    }\n};\n\nTChannel.prototype.setLazyRelaying =\nfunction setLazyRelaying(enabled) {\n    var self = this;\n\n    if (self.topChannel) {\n        self.topChannel.setLazyRelaying(enabled);\n        return;\n    }\n\n    self.options.useLazyRelaying = enabled;\n\n    var keys = Object.keys(self.subChannels);\n    for (var i = 0; i < keys.length; i++) {\n        var subChan = self.subChannels[keys[i]];\n        if (subChan.handler.type === 'tchannel.relay-handler') {\n            subChan.handler.lazyEnabled = enabled;\n        }\n    }\n};\n\nTChannel.prototype.drain = function drain(reason, callback) {\n    var self = this;\n\n    // TODO: we could do this by defaulting and/or forcing you into an\n    // exemption function that exempting anything not matching the given sub\n    // channel's service name; however there are many other complications to\n    // consider to implement sub channel draining, so for now:\n    assert(!self.topChannel, 'sub channel draining not supported');\n    assert(!self.draining, 'channel already draining');\n\n    self.draining = true;\n    self.drainReason = reason;\n\n    var drained = CountedReadySignal(1);\n    drained(callback);\n    self.eachConnection(drainEachConn);\n    process.nextTick(drained.signal);\n    self.logger.info('draining channel', self.extendLogInfo({\n        reason: self.drainReason,\n        count: drained.counter\n    }));\n\n    function drainEachConn(conn) {\n        drained.counter++;\n        conn.drain(self.drainReason, drained.signal);\n    }\n};\n\nTChannel.prototype.getServer = function getServer() {\n    var self = this;\n    if (self.serverSocket) {\n        return self.serverSocket;\n    }\n\n    self.serverConnections = Object.create(null);\n    self.serverSocket = net.createServer(onServerSocketConnection);\n    self.serverSocket.on('listening', onServerSocketListening);\n    self.serverSocket.on('error', onServerSocketError);\n\n    return self.serverSocket;\n\n    function onServerSocketConnection(sock) {\n        self.onServerSocketConnection(sock);\n    }\n\n    function onServerSocketListening() {\n        self.onServerSocketListening();\n    }\n\n    function onServerSocketError(err) {\n        self.onServerSocketError(err);\n    }\n};\n\nTChannel.prototype.onServerSocketConnection = function onServerSocketConnection(sock) {\n    var self = this;\n\n    if (self.destroyed) {\n        self.logger.error('got incoming socket whilst destroyed', self.extendLogInfo({\n            remoteAddress: sock.remoteAddress,\n            remotePort: sock.remotePort\n        }));\n        return;\n    }\n\n    var socketRemoteAddr = sock.remoteAddress + ':' + sock.remotePort;\n    var chan = self.topChannel || self;\n    var conn = new TChannelConnection(chan, sock, 'in', socketRemoteAddr);\n\n    if (self.draining) {\n        conn.drain(self.drainReason, null);\n    }\n\n    conn.errorEvent.on(onConnectionError);\n\n    if (self.serverConnections[socketRemoteAddr]) {\n        var oldConn = self.serverConnections[socketRemoteAddr];\n        oldConn.resetAll(errors.SocketClosedError({\n            reason: 'duplicate socketRemoteAddr incoming conn'\n        }));\n        delete self.serverConnections[socketRemoteAddr];\n    }\n\n    sock.on('close', onSocketClose);\n\n    self.serverConnections[socketRemoteAddr] = conn;\n    self.connectionEvent.emit(self, conn);\n\n    function onSocketClose() {\n        delete self.serverConnections[socketRemoteAddr];\n    }\n\n    // TODO: move method\n    function onConnectionError(err) {\n        var codeName = errors.classify(err);\n\n        var loggerInfo = conn.extendLogInfo({\n            error: err\n        });\n\n        if (codeName === 'Timeout' ||\n            codeName === 'NetworkError') {\n            self.logger.warn('Got a connection error', loggerInfo);\n        } else {\n            self.logger.error('Got an unexpected connection error', loggerInfo);\n        }\n        delete self.serverConnections[socketRemoteAddr];\n    }\n};\n\nTChannel.prototype.onServerSocketListening = function onServerSocketListening() {\n    var self = this;\n\n    if (self.destroyed) {\n        self.logger.error('got serverSocket listen whilst destroyed', self.extendLogInfo({\n            requestedPort: self.requestedPort\n        }));\n        return;\n    }\n\n    var address = self.serverSocket.address();\n    self.hostPort = self.host + ':' + address.port;\n    self.listening = true;\n\n    if (self.subChannels) {\n        var subChanNames = Object.keys(self.subChannels);\n        for (var i = 0; i < subChanNames.length; i++) {\n            var chan = self.subChannels[subChanNames[i]];\n            if (!chan.hostPort) {\n                chan.hostPort = self.hostPort;\n            }\n        }\n    }\n\n    self.listeningEvent.emit(self);\n};\n\nTChannel.prototype.onServerSocketError = function onServerSocketError(err) {\n    var self = this;\n\n    if (err.code === 'EADDRINUSE') {\n        err = errors.TChannelListenError(err, {\n            requestedPort: self.requestedPort,\n            host: self.host\n        });\n    }\n    self.logger.error('server socket error', self.extendLogInfo({\n        requestedPort: self.requestedPort,\n        host: self.host,\n        error: err\n    }));\n    self.errorEvent.emit(self, err);\n};\n\nTChannel.prototype.makeSubChannel = function makeSubChannel(options) {\n    var self = this;\n    if (!options) {\n        options = {};\n    }\n    assert(!self.serviceName, 'arbitrary-depth sub channels are unsupported');\n    assert(options.serviceName, 'must specify serviceName');\n    assert(!self.subChannels[options.serviceName], 'duplicate sub channel creation');\n    var opts = extend(self.options);\n    var keys = Object.keys(options);\n    for (var i = 0; i < keys.length; i++) {\n        switch (keys[i]) {\n            case 'peers':\n                break;\n            default:\n                opts[keys[i]] = options[keys[i]];\n        }\n    }\n\n    opts.topChannel = self;\n    opts.timeHeap = self.timeHeap;\n\n    opts.enableMaxRetryRatio = options.enableMaxRetryRatio;\n    opts.maxRetryRatio = options.maxRetryRatio;\n\n    var chan = TChannel(opts);\n\n    if (options.peers) {\n        for (i = 0; i < options.peers.length; i++) {\n            if (typeof options.peers[i] === 'string') {\n                chan.peers.add(options.peers[i]);\n            }\n        }\n    }\n    self.subChannels[chan.serviceName] = chan;\n\n    // Subchannels should not have tracers; all tracing goes\n    // through the top channel.\n    chan.tracer = self.tracer;\n\n    if (self.hostPort) {\n        chan.hostPort = self.hostPort;\n    }\n\n    if (options.peerFile) {\n        chan.watcher = new PeerFileWatcher(chan, {\n            peerFile: options.peerFile,\n            refreshInterval: options.refreshInterval\n        });\n    }\n\n    return chan;\n};\n\nTChannel.prototype.listen = function listen(port, host, callback) {\n    // Note:\n    // - 0 is a valid port number, indicating that the system must assign an\n    //   available ephemeral port\n    // - 127.0.0.1 is a valid host, primarily for testing\n    var self = this;\n\n    assert(!self.topChannel, 'TChannel must listen on top channel');\n    assert(!self.listened, 'TChannel can only listen once');\n\n    var reason;\n    reason = HostPort.validateHost(host);\n    if (reason) {\n        assert(false, reason);\n    }\n\n    reason = HostPort.validatePort(port, true);\n    if (reason) {\n        assert(false, reason);\n    }\n\n    self.listened = true;\n    self.requestedPort = port;\n    self.host = host;\n    self.getServer().listen(port, host, callback);\n};\n\nTChannel.prototype.register = function register(name, options, handler) {\n    var self = this;\n\n    var handlerType = self.handler && self.handler.type;\n\n    switch (handlerType) {\n        case 'tchannel.endpoint-handler':\n            self.handler.register(name, options, handler);\n            break;\n\n        case 'tchannel.service-name-handler':\n            throw errors.TopLevelRegisterError();\n\n        default:\n            if (typeof self.handler.register === 'function') {\n                self.handler.register(name, options, handler);\n            } else {\n                throw errors.InvalidHandlerForRegister({\n                    handlerType: handlerType,\n                    handler: self.handler\n                });\n            }\n    }\n};\n\nTChannel.prototype.address = function address() {\n    var self = this;\n    if (self.serverSocket) {\n        return self.serverSocket.address() || null;\n    } else if (self.topChannel) {\n        return self.topChannel.address();\n    } else {\n        return null;\n    }\n};\n\nTChannel.prototype.updatePeers =\nfunction updatePeers(newPeers) {\n    // Take a snapshot of current, existing peers. This is used to delete old\n    // peers later.\n    var oldPeers = this.peers.keys().slice();\n\n    var i;\n\n    // Load new peers; duplicates are ignored\n    for (i = 0; i < newPeers.length; i++) {\n        if (typeof newPeers[i] === 'string') {\n            this.peers.add(newPeers[i]);\n        }\n    }\n\n    // Drain and delete existing peers that are not in the new peer list\n    for (i = 0; i < oldPeers.length; i++) {\n        if (newPeers.indexOf(oldPeers[i]) === -1) {\n            this.logger.info('TChannel: Removing old peer', {\n                peer: oldPeers[i]\n            });\n\n            var peer = this.peers.get(oldPeers[i]);\n            this.peers.delete(oldPeers[i]);\n\n            this.drainPeer(peer);\n        }\n    }\n\n    this.logger.info('TChannel: Loaded peers', {\n        newPeers: newPeers\n    });\n};\n\nTChannel.prototype.drainPeer = function drainPeer(peer) {\n    var self = this;\n    if (peer.draining) {\n        return;\n    }\n\n    peer.drain({\n        goal: peer.DRAIN_GOAL_CLOSE_PEER,\n        reason: 'peer has been removed from the peer list',\n        direction: 'both',\n        timeout: 5 * 1000\n    }, thenDeleteIt);\n\n    function thenDeleteIt(err) {\n        if (err) {\n            self.logger.warn(\n                'TChannel: error closing peer, deleting anyhow',\n                peer.extendLogInfo(peer.draining.extendLogInfo({\n                    error: err\n                }))\n            );\n        }\n\n        if (self.topChannel) {\n            self.topChannel.peers.delete(peer.hostPort);\n        } else {\n            self.peers.delete(peer.hostPort);\n        }\n    }\n};\n\n/*\n    Build a new opts\n    Copy all props from defaults over.\n    Build a new opts.headers\n    Copy all headers from defaults.headers over\n    For each key in per request options; assign\n    For each key in per request headers; assign\n*/\nTChannel.prototype.requestOptions = function requestOptions(options) {\n    var self = this;\n    var prop;\n    var opts = {};\n    for (prop in self.requestDefaults) {\n        if (prop === 'headers') {\n            continue;\n        }\n\n        opts[prop] = self.requestDefaults[prop];\n    }\n    opts.headers = {};\n    if (self.requestDefaults.headers) {\n        /*eslint-disable guard-for-in*/\n        for (prop in self.requestDefaults.headers) {\n            opts.headers[prop] = self.requestDefaults.headers[prop];\n        }\n        /*eslint-enable guard-for-in*/\n    }\n\n    if (options) {\n        for (prop in options) {\n            if (prop === 'headers') {\n                continue;\n            }\n            opts[prop] = options[prop];\n        }\n    }\n    if (options && options.headers) {\n        opts.headers = opts.headers;\n        /*eslint-disable guard-for-in*/\n        for (prop in options.headers) {\n            opts.headers[prop] = options.headers[prop];\n        }\n        /*eslint-enable guard-for-in*/\n    }\n    return opts;\n};\n\nTChannel.prototype.waitForIdentified =\nfunction waitForIdentified(options, callback) {\n    var self = this;\n    if (self.destroyed) {\n        callback(errors.TChannelDestroyedError());\n    } else {\n        assert(typeof options.host === 'string', 'options.host is required');\n        var peer = self.peers.add(options.host);\n        peer.waitForIdentified(callback);\n    }\n};\n\n/*\n    Build a new opts\n    Copy all props from defaults over.\n    Build a new opts.headers\n    Copy all headers from defaults.headers over\n    For each key in per request options; assign\n    For each key in per request headers; assign\n*/\n/*eslint max-statements: [2, 50]*/\nTChannel.prototype.fastRequestDefaults =\nfunction fastRequestDefaults(reqOpts) {\n    var self = this;\n\n    var defaults = self.requestDefaults;\n    if (!defaults) {\n        return;\n    }\n\n    if (defaults.timeout && !reqOpts.timeout) {\n        reqOpts.timeout = defaults.timeout;\n    }\n    if (defaults.retryLimit && !reqOpts.retryLimit) {\n        reqOpts.retryLimit = defaults.retryLimit;\n    }\n    if (defaults.serviceName && !reqOpts.serviceName) {\n        reqOpts.serviceName = defaults.serviceName;\n    }\n    if (defaults._trackPendingSpecified && !reqOpts._trackPendingSpecified) {\n        reqOpts.trackPending = defaults.trackPending;\n    }\n    if (defaults._checkSumTypeSpecified && reqOpts.checksumType === null) {\n        reqOpts.checksumType = defaults.checksumType;\n    }\n    if (defaults._hasNoParentSpecified && !reqOpts._hasNoParentSpecified) {\n        reqOpts.hasNoParent = defaults.hasNoParent;\n    }\n    if (defaults._traceSpecified && !reqOpts._traceSpecified) {\n        reqOpts.trace = defaults.trace;\n    }\n    if (defaults.retryFlags && !reqOpts._retryFlagsSpecified) {\n        reqOpts.retryFlags = defaults.retryFlags;\n    }\n    if (defaults.shouldApplicationRetry &&\n        !reqOpts.shouldApplicationRetry\n    ) {\n        reqOpts.shouldApplicationRetry = defaults.shouldApplicationRetry;\n    }\n\n    if (defaults.headers) {\n        for (var key in defaults.headers) {\n            if (!reqOpts.headers[key]) {\n                reqOpts.headers[key] = defaults.headers[key];\n            }\n        }\n    }\n};\n\nfunction RequestDefaults(reqDefaults) {\n    this.timeout = reqDefaults.timeout || 0;\n    this.retryLimit = reqDefaults.retryLimit || 0;\n    this.serviceName = reqDefaults.serviceName || '';\n\n    this._trackPendingSpecified = typeof reqDefaults.trackPending === 'boolean';\n    this.trackPending = reqDefaults.trackPending;\n\n    this._checkSumTypeSpecified = typeof reqDefaults.checksumType === 'number';\n    this.checksumType = reqDefaults.checksumType || 0;\n\n    this._hasNoParentSpecified = typeof reqDefaults.hasNoParent === 'boolean';\n    this.hasNoParent = reqDefaults.hasNoParent || false;\n\n    this._traceSpecified = typeof reqDefaults.trace === 'boolean';\n    this.trace = reqDefaults.trace || false;\n\n    this.retryFlags = reqDefaults.retryFlags || null;\n    this.shouldApplicationRetry = reqDefaults.shouldApplicationRetry || null;\n\n    this.headers = reqDefaults.headers;\n}\n\nTChannel.prototype.request = function channelRequest(options) {\n    var self = this;\n\n    options = options || {};\n\n    var opts = new RequestOptions(self, options);\n    self.fastRequestDefaults(opts);\n\n    if (opts.trace && opts.hasNoParent) {\n        if (Math.random() < self.traceSample) {\n            opts.trace = true;\n        } else {\n            opts.trace = false;\n        }\n    }\n\n    return self._request(opts);\n};\n\nfunction RequestOptions(channel, opts) {\n    /*eslint complexity: [2, 30]*/\n    this.channel = channel;\n\n    this.host = opts.host || '';\n    this.streamed = opts.streamed || false;\n    this.timeout = opts.timeout || 0;\n    this.retryLimit = opts.retryLimit || 0;\n    this.serviceName = opts.serviceName || '';\n    this._trackPendingSpecified = typeof opts.trackPending === 'boolean';\n    this.trackPending = opts.trackPending || false;\n    this.checksumType = opts.checksumType || null;\n    this._hasNoParentSpecified = typeof opts.hasNoParent === 'boolean';\n    this.hasNoParent = opts.hasNoParent || false;\n    this.forwardTrace = opts.forwardTrace || false;\n    this._traceSpecified = typeof opts.trace === 'boolean';\n    this.trace = this._traceSpecified ? opts.trace : true;\n    this._retryFlagsSpecified = !!opts.retryFlags;\n    this.retryFlags = opts.retryFlags || DEFAULT_RETRY_FLAGS;\n    this.shouldApplicationRetry = opts.shouldApplicationRetry || null;\n    this.parent = opts.parent || null;\n    this.tracing = opts.tracing || null;\n    this.peer = opts.peer || null;\n    this.timeoutPerAttempt = opts.timeoutPerAttempt || 0;\n    this.checksum = opts.checksum || null;\n\n    // TODO optimize?\n    this.headers = opts.headers || new RequestHeaders();\n\n    this.retryCount = 0;\n    this.logical = false;\n    this.remoteAddr = null;\n    this.hostPort = null;\n}\n\nfunction RequestHeaders() {\n    this.cn = '';\n    this.as = '';\n    this.re = '';\n}\n\nTChannel.prototype._request = function _request(opts) {\n    var self = this;\n\n    assert(!self.destroyed, 'cannot request() to destroyed tchannel');\n    if (!self.topChannel) {\n        throw errors.TopLevelRequestError();\n    }\n\n    var req = null;\n    // retries are only between hosts\n    if (opts.peer) {\n        opts.retryCount = 0;\n        req = opts.peer.request(opts);\n    } else if (opts.host) {\n        opts.retryCount = 0;\n        opts.peer = self.peers.add(opts.host);\n        req = opts.peer.request(opts);\n    // streaming retries not yet implemented\n    } else if (opts.streamed) {\n        opts.retryCount = 0;\n\n        opts.peer = self.peers.choosePeer();\n        if (!opts.peer) {\n            // TODO: operational error?\n            throw errors.NoPeerAvailable();\n        }\n        req = opts.peer.request(opts);\n    } else {\n        req = new TChannelRequest(opts);\n    }\n\n    return req;\n};\n\nTChannel.prototype.quit = // to provide backward compatibility.\nTChannel.prototype.close = function close(callback) {\n    var self = this;\n    assert(!self.destroyed, 'TChannel double close');\n    self.destroyed = true;\n\n    var counter = 1;\n\n    if (self.watcher) {\n        self.watcher.destroy();\n    }\n\n    if (self.batchStats) {\n        ObjectPool.unref();\n    }\n\n    if (self.sanityTimer) {\n        self.timers.clearTimeout(self.sanityTimer);\n        self.sanityTimer = null;\n    }\n\n    if (self.retryRatioTracker) {\n        self.retryRatioTracker.destroy();\n    }\n\n    if (self.serverSocket) {\n        ++counter;\n        if (self.serverSocket.address()) {\n            closeServerSocket();\n        } else {\n            self.serverSocket.once('listening', closeServerSocket);\n        }\n    }\n\n    if (self.serverConnections) {\n        var incomingConns = Object.keys(self.serverConnections);\n        for (var i = 0; i < incomingConns.length; i++) {\n            ++counter;\n            var incomingConn = self.serverConnections[incomingConns[i]];\n            incomingConn.close(onClose);\n        }\n    }\n\n    if (self.subChannels) {\n        var serviceNames = Object.keys(self.subChannels);\n        serviceNames.forEach(function each(serviceName) {\n            var svcchan = self.subChannels[serviceName];\n            if (!svcchan.destroyed) {\n                counter++;\n                svcchan.close(onClose);\n            }\n        });\n    }\n\n    if (!self.topChannel) {\n        if (self.batchStatsAllocated) {\n            self.batchStats.destroy();\n        }\n        self.timeHeap.clear();\n    }\n\n    counter++;\n    self.peers.close(onClose);\n\n    onClose();\n\n    function closeServerSocket() {\n        self.serverSocket.once('close', onClose);\n        self.serverSocket.close();\n    }\n\n    function onClose() {\n        if (--counter <= 0) {\n            if (counter < 0) {\n                self.logger.error('closed more channel sockets than expected', self.extendLogInfo({\n                    counter: counter\n                }));\n            }\n            if (typeof callback === 'function') {\n                callback();\n            }\n        }\n    }\n};\n\nTChannel.prototype.emitFastStat =\nfunction emitFastStat(name, type, value, tags) {\n    var self = this;\n\n    var stat = self.batchStats.pushStat(name, type, value, tags);\n\n    var topChannel = self.topChannel ? self.topChannel : self;\n    topChannel.statEvent.emit(topChannel, stat);\n};\n\nTChannel.prototype.flushStats = function flushStats() {\n    var self = this;\n\n    if (self.batchStats) {\n        self.batchStats.flushStats();\n    }\n};\n\nTChannel.prototype.sanitySweep =\nfunction sanitySweep(callback) {\n    var self = this;\n\n    if (!self.serverConnections) {\n        self.peers.sanitySweep(callback);\n        return;\n    }\n\n    var incomingConns = Object.keys(self.serverConnections);\n\n    nextConn(incomingConns, 0, function connSweepDone(err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n\n        self.peers.sanitySweep(callback);\n    });\n\n    function nextConn(connectionKeys, index, cb) {\n        if (index >= connectionKeys.length) {\n            cb(null);\n            return;\n        }\n\n        var connection = self.serverConnections[connectionKeys[index]];\n        if (!connection || !connection.ops) {\n            setImmediate(deferNextConn);\n        } else {\n            connection.ops.sanitySweep(function opsSweepDone() {\n                setImmediate(deferNextConn);\n            });\n        }\n\n        function deferNextConn() {\n            nextConn(connectionKeys, index + 1, cb);\n        }\n    }\n};\n\nTChannel.prototype.setMaxTombstoneTTL =\nfunction setMaxTombstoneTTL(ttl) {\n    var self = this;\n\n    if (ttl === self.options.maxTombstoneTTL) {\n        return;\n    }\n\n    self.options.maxTombstoneTTL = ttl;\n    var peers = self.peers.values();\n    for (var i = 0; i < peers.length; i++) {\n        var peer = peers[i];\n        peer.setMaxTombstoneTTL(ttl);\n    }\n};\n\nTChannel.prototype.isUnhealthyError = function isUnhealthyError(err) {\n    if (!err) {\n        return false;\n    }\n    var codeName = errors.classify(err);\n    return errors.isUnhealthy(codeName);\n};\n\nmodule.exports = TChannel;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/host-port.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar validIPv4 = /^\\d+\\.\\d+\\.\\d+\\.\\d+$/;\n\nmodule.exports.validateHostPort = validateHostPort;\nmodule.exports.validateHost = validateHost;\nmodule.exports.validatePort = validatePort;\n\nfunction validateHost(host, allowEmphemeral) {\n    if (typeof host !== 'string') {\n        return 'Expected host to be a string';\n    }\n\n    if (!validIPv4.test(host)) {\n        return 'Expected host to contain IPv4';\n    }\n\n    if (!allowEmphemeral && host === '0.0.0.0') {\n        return 'Expected host to not be 0.0.0.0';\n    }\n\n    return null;\n}\n\nfunction validatePort(portNum, allowEmphemeral) {\n    if (typeof portNum !== 'number') {\n        return 'Expected port to be a number';\n    }\n\n    if (!(portNum >= 0 && portNum < 65536)) {\n        return 'Expected port to be between >=0 & <65536';\n    }\n\n    if (!allowEmphemeral && portNum === 0) {\n        return 'Expected port to not be 0';\n    }\n\n    return null;\n}\n\nfunction validateHostPort(hostPort, allowEmphemeral) {\n    var reason;\n    if (typeof hostPort !== 'string') {\n        return 'Expected hostPort to be a string, got ' + JSON.stringify(hostPort) + ' instead';\n    }\n\n    var parts = hostPort.split(':');\n    if (parts.length !== 2) {\n        return 'Expected hostPort to be {ipv4}:{port}, got ' + JSON.stringify(hostPort) + 'instead';\n    }\n\n    var host = parts[0];\n    reason = validateHost(host, allowEmphemeral);\n    if (reason) {\n        return reason + ' in ' + JSON.stringify(hostPort);\n    }\n\n    var portStr = parts[1];\n    if (!stringIsValidNumber(portStr)) {\n        return 'Expected port to be a valid number in ' + JSON.stringify(hostPort);\n    }\n\n    var portNum = parseInt(portStr, 10);\n    reason = validatePort(portNum, allowEmphemeral);\n    if (reason) {\n        return reason + ' in ' + JSON.stringify(hostPort);\n    }\n\n    return null;\n}\n\nfunction stringIsValidNumber(numAsStr) {\n    var num = parseInt(numAsStr, 10);\n    return num.toString() === numAsStr;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/null-logger.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nfunction noop() {}\n\nmodule.exports = {\n    debug: noop,\n    error: noop,\n    fatal: noop,\n    info: noop,\n    warn: noop\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/endpoint-handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar EventEmitter = require('./lib/event_emitter');\nvar inherits = require('util').inherits;\nvar util = require('util');\nvar errors = require('./errors');\nvar coerceRequestHandler = require('./request-handler');\n\nfunction TChannelEndpointHandler(serviceName) {\n    if (!(this instanceof TChannelEndpointHandler)) {\n        return new TChannelEndpointHandler(serviceName);\n    }\n    var self = this;\n    EventEmitter.call(self);\n    self.handleEndpointEvent = self.defineEvent('handleEndpoint');\n\n    self.serviceName = serviceName;\n    self.endpoints = Object.create(null);\n}\ninherits(TChannelEndpointHandler, EventEmitter);\n\nTChannelEndpointHandler.prototype.type = 'tchannel.endpoint-handler';\n\nTChannelEndpointHandler.prototype.register = function register(name, options, handler) {\n    var self = this;\n    if (typeof options === 'function') {\n        handler = options;\n        options = {};\n    }\n    if (typeof handler !== 'function') {\n        throw errors.InvalidHandlerError();\n    }\n    if (options.streamed) {\n        handler.canStream = true;\n    }\n    self.endpoints[name] = coerceRequestHandler(handler, self, options);\n    return handler;\n};\n\nTChannelEndpointHandler.prototype.handleRequest = function handleRequest(req, buildResponse) {\n    var self = this;\n\n    var handler = self.endpoints[req.endpoint];\n    self.handleEndpointEvent.emit(self, {\n        name: req.endpoint,\n        handler: handler\n    });\n    if (!handler) {\n        buildResponse({streamed: false}).sendError('BadRequest', util.format(\n            'no such endpoint service=%j endpoint=%j',\n            req.serviceName, req.endpoint));\n    } else {\n        handler.handleRequest(req, buildResponse);\n    }\n};\n\nTChannelEndpointHandler.prototype.withArg23 = function withArg23(req, buildResponse, handler) {\n    req.withArg23(function gotArg23(err, arg2, arg3) {\n        var res = buildResponse({streamed: false});\n        if (err) {\n            // TODO: log error\n            res.sendError('UnexpectedError', util.format(\n                'error accumulating arg2/arg3: %s: %s',\n                err.constructor.name, err.message));\n        } else {\n            handler.handleRequest(req, res, arg2, arg3);\n        }\n    });\n};\n\nmodule.exports = TChannelEndpointHandler;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/event_emitter.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\n\nfunction EventEmitter() {\n}\n\nEventEmitter.prototype.defineEvent =\nfunction defineEvent(type, defaultListener) {\n    if (!defaultListener && type === 'error') {\n        defaultListener = defaultErrorListener;\n    }\n    return new DefinedEvent(type, defaultListener);\n};\n\nEventEmitter.prototype.on =\nEventEmitter.prototype.addListener =\nfunction addListener(type, listener) {\n    this[type + 'Event'].addListener(listenerCompatShim);\n    listenerCompatShim.listener = listener;\n    function listenerCompatShim(arg, context) {\n        listener.call(context, arg);\n    }\n};\n\nEventEmitter.prototype.removeListener =\nfunction removeListener(type, listener) {\n    var evt = this[type + 'Event'];\n    if (evt.listener && evt.listener.listener === listener) {\n        evt.listener = null;\n    } else if (evt.listeners.length) {\n        var listeners = [];\n        for (var i = 0; i < evt.listeners.length; i++) {\n            if (evt.listeners[i].listener !== listener) {\n                listeners.push(evt.listeners[i]);\n            }\n        }\n        if (listeners.length === 1) {\n            evt.listener = listeners.pop();\n        }\n        evt.listeners = listeners;\n    }\n};\n\nEventEmitter.prototype.removeAllListeners =\nfunction removeAllListeners(type) {\n    assert(type, 'not implemented: removing all listeners from all event types');\n    this[type + 'Event'].removeAllListeners();\n};\n\nEventEmitter.prototype.emit =\nfunction emit(type, arg) {\n    this[type + 'Event'].emit(this, arg);\n};\n\nfunction DefinedEvent(type, defaultListener) {\n    this.type = type;\n    this.defaultListener = defaultListener;\n    this.listener = null;\n    this.listeners = [];\n}\n\nDefinedEvent.prototype.emit =\nfunction emit(that, arg) {\n    if (this.listener) {\n        this.listener(arg, that);\n    } else if (this.listeners.length) {\n        var listeners = this.listeners;\n        for (var i = 0; i < listeners.length; i++) {\n            listeners[i](arg, that);\n        }\n    } else if (this.defaultListener) {\n        this.defaultListener(arg, that);\n    }\n};\n\nDefinedEvent.prototype.on =\nDefinedEvent.prototype.addListener =\nfunction addListener(listener) {\n    if (this.listeners.length) {\n        this.listeners.push(listener);\n    } else if (this.listener) {\n        this.listeners.push(this.listener, listener);\n        this.listener = null;\n    } else {\n        this.listener = listener;\n    }\n};\n\nDefinedEvent.prototype.removeListener =\nfunction removeListener(listener) {\n    if (this.listener) {\n        if (this.listener === listener) {\n            this.listener = null;\n        }\n    } else if (this.listeners.length) {\n        var listeners = [];\n        for (var i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i] !== listener) {\n                listeners.push(this.listeners[i]);\n            }\n        }\n        if (listeners.length === 1) {\n            this.listener = listeners.pop();\n        }\n        this.listeners = listeners;\n    }\n};\n\nDefinedEvent.prototype.removeAllListeners =\nfunction removeAllListeners() {\n    this.listener = null;\n    this.listeners = [];\n};\n\nfunction defaultErrorListener(err) {\n    if (!err) {\n        err = new TypeError('Uncaught, unspecified \"error\" event.');\n    }\n    throw err;\n}\n\nmodule.exports = EventEmitter;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/errors.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar TypedError = require('error/typed');\nvar WrappedError = require('error/wrapped');\nvar bufrwErrors = require('bufrw/errors');\n\nvar Errors = module.exports;\n\n// All exported errors must be in sorted order\n\nErrors.Arg1Fragmented = TypedError({\n    type: 'tchannel.arg1-fragmented',\n    message: 'arg1 must not be fragmented'\n});\n\nErrors.Arg1OverLengthLimit = TypedError({\n    type: 'tchannel.arg1-over-length-limit',\n    message: 'arg1 length {length} is larger than the limit {limit}',\n    length: null,\n    limit: null\n});\n\nErrors.ArgChunkGapError = TypedError({\n    type: 'tchannel.arg-chunk.gap',\n    message: 'arg chunk gap, current: {current} got: {got}',\n    current: null,\n    got: null\n});\n\nErrors.ArgChunkOutOfOrderError = TypedError({\n    type: 'tchannel.arg-chunk.out-of-order',\n    message: 'out of order arg chunk, current: {current} got: {got}',\n    current: null,\n    got: null\n});\n\nErrors.ArgStreamExceededFramePartsError = TypedError({\n    type: 'tchannel.argstream.exceeded-frame-parts',\n    message: 'frame parts exceeded stream arity'\n});\n\nErrors.ArgStreamFinishedError = TypedError({\n    type: 'tchannel.argstream.finished',\n    message: 'arg stream already finished'\n});\n\nErrors.ArgStreamUnimplementedError = TypedError({\n    type: 'tchannel.argstream.unimplemented',\n    message: 'un-streamed argument defragmentation is not implemented'\n});\n\nErrors.ArgStreamUnknownFrameHandlingStateError = TypedError({\n    type: 'tchannel.argstream.unknown-frame-handling-state',\n    message: 'unknown frame handling state'\n});\n\nErrors.BadCallRequestFrameError = TypedError({\n    type: 'tchannel.bad-call-request',\n    message: 'Bad call request: {reason}',\n    reason: null\n});\n\nErrors.CallReqBeforeInitReqError = TypedError({\n    type: 'tchannel.init.call-request-before-init-request',\n    message: 'call request before init request'\n});\n\nErrors.CallReqContBeforeInitReqError = TypedError({\n    type: 'tchannel.init.call-request-cont-before-init-request',\n    message: 'call request cont before init request'\n});\n\nErrors.CallResBeforeInitResError = TypedError({\n    type: 'tchannel.init.call-response-before-init-response',\n    message: 'call response before init response'\n});\n\nErrors.CallResContBeforeInitResError = TypedError({\n    type: 'tchannel.init.call-response-cont-before-init-response',\n    message: 'call response cont before init response'\n});\n\nErrors.ChecksumError = TypedError({\n    type: 'tchannel.checksum',\n    message: 'invalid checksum (type {checksumType}) expected: {expectedValue} actual: {actualValue}',\n    checksumType: null,\n    expectedValue: null,\n    actualValue: null\n});\n\nErrors.ChecksumTypeChanged = TypedError({\n    type: 'tchannel.call.checksum-type-changed',\n    message: 'checksum type changed mid-stream',\n    initialChecksumType: null,\n    newChecksumType: null\n});\n\nErrors.ConnectionStaleTimeoutError = TypedError({\n    type: 'tchannel.connection-stale.timeout',\n    message: 'Connection got two timeouts in a row.\\n' +\n        'Connection has been marked as stale and will be timed out',\n    period: null,\n    elapsed: null,\n    lastTimeoutTime: null\n});\n\nErrors.ConnectionTimeoutError = TypedError({\n    type: 'tchannel.connection.timeout',\n    message: 'connection timed out after {elapsed}ms ' +\n        '(limit was {timeout}ms)',\n    id: null,\n    start: null,\n    elapsed: null,\n    timeout: null\n});\n\nErrors.CorruptWriteLazyFrame = TypedError({\n    type: 'tchannel.lazy-frame.write-corrupt',\n    message: 'could not serialize lazy frame due to {context}',\n    context: null\n});\n\nErrors.DuplicateHeaderKeyError = TypedError({\n    type: 'tchannel.duplicate-header-key',\n    message: 'duplicate header key {key}',\n    offset: null,\n    endOffset: null,\n    key: null,\n    value: null,\n    priorValue: null\n});\n\nErrors.DuplicateInitRequestError = TypedError({\n    type: 'tchannel.init.duplicate-init-request',\n    message: 'tchannel: duplicate init request'\n});\n\nErrors.DuplicateInitResponseError = TypedError({\n    type: 'tchannel.init.duplicate-init-response',\n    message: 'tchannel: duplicate init response'\n});\n\nErrors.EphemeralInitResponse = TypedError({\n    type: 'tchannel.init.ephemeral-init-response',\n    message: 'tchannel: got invalid 0.0.0.0:0 as hostPort in Init Response',\n    hostPort: null,\n    socketRemoteAddr: null,\n    processName: null\n});\n\nErrors.HTTPReqArg2fromBufferError = WrappedError({\n    type: 'tchannel.http-handler.from-buffer-arg2.req-failed',\n    message: 'Could not read from buffer when sending request.',\n    isSerializationError: true,\n    arg2: null\n});\n\nErrors.HTTPReqArg2toBufferError = WrappedError({\n    type: 'tchannel.http-handler.to-buffer-arg2.req-failed',\n    message: 'Could not write to buffer when sending request.',\n    isSerializationError: true,\n    head: null\n});\n\nErrors.HTTPResArg2fromBufferError = WrappedError({\n    type: 'tchannel.http-handler.from-buffer-arg2.res-failed',\n    message: 'Could not read from buffer when sending response.',\n    isSerializationError: true,\n    arg2: null\n});\n\nErrors.HTTPResArg2toBufferError = WrappedError({\n    type: 'tchannel.http-handler.to-buffer-arg2.res-failed',\n    message: 'Could not write to buffer when sending response.',\n    isSerializationError: true,\n    head: null\n});\n\nErrors.InAsHeaderRequired = TypedError({\n    type: 'tchannel.handler.incoming-req-as-header-required',\n    message: 'Expected incoming call {frame} to have \"as\" header set.',\n    frame: null\n});\n\nErrors.InCnHeaderRequired = TypedError({\n    type: 'tchannel.handler.incoming-req-cn-header-required',\n    message: 'Expected incoming call request to have \"cn\" header set.'\n});\n\nErrors.InvalidArgumentError = TypedError({\n    type: 'tchannel.invalid-argument',\n    message: 'invalid argument, expected array or null',\n    argType: null,\n    argConstructor: null\n});\n\nErrors.InvalidErrorCodeError = TypedError({\n    type: 'tchannel.invalid-error-code',\n    message: 'invalid tchannel error code {errorCode}',\n    errorCode: null,\n    originalId: null\n});\n\nErrors.InvalidFrameTypeError = TypedError({\n    type: 'tchannel.invalid-frame-type',\n    message: 'invalid frame type {typeNumber}',\n    typeNumber: null\n});\n\nErrors.InvalidHandlerError = TypedError({\n    type: 'tchannel.invalid-handler',\n    message: 'invalid handler function'\n});\n\nErrors.InvalidHandlerForRegister = TypedError({\n    type: 'tchannel.invalid-handler.for-registration',\n    message: 'Found unexpected handler when calling `.register()`.\\n' +\n        'You cannot set a custom handler when using `.register()`.\\n' +\n        '`.register()` is deprecated; use a proper handler.',\n    handlerType: null,\n    handler: null\n});\n\nErrors.InvalidHeaderTypeError = TypedError({\n    type: 'tchannel.invalid-header-type',\n    message: 'invalid header type for header {name}; ' +\n        'expected string, got {headerType}',\n    headerType: null,\n    name: null\n});\n\nErrors.InvalidInitHostPortError = TypedError({\n    type: 'tchannel.invalid-init-host-port',\n    message: 'invalid host:port string in init header',\n    hostPort: null\n});\n\nErrors.InvalidJSONBody = TypedError({\n    type: 'tchannel-handler.json.invalid-body',\n    message: 'Invalid error body, expected a typed-error',\n    isSerializationError: true,\n    head: null,\n    body: null\n});\n\nErrors.InvalidTTL = TypedError({\n    type: 'tchannel.protocol.invalid-ttl',\n    message: 'Got an invalid ttl. Expected positive ttl but got {ttl}',\n    ttl: null,\n    isParseError: null\n});\n\nErrors.JSONBodyParserError = WrappedError({\n    type: 'tchannel-json-handler.parse-error.body-failed',\n    message: 'Could not parse body (arg3) argument.\\n' +\n        'Expected JSON encoded arg3 for endpoint {endpoint}.\\n' +\n        'Got {bodyStr} instead of JSON.',\n    isSerializationError: true,\n    endpoint: null,\n    direction: null,\n    bodyStr: null\n});\n\nErrors.JSONBodyStringifyError = WrappedError({\n    type: 'tchannel-json-handler.stringify-error.body-failed',\n    message: 'Could not stringify body (res2) argument.\\n' +\n        'Expected JSON serializable res2 for endpoint {endpoint}.',\n    isSerializationError: true,\n    endpoint: null,\n    body: null,\n    direction: null\n});\n\nErrors.JSONHeadParserError = WrappedError({\n    type: 'tchannel-json-handler.parse-error.head-failed',\n    message: 'Could not parse head (arg2) argument.\\n' +\n        'Expected JSON encoded arg2 for endpoint {endpoint}.\\n' +\n        'Got {headStr} instead of JSON.',\n    isSerializationError: true,\n    endpoint: null,\n    direction: null,\n    headStr: null\n});\n\nErrors.JSONHeadStringifyError = WrappedError({\n    type: 'tchannel-json-handler.stringify-error.head-failed',\n    message: 'Could not stringify head (res1) argument.\\n' +\n        'Expected JSON serializable res1 for endpoint {endpoint}.',\n    isSerializationError: true,\n    endpoint: null,\n    head: null,\n    direction: null\n});\n\nErrors.LocalSocketCloseError = TypedError({\n    type: 'tchannel.socket-local-closed',\n    message: 'tchannel: Connection was manually closed.'\n});\n\nErrors.MaxPendingError = TypedError({\n    type: 'tchannel.max-pending',\n    message: 'maximum pending requests exceeded (limit was {pending})',\n    pending: null\n});\n\nErrors.MaxPendingForServiceError = TypedError({\n    type: 'tchannel.max-pending-for-service',\n    message: 'maximum pending requests exceeded for service (limit was {pending} for service {serviceName})',\n    pending: null,\n    serviceName: null\n});\n\nErrors.MissingInitHeaderError = TypedError({\n    type: 'tchannel.missing-init-header',\n    message: 'missing init frame header {field}',\n    field: null\n});\n\nErrors.NoPeerAvailable = TypedError({\n    type: 'tchannel.no-peer-available',\n    message: 'no peer available for request'\n});\n\nErrors.NoServiceHandlerError = TypedError({\n    type: 'tchannel.no-service-handler',\n    message: 'unknown service {serviceName}',\n    serviceName: null\n});\n\nErrors.NullKeyError = TypedError({\n    type: 'tchannel.null-key',\n    message: 'null key',\n    offset: null,\n    endOffset: null\n});\n\nErrors.OrphanCallRequestCont = TypedError({\n    type: 'tchannel.call-request.orphan-cont',\n    message: 'orphaned call request cont',\n    frameId: null\n});\n\nErrors.OrphanCallResponseCont = TypedError({\n    type: 'tchannel.call-response.orphan-cont',\n    message: 'orphaned call response cont',\n    frameId: null\n});\n\nErrors.OutAsHeaderRequired = TypedError({\n    type: 'tchannel.handler.outgoing-req-as-header-required',\n    message: 'Expected outgoing call request to have \"as\" header set.'\n});\n\nErrors.OutCnHeaderRequired = TypedError({\n    type: 'tchannel.handler.outgoing-req-cn-header-required',\n    message: 'Expected outgoing call request to have \"cn\" header set.'\n});\n\nErrors.ParentRequired = TypedError({\n    type: 'tchannel.tracer.parent-required',\n    message: 'parent not specified for outgoing call req.\\n' +\n        'Expected either a parent or hasNoParent.\\n' +\n        'For the call to {serviceName}.\\n',\n    parentSpan: null,\n    hasNoParent: null,\n    serviceName: null\n});\n\nErrors.PeerDrainTimedOutError = TypedError({\n    type: 'tchannel.drain.peer.timed-out',\n    message: 'peer drain timed out',\n    direction: null,\n    elapsed: null,\n    timeout: null\n});\n\nErrors.ReconstructedError = TypedError({\n    type: 'tchannel.hydrated-error.default-type',\n    message: 'TChannel json hydrated error;' +\n        ' this message should be replaced with an upstream error message'\n});\n\nErrors.RequestAlreadyDone = TypedError({\n    type: 'tchannel.request-already-done',\n    message: 'cannot {attempted}, request already done',\n    attempted: null\n});\n\nErrors.RequestDrained = TypedError({\n    type: 'tchannel.request.drained',\n    message: 'refusing to send drained request: {reason}',\n    reason: null\n});\n\nErrors.RequestFrameState = TypedError({\n    type: 'tchannel.request-frame-state',\n    message: 'cannot send {attempted} in {state} request state',\n    attempted: null,\n    state: null\n});\n\nErrors.RequestRetryLimitExceeded = TypedError({\n    type: 'tchannel.request.retry-limit-exceeded',\n    message: 'exceeded retry limit',\n    limit: null\n});\n\nErrors.RequestTimeoutError = TypedError({\n    type: 'tchannel.request.timeout',\n    message: 'request timed out after {elapsed}ms ' +\n        '(limit was {timeout}ms)',\n    id: null,\n    start: null,\n    elapsed: null,\n    timeout: null,\n    logical: false\n});\n\nErrors.ResponseAlreadyDone = TypedError({\n    type: 'tchannel.response-already-done',\n    message: 'cannot send {attempted}, response already done ' +\n        'in state: {currentState}',\n    attempted: null,\n    currentState: null\n});\n\nErrors.ResponseAlreadyStarted = TypedError({\n    type: 'tchannel.response-already-started',\n    message: 'response already started (state {state})',\n    state: null\n});\n\nErrors.ResponseFrameState = TypedError({\n    type: 'tchannel.response-frame-state',\n    message: 'cannot send {attempted} in {state} response state',\n    attempted: null,\n    state: null\n});\n\nErrors.SendCallReqBeforeIdentifiedError = TypedError({\n    type: 'tchannel.init.send-call-request-before-indentified',\n    message: 'cannot send call request before the connection is identified'\n});\n\nErrors.SendCallReqContBeforeIdentifiedError = TypedError({\n    type: 'tchannel.init.send-call-request-cont-before-indentified',\n    message: 'cannot send call request cont before the connection is identified'\n});\n\nErrors.SendCallResBeforeIdentifiedError = TypedError({\n    type: 'tchannel.init.send-call-response-before-indentified',\n    message: 'cannot send call response before the connection is identified'\n});\n\nErrors.SendCallResContBeforeIdentifiedError = TypedError({\n    type: 'tchannel.init.send-call-response-cont-before-indentified',\n    message: 'cannot send call response cont before the connection is identified'\n});\n\nErrors.SocketClosedError = TypedError({\n    type: 'tchannel.socket-closed',\n    message: 'socket closed, {reason}',\n    reason: null\n});\n\nErrors.SocketError = WrappedError({\n    type: 'tchannel.socket',\n    message: 'tchannel socket error ({code} from {syscall}): {origMessage}',\n    hostPort: null,\n    direction: null,\n    remoteAddr: null\n});\n\nErrors.SocketWriteFullError = TypedError({\n    type: 'tchannel.socket.write-full',\n    message: 'Could not write to socket; socket has {pendingWrites} writes',\n    pendingWrites: null\n});\n\nErrors.TChannelConnectionCloseError = TypedError({\n    type: 'tchannel.connection.close',\n    message: 'connection closed'\n});\n\nErrors.TChannelConnectionResetError = WrappedError({\n    type: 'tchannel.connection.reset',\n    message: 'tchannel: {causeMessage}'\n});\n\nErrors.TChannelDestroyedError = TypedError({\n    type: 'tchannel.destroyed',\n    message: 'the channel is destroyed'\n});\n\nErrors.TChannelListenError = WrappedError({\n    type: 'tchannel.server.listen-failed',\n    message: 'tchannel: {origMessage}, {host}:{requestedPort}',\n    requestedPort: null,\n    host: null\n});\n\nErrors.TChannelLocalResetError = WrappedError({\n    type: 'tchannel.local.reset',\n    message: 'tchannel: {causeMessage}'\n});\n\nErrors.TChannelReadProtocolError = WrappedError({\n    type: 'tchannel.protocol.read-failed',\n    message: 'tchannel read failure: {origMessage}',\n    remoteName: null,\n    localName: null\n});\n\nErrors.TChannelUnhandledFrameTypeError = TypedError({\n    type: 'tchannel.unhandled-frame-type',\n    message: 'unhandled frame type {typeCode}',\n    typeCode: null\n});\n\nErrors.TChannelWriteProtocolError = WrappedError({\n    type: 'tchannel.protocol.write-failed',\n    message: 'tchannel write failure: {origMessage}',\n    remoteName: null,\n    localName: null\n});\n\nErrors.ThriftBodyParserError = WrappedError({\n    type: 'tchannel-thrift-handler.parse-error.body-failed',\n    message: 'Could not parse body (arg3) argument.\\n' +\n        'Expected Thrift encoded arg3 for endpoint {endpoint}.\\n' +\n        'Got {bodyBuf} instead of Thrift.\\n' +\n        'Parsing error was: {causeMessage}.\\n',\n    isSerializationError: true,\n    endpoint: null,\n    direction: null,\n    ok: null,\n    bodyBuf: null\n});\n\nErrors.ThriftBodyStringifyError = WrappedError({\n    type: 'tchannel-thrift-handler.stringify-error.body-failed',\n    message: 'Could not stringify body (res2) argument.\\n' +\n        'Expected Thrift serializable res2 for endpoint {endpoint}.',\n    isSerializationError: true,\n    endpoint: null,\n    ok: null,\n    body: null,\n    direction: null\n});\n\nErrors.ThriftHeadParserError = WrappedError({\n    type: 'tchannel-thrift-handler.parse-error.head-failed',\n    message: 'Could not parse head (arg2) argument.\\n' +\n        'Expected Thrift encoded arg2 for endpoint {endpoint}.\\n' +\n        'Got {headBuf} instead of Thrift.\\n' +\n        'Parsing error was: {causeMessage}.\\n',\n    isSerializationError: true,\n    endpoint: null,\n    ok: null,\n    direction: null,\n    headBuf: null\n});\n\nErrors.ThriftHeadStringifyError = WrappedError({\n    type: 'tchannel-thrift-handler.stringify-error.head-failed',\n    message: 'Could not stringify head (res1) argument.\\n' +\n        'Expected Thrift serializable res1 for endpoint {endpoint}.',\n    isSerializationError: true,\n    endpoint: null,\n    ok: null,\n    head: null,\n    direction: null\n});\n\nErrors.TooManyHeaders = TypedError({\n    type: 'tchannel.protocol.too-many-headers',\n    message: 'too many transport headers, got {count}, expected at most {maxHeaderCount}',\n    count: null,\n    maxHeaderCount: null,\n    offset: null,\n    endOffset: null\n});\n\nErrors.TopLevelRegisterError = TypedError({\n    type: 'tchannel.top-level-register',\n    message: 'Cannot register endpoints points on top-level channel.\\n' +\n        'Provide serviceName to constructor, or create a sub-channel.'\n});\n\nErrors.TopLevelRequestError = TypedError({\n    type: 'tchannel.top-level-request',\n    message: 'Cannot make request() on top level tchannel.\\n' +\n        'Must use a sub channel directly.'\n});\n\nErrors.TransportHeaderTooLong = TypedError({\n    type: 'tchannel.transport-header-too-long',\n    message: 'transport header: {headerName} exceeds {maxLength} bytes',\n    maxLength: null,\n    headerName: null,\n    offset: null,\n    endOffset: null\n});\n\nErrors.UnexpectedCallFrameAfterDone = TypedError({\n    type: 'tchannel.call.frame-unexpected.after-done',\n    message: 'got call frame (type {frameType}) in done state',\n    frameId: null,\n    frameType: null\n});\n\nErrors.UnexpectedCallFrameAfterError = TypedError({\n    type: 'tchannel.call.frame-unexpected.after-error',\n    message: 'got call frame (type {frameType}) in error state',\n    frameId: null,\n    frameType: null\n});\n\nErrors.UnimplementedMethod = TypedError({\n    message: 'Unimplemented {className}#{methodName}',\n    type: 'tchannel.unimplemented-method',\n    className: null,\n    methodName: null\n});\n\nErrors.UnknownConnectionReset = TypedError({\n    type: 'tchannel.connection.unknown-reset',\n    message: 'unknown connection reset'\n});\n\n// utilities\n/*eslint-disable complexity*/\nErrors.classify = function classify(err) {\n    if (err.isErrorFrame) {\n        return err.codeName;\n    }\n\n    if (err.type && err.type.indexOf('bufrw.') > -1) {\n        return classifyBurwError(err);\n    }\n\n    switch (err.type) {\n        case 'tchannel.request.retry-limit-exceeded':\n            return 'Cancelled';\n\n        case 'tchannel.max-pending':\n        case 'tchannel.max-pending-for-service':\n        case 'tchannel.no-peer-available':\n        case 'tchannel.no-service-handler':\n        case 'tchannel.request.drained':\n            return 'Declined';\n\n        case 'tchannel.connection-stale.timeout':\n        case 'tchannel.connection.timeout':\n        case 'tchannel.request.timeout':\n            return 'Timeout';\n\n        case 'tchannel-handler.json.invalid-body':\n        case 'tchannel-json-handler.parse-error.body-failed':\n        case 'tchannel-json-handler.parse-error.head-failed':\n        case 'tchannel-thrift-handler.parse-error.body-failed':\n        case 'tchannel-thrift-handler.parse-error.head-failed':\n        case 'tchannel.arg-chunk.gap':\n        case 'tchannel.arg-chunk.out-of-order':\n        case 'tchannel.arg1-fragmented':\n        case 'tchannel.arg1-over-length-limit':\n        case 'tchannel.argstream.exceeded-frame-parts':\n        case 'tchannel.bad-call-request':\n        case 'tchannel.call.checksum-type-changed':\n        case 'tchannel.checksum':\n        case 'tchannel.duplicate-header-key':\n        case 'tchannel.handler.incoming-req-as-header-required':\n        case 'tchannel.handler.incoming-req-cn-header-required':\n        case 'tchannel.http-handler.to-buffer-arg2.req-failed':\n        case 'tchannel.http-handler.to-buffer-arg2.res-failed':\n        case 'tchannel.null-key':\n        case 'tchannel.request-already-done':\n        case 'tchannel.request-frame-state':\n            return 'BadRequest';\n\n        case 'tchannel.argstream.finished':\n        case 'tchannel.argstream.unimplemented':\n\n        // TODO: really we'd rather classify as BadRequest. see note in\n        // TChannelV2Handler#handleCallRequestCont wrt frame id association\n        // support\n        case 'tchannel.call-request.orphan-cont':\n\n        // TODO: can BadRequest be used for a response error? Maybe instead we\n        // could use UnexpectedError rather than terminate the connection?\n        case 'tchannel.call-response.orphan-cont':\n\n        // TODO: classify as BadRequest/UnexpectedError for req/res?\n        case 'tchannel.call.frame-unexpected.after-done':\n        case 'tchannel.call.frame-unexpected.after-error':\n\n        case 'tchannel.init.call-request-before-init-request':\n        case 'tchannel.init.call-request-cont-before-init-request':\n        case 'tchannel.init.call-response-before-init-response':\n        case 'tchannel.init.call-response-cont-before-init-response':\n        case 'tchannel.init.duplicate-init-request':\n        case 'tchannel.init.duplicate-init-response':\n        case 'tchannel.init.ephemeral-init-response':\n        case 'tchannel.init.send-call-request-before-indentified':\n        case 'tchannel.init.send-call-request-cont-before-indentified':\n        case 'tchannel.init.send-call-response-before-indentified':\n        case 'tchannel.init.send-call-response-cont-before-indentified':\n        case 'tchannel.invalid-error-code':\n        case 'tchannel.invalid-frame-type':\n        case 'tchannel.invalid-init-host-port':\n        case 'tchannel.missing-init-header':\n        case 'tchannel.protocol.invalid-ttl':\n        case 'tchannel.protocol.read-failed':\n        case 'tchannel.protocol.too-many-headers':\n        case 'tchannel.protocol.write-failed':\n        case 'tchannel.transport-header-too-long':\n        case 'tchannel.unhandled-frame-type':\n            return 'ProtocolError';\n\n        case 'tchannel.connection.close':\n        case 'tchannel.connection.reset':\n        case 'tchannel.destroyed':\n        case 'tchannel.local.reset':\n        case 'tchannel.socket':\n        case 'tchannel.socket-closed':\n        case 'tchannel.socket-local-closed':\n        case 'tchannel.socket.write-full':\n            return 'NetworkError';\n\n        case 'tchannel-json-handler.stringify-error.body-failed':\n        case 'tchannel-json-handler.stringify-error.head-failed':\n        case 'tchannel-thrift-handler.stringify-error.body-failed':\n        case 'tchannel-thrift-handler.stringify-error.head-failed':\n        case 'tchannel.argstream.unknown-frame-handling-state':\n        case 'tchannel.connection.unknown-reset':\n        case 'tchannel.drain.peer.timed-out':\n        case 'tchannel.handler.outgoing-req-as-header-required':\n        case 'tchannel.handler.outgoing-req-cn-header-required':\n        case 'tchannel.http-handler.from-buffer-arg2.req-failed':\n        case 'tchannel.http-handler.from-buffer-arg2.res-failed':\n        case 'tchannel.hydrated-error.default-type':\n        case 'tchannel.invalid-argument':\n        case 'tchannel.invalid-handler':\n        case 'tchannel.invalid-handler.for-registration':\n        case 'tchannel.invalid-header-type':\n        case 'tchannel.lazy-frame.write-corrupt':\n        case 'tchannel.response-already-done':\n        case 'tchannel.response-already-started':\n        case 'tchannel.response-frame-state':\n        case 'tchannel.server.listen-failed':\n        case 'tchannel.top-level-register':\n        case 'tchannel.top-level-request':\n        case 'tchannel.tracer.parent-required':\n        case 'tchannel.unimplemented-method':\n            return 'UnexpectedError';\n\n        default:\n            return null;\n    }\n};\n/*eslint-enable complexity*/\n\nfunction classifyBurwError(err) {\n    var bufrwClass = bufrwErrors.classify(err);\n    if (bufrwClass !== null) {\n        switch (bufrwClass) {\n            case 'Read':\n                return 'NetworkError';\n            case 'Write':\n                return 'ProtocolError';\n            case 'Internal':\n            default:\n                return 'UnexpectedError';\n        }\n    }\n}\n\n// To determine whether a circuit should break for each response code.\n// TODO consider whether to keep a circuit healthy if a downstream circuit is\n// unhealthy.\nErrors.isUnhealthy = function isUnhealthy(codeName) {\n    switch (codeName) {\n        // not an indicator of bad health\n        case 'BadRequest':\n        case 'Cancelled':\n            return false;\n\n        case 'Unhealthy':\n        case 'Timeout':\n        case 'Busy':\n        case 'Declined':\n        case 'UnexpectedError':\n        case 'NetworkError':\n        case 'ProtocolError':\n            return true;\n\n        default:\n            return null;\n    }\n};\n\nErrors.shouldRetry = function shouldRetry(codeName, retryFlags) {\n    switch (codeName) {\n        case 'BadRequest':\n        case 'Cancelled':\n        case 'Unhealthy':\n            return false;\n\n        case 'Busy':\n        case 'Declined':\n            return true;\n\n        case 'Timeout':\n            return !!retryFlags.onTimeout;\n\n        case 'NetworkError':\n        case 'ProtocolError':\n        case 'UnexpectedError':\n            return !!retryFlags.onConnectionError;\n\n        default:\n            return null;\n    }\n};\n\nfunction HTTPInfo(statusCode, statusMessage) {\n    this.statusCode = statusCode;\n    this.statusMessage = statusMessage;\n}\n\nErrors.toHTTPCode = function toHTTPCode(codeName) {\n    switch (codeName) {\n        case 'Cancelled':\n            return new HTTPInfo(500, 'TChannel Cancelled');\n\n        case 'Unhealthy':\n        case 'Declined':\n            return new HTTPInfo(503, 'Service Unavailable');\n\n        case 'Timeout':\n            return new HTTPInfo(504, 'Gateway Timeout');\n\n        case 'BadRequest':\n            return new HTTPInfo(400, 'Bad Request');\n\n        case 'Busy':\n            return new HTTPInfo(429, 'Too Many Requests');\n\n        case 'ProtocolError':\n            return new HTTPInfo(500, 'TChannel Protocol Error');\n\n        case 'NetworkError':\n            return new HTTPInfo(500, 'TChannel Network Error');\n\n        case 'UnexpectedError':\n            return new HTTPInfo(500, 'TChannel Unexpected Error');\n\n        default:\n            return new HTTPInfo(500, 'Internal Server Error');\n    }\n};\n\nErrors.isFatal = function isFatal(err, codeName) {\n    if (!codeName) {\n        codeName = Errors.classify(err);\n    }\n    switch (codeName) {\n        case 'Busy':\n        case 'Cancelled':\n        case 'Declined':\n        case 'NetworkError':\n        case 'Timeout':\n        case 'Unhealthy':\n            return false;\n\n        case 'BadRequest':\n        case 'ProtocolError':\n        case 'UnexpectedError':\n            return true;\n\n        default:\n            return true;\n    }\n};\n\n/*eslint complexity: [2, 15]*/\nErrors.logLevel = function errorLogLevel(err, codeName) {\n    switch (codeName) {\n        case 'ProtocolError':\n        case 'UnexpectedError':\n            if (err.isErrorFrame || Errors.isParseError(err)) {\n                return 'warn';\n            }\n            return 'error';\n\n        case 'Busy':\n        case 'Cancelled':\n        case 'Declined':\n        case 'NetworkError':\n        case 'Unhealthy':\n            return 'warn';\n\n        case 'BadRequest':\n        case 'Timeout':\n            return 'info';\n\n        default:\n            return 'error';\n    }\n};\n\n/*  Whether we should increase peer.pending on an error frame.\n\n    On Busy & Declined we increase the pending count for a peer\n    to allow peer selection to favor less loaded peers.\n*/\nErrors.isPendingError = function isPendingError(codeName) {\n    switch (codeName) {\n        case 'Busy':\n        case 'Declined':\n        case 'Unhealthy':\n            return true;\n\n        case 'BadRequest':\n        case 'Cancelled':\n        case 'NetworkError':\n        case 'ProtocolError':\n        case 'Timeout':\n        case 'UnexpectedError':\n            return false;\n\n        default:\n            return false;\n    }\n};\n\nErrors.isParseError = function isParseError(error) {\n    return error.isParseError || false;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/request-handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\n\n// This function allows EndpointHandler to accept either a callback or a\n// RequestHandler object that implements handleRequest.\n\nmodule.exports = coerceRequestHandler;\n\nfunction coerceRequestHandler(handler, thisp, options) {\n    if (typeof handler === 'function') {\n        if (options.streamed) {\n            return new StreamedRequestCallbackHandler(handler, thisp);\n        } else {\n            return new RequestCallbackHandler(handler, thisp);\n        }\n    } else {\n        assert(typeof handler.handleRequest === 'function', 'handler must have handleRequest method');\n        return handler;\n    }\n}\n\n// The non-streamed request handler is only for the cases where neither the\n// request or response can have streams. In this case, a req.stream indicates\n// that the request is fragmented across multiple frames.\nfunction RequestCallbackHandler(callback, thisp) {\n    var self = this;\n    self.callback = callback;\n    self.thisp = thisp || self;\n}\n\nRequestCallbackHandler.prototype.handleRequest = function handleRequest(req, buildResponse) {\n    var self = this;\n    var res;\n    if (req.streamed) {\n        req.withArg23(function onArg23(err, arg2, arg3) {\n            if (err) {\n                req.channel.logger.warn(\n                    'Could not parse arg2/arg3 for streaming inreq',\n                    req.extendLogInfo({\n                        error: err\n                    })\n                );\n\n                req.emitError(err);\n                return;\n            }\n\n            if (req.res && req.res.responseAlreadyDone()) {\n                return;\n            }\n\n            res = buildResponse({streamed: false});\n            self.callback.call(self.thisp, req, res, arg2, arg3);\n        });\n    } else {\n        res = buildResponse({streamed: false});\n        self.callback.call(self.thisp, req, res, req.arg2, req.arg3);\n    }\n};\n\n// The streamed request handler is for cases where the handler function elects\n// to deal with whether req.streamed and whether res.streamed.\n// req.streamed may indicated either a streaming request or a fragmented\n// request and the handler must distinguish the cases.\nfunction StreamedRequestCallbackHandler(callback, thisp) {\n    var self = this;\n    self.callback = callback;\n    self.thisp = thisp || self;\n}\n\nStreamedRequestCallbackHandler.prototype.handleRequest = function handleRequest(req, buildResponse) {\n    var self = this;\n    return self.callback.call(self.thisp, req, buildResponse);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = TChannelRequest;\n\nvar assert = require('assert');\nvar EventEmitter = require('./lib/event_emitter');\nvar inherits = require('util').inherits;\nvar process = require('process');\nvar stat = require('./stat-tags.js');\n\nvar RetryFlags = require('./retry-flags.js');\nvar errors = require('./errors');\n\nfunction TChannelRequest(options) {\n    /*eslint max-statements: [2, 40]*/\n    assert(!options.streamed, 'streaming request federation not implemented');\n\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.responseEvent = this.defineEvent('response');\n\n    this.channel = options.channel;\n\n    this.options = options;\n\n    this.triedRemoteAddrs = null;\n    this.outReqs = [];\n    this.timeout = this.options.timeout || TChannelRequest.defaultTimeout;\n    if (this.options.timeoutPerAttempt) {\n        this.options.retryFlags = new RetryFlags(\n            this.options.retryFlags.never,\n            this.options.retryFlags.onConnectionError,\n            true\n        );\n    }\n    this.timeoutPerAttempt = this.options.timeoutPerAttempt || this.timeout;\n    this.limit = this.options.retryLimit || TChannelRequest.defaultRetryLimit;\n    this.start = 0;\n    this.end = 0;\n    this.elapsed = 0;\n    this.resendSanity = 0;\n    this.trackPending = this.options.trackPending || false;\n\n    this.serviceName = options.serviceName || '';\n    this.callerName = options.headers && options.headers.cn || '';\n    // so that as-foo can punch req.headers.X\n    this.headers = this.options.headers;\n\n    this.endpoint = null;\n    this.arg1 = null;\n    this.arg2 = null;\n    this.arg3 = null;\n\n    this.err = null;\n    this.res = null;\n}\n\ninherits(TChannelRequest, EventEmitter);\n\nTChannelRequest.defaultRetryLimit = 5;\nTChannelRequest.defaultTimeout = 100;\n\nfunction RequestOperation(req, timeout, peer, waitForIdentifiedSlot) {\n    this.req = req;\n    this.timeout = timeout;\n    this.peer = peer;\n    this.waitForIdentifiedSlot =\n        typeof waitForIdentifiedSlot === 'number' ?\n        waitForIdentifiedSlot : -1;\n}\n\nRequestOperation.prototype.onTimeout = function onTimeout(now) {\n    if (this.waitForIdentifiedSlot !== -1) {\n        this.peer.stopWaitingForIdentified(this.waitForIdentifiedSlot);\n    }\n\n    this.req.checkTimeout();\n};\n\nTChannelRequest.prototype.type = 'tchannel.request';\n\nTChannelRequest.prototype.emitError = function emitError(err) {\n    var self = this;\n    if (!self.end) {\n        self.end = self.channel.timers.now();\n    }\n    self.err = err;\n\n    self.emitErrorStat(err);\n    self.emitLatency();\n\n    self.channel.services.onRequestError(self);\n    self.errorEvent.emit(self, err);\n};\n\nTChannelRequest.prototype.emitErrorStat =\nfunction emitErrorStat(err) {\n    var self = this;\n\n    if (err.isErrorFrame) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.system-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsSystemErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                err.codeName,\n                self.retryCount\n            )\n        );\n    } else {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.operational-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsOperationalErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                err.type || 'unknown'\n            )\n        );\n    }\n};\n\nTChannelRequest.prototype.emitLatency =\nfunction emitLatency() {\n    var self = this;\n\n    var latency = self.end - self.start;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.latency',\n        'timing',\n        latency,\n        new stat.OutboundCallsLatencyTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n};\n\nTChannelRequest.prototype.emitResponse = function emitResponse(res) {\n    var self = this;\n    if (!self.end) {\n        self.end = self.channel.timers.now();\n    }\n    self.res = res;\n\n    self.arg1 = null;\n    self.arg2 = null;\n    self.arg3 = null;\n\n    self.emitResponseStat(res);\n    self.emitLatency();\n\n    self.channel.services.onRequestResponse(self);\n    self.responseEvent.emit(self, res);\n};\n\nTChannelRequest.prototype.emitResponseStat =\nfunction emitResponseStat(res) {\n    var self = this;\n\n    if (res.ok) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.success',\n            'counter',\n            1,\n            new stat.OutboundCallsSuccessTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint\n            )\n        );\n    } else {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.app-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsAppErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                'unknown'\n            )\n        );\n    }\n};\n\nTChannelRequest.prototype.hookupStreamCallback = function hookupCallback(callback) {\n    throw new Error('not implemented');\n};\n\nTChannelRequest.prototype.hookupCallback = function hookupCallback(callback) {\n    var self = this;\n    if (callback.canStream) {\n        return self.hookupStreamCallback(callback);\n    }\n    var called = false;\n\n    self.errorEvent.on(onError);\n    self.responseEvent.on(onResponse);\n\n    function onError(err) {\n        if (called) {\n            return;\n        }\n        called = true;\n\n        callback(err, null, null, null);\n    }\n\n    function onResponse(res) {\n        if (called) {\n            return;\n        }\n        called = true;\n        res.withArg23(function gotArg23(err, arg2, arg3) {\n            callback(err, res, arg2, arg3);\n        });\n    }\n\n    return self;\n};\n\nTChannelRequest.prototype.choosePeer = function choosePeer() {\n    var self = this;\n    return self.channel.peers.choosePeer(self);\n};\n\nTChannelRequest.prototype.send = function send(arg1, arg2, arg3, callback) {\n    var self = this;\n\n    self.endpoint = String(arg1);\n    self.arg1 = arg1;\n    self.arg2 = arg2;\n    self.arg3 = arg3;\n    if (callback) {\n        self.hookupCallback(callback);\n    }\n    self.start = self.channel.timers.now();\n    self.resendSanity = self.limit;\n\n    self.emitOutboundCallsSent();\n\n    self.channel.services.onRequest(self);\n    self.resend();\n};\n\nTChannelRequest.prototype.emitOutboundCallsSent =\nfunction emitOutboundCallsSent() {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.sent',\n        'counter',\n        1,\n        new stat.OutboundCallsSentTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n};\n\nTChannelRequest.prototype.resend = function resend() {\n    var self = this;\n\n    if (self.channel.enableMaxRetryRatio) {\n        var isRetry = self.outReqs.length > 0;\n        self.channel.retryRatioTracker.incrementRequest(isRetry);\n    }\n\n    if (self.trackPending && self.checkPending()) {\n        return;\n    }\n\n    if (self.checkTimeout()) {\n        return;\n    }\n\n    var peer = self.choosePeer();\n    if (!peer) {\n        var lastReq = self.outReqs.length &&\n                      self.outReqs[self.outReqs.length - 1];\n        if (!lastReq) {\n            self.emitError(errors.NoPeerAvailable());\n        } else if (lastReq.err) {\n            self.emitError(lastReq.err);\n        } else if (lastReq.res) {\n            self.emitResponse(lastReq.res);\n        } else {\n            // TODO: perhaps a different typed error \"last request didn't even\n            // error?\"\n            self.emitError(errors.NoPeerAvailable());\n        }\n        return;\n    }\n\n    var conn = peer.getInConnection(true);\n    var reqTimeout;\n    if (conn && conn.remoteName && !conn.closing) {\n        self.onIdentified(peer);\n    } else {\n        var waitForIdentifiedSlot = peer.waitForIdentified(onIdentified);\n\n        var now = self.channel.timers.now();\n        self.elapsed = now - self.start;\n        var timeout = self.timeout - self.elapsed;\n        var reqOp = new RequestOperation(\n            self, timeout, peer, waitForIdentifiedSlot\n        );\n        reqTimeout = self.channel.timeHeap.update(reqOp, now);\n    }\n\n    function onIdentified(err) {\n        reqTimeout.cancel();\n\n        if (err) {\n            /* emulate outReq failure */\n\n            self.outReqs.push({\n                err: err\n            });\n            if (!self.triedRemoteAddrs) {\n                self.triedRemoteAddrs = {};\n            }\n            self.triedRemoteAddrs[peer.hostPort] =\n                (self.triedRemoteAddrs[peer.hostPort] || 0) + 1;\n\n            return self.onSubreqError(err);\n        }\n\n        self.onIdentified(peer);\n    }\n};\n\nTChannelRequest.prototype.onIdentified = function onIdentified(peer) {\n    var self = this;\n\n    if (self.checkTimeout()) {\n        return;\n    }\n\n    var opts = {};\n    var keys = Object.keys(self.options);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        opts[key] = self.options[key];\n    }\n    opts.timeout = self.timeout - self.elapsed;\n    if (opts.timeout > self.timeoutPerAttempt) {\n        opts.timeout = self.timeoutPerAttempt;\n    }\n\n    opts.peer = peer;\n    opts.retryCount = self.outReqs.length;\n    opts.logical = true;\n\n    var outReq = peer.request(opts);\n    self.outReqs.push(outReq);\n\n    if (self.outReqs.length !== 1) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.retries',\n            'counter',\n            1,\n            new stat.OutboundCallsRetriesTags(\n                outReq.serviceName,\n                outReq.callerName,\n                String(self.arg1),\n                self.outReqs.length - 1\n            ));\n    }\n\n    if (!self.triedRemoteAddrs) {\n        self.triedRemoteAddrs = {};\n    }\n    self.triedRemoteAddrs[outReq.remoteAddr] =\n        (self.triedRemoteAddrs[outReq.remoteAddr] || 0) + 1;\n    outReq.responseEvent.on(onResponse);\n    outReq.errorEvent.on(onError);\n    outReq.send(self.arg1, self.arg2, self.arg3);\n\n    function onError(err) {\n        self.onSubreqError(err);\n    }\n\n    function onResponse(res) {\n        self.onSubreqResponse(res);\n    }\n};\n\nTChannelRequest.prototype.onSubreqError = function onSubreqError(err) {\n    var self = this;\n    if (self.checkTimeout(err)) {\n        return;\n    }\n    if (self.shouldRetryError(err)) {\n        self.deferResend();\n    } else {\n        self.emitError(err);\n    }\n};\n\nTChannelRequest.prototype.onSubreqResponse = function onSubreqResponse(res) {\n    var self = this;\n    if (self.checkTimeout(null, res)) {\n        return;\n    }\n    if (res.ok) {\n        self.emitResponse(res);\n    } else if (self.options.shouldApplicationRetry) {\n        self.maybeAppRetry(res);\n    } else {\n        self.emitResponse(res);\n    }\n};\n\nTChannelRequest.prototype.deferResend = function deferResend() {\n    var self = this;\n    if (--self.resendSanity < 0) {\n        self.emitError(errors.RequestRetryLimitExceeded({\n            limit: self.limit\n        }));\n    } else {\n        process.nextTick(doResend);\n    }\n    function doResend() {\n        self.resend();\n    }\n};\n\nTChannelRequest.prototype.checkPending = function checkPending() {\n    var self = this;\n    var err = self.channel.services.errorIfExceedsMaxPending(self);\n    if (err) {\n        self.emitError(err);\n        return true;\n    }\n    return false;\n};\n\nTChannelRequest.prototype.checkTimeout = function checkTimeout(err, res) {\n    var self = this;\n    var now = self.channel.timers.now();\n    self.elapsed = now - self.start;\n    if (self.elapsed < self.timeout) {\n        return false;\n    }\n\n    if (err) {\n        if (!self.err) {\n            self.emitError(err);\n        }\n    } else if (res) {\n        if (!self.err && !self.res) {\n            self.emitResponse(res);\n        }\n    } else if (!self.err) {\n        self.emitError(errors.RequestTimeoutError({\n            start: self.start,\n            elapsed: self.elapsed,\n            timeout: self.timeout\n        }));\n    }\n    return true;\n};\n\nTChannelRequest.prototype.shouldRetryError = function shouldRetryError(err) {\n    var self = this;\n\n    if (self.outReqs.length > self.limit) {\n        return false;\n    }\n\n    if (self.options.retryFlags.never) {\n        return false;\n    }\n\n    if (self.channel.enableMaxRetryRatio &&\n        self.channel.retryRatioTracker.isWarmedUp() &&\n        self.channel.retryRatioTracker.currentRetryRatio() >= self.channel.maxRetryRatio\n    ) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.retries-rejected-by-max-retry-ratio',\n            'counter',\n            1,\n            new stat.OutboundCallsRetriesTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                self.outReqs.length - 1\n            )\n        );\n        return false;\n    }\n\n    if (err) {\n        var codeName = errors.classify(err);\n\n        var shouldRetry = errors.shouldRetry(codeName, self.options.retryFlags);\n        if (shouldRetry === null) {\n            self.channel.logger.error('unknown error type in request retry', {\n                error: err\n            });\n            return true;\n        }\n\n        return shouldRetry;\n    }\n\n    return false;\n};\n\nTChannelRequest.prototype.maybeAppRetry = function maybeAppRetry(res) {\n    var self = this;\n    self.options.shouldApplicationRetry(self, res, retry, done);\n\n    function retry() {\n        if (self.checkTimeout(null, res)) {\n            return;\n        }\n\n        self.deferResend();\n    }\n\n    function done(err) {\n        if (err) {\n            self.emitError(err);\n        } else {\n            self.emitResponse(res);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/stat-tags.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar BatchStatsd = require('./lib/statsd.js');\nvar clean = BatchStatsd.clean;\nvar cleanHostPort = BatchStatsd.cleanHostPort;\n\nmodule.exports = {\n    InboundCallsRecvdTags: InboundCallsRecvdTags,\n    OutboundCallsSuccessTags: OutboundCallsSuccessTags,\n    OutboundCallsLatencyTags: OutboundCallsLatencyTags,\n    OutboundCallsSentTags: OutboundCallsSentTags,\n    OutboundCallsAppErrorsTags: OutboundCallsAppErrorsTags,\n    OutboundCallsPerAttemptLatencyTags: OutboundCallsPerAttemptLatencyTags,\n    OutboundCallsPerAttemptAppErrorsTags: OutboundCallsPerAttemptAppErrorsTags,\n    OutboundCallsSystemErrorsTags: OutboundCallsSystemErrorsTags,\n    OutboundCallsOperationalErrorsTags: OutboundCallsOperationalErrorsTags,\n    OutboundCallsPerAttemptOperationalErrorsTags: OutboundCallsPerAttemptOperationalErrorsTags,\n    OutboundCallsRetriesTags: OutboundCallsRetriesTags,\n    InboundCallsLatencyTags: InboundCallsLatencyTags,\n    InboundCallsSuccessTags: InboundCallsSuccessTags,\n    InboundCallsAppErrorsTags: InboundCallsAppErrorsTags,\n    InboundCallsSystemErrorsTags: InboundCallsSystemErrorsTags,\n    InboundRequestSizeTags: InboundRequestSizeTags,\n    ConnectionsBytesRcvdTags: ConnectionsBytesRcvdTags,\n    InboundResponseSizeTags: InboundResponseSizeTags,\n    OutboundRequestSizeTags: OutboundRequestSizeTags,\n    ConnectionsBytesSentTags: ConnectionsBytesSentTags,\n    OutboundResponseSizeTags: OutboundResponseSizeTags,\n    RateLimiterServiceTags: RateLimiterServiceTags,\n    RateLimiterEdgeTags: RateLimiterEdgeTags,\n    RateLimiterEmptyTags: RateLimiterEmptyTags,\n    InboundProtocolErrorsTags: InboundProtocolErrorsTags,\n    ConnectionsActiveTags: ConnectionsActiveTags,\n    ConnectionsInitiatedTags: ConnectionsInitiatedTags,\n    ConnectionsConnectErrorsTags: ConnectionsConnectErrorsTags,\n    ConnectionsAcceptedTags: ConnectionsAcceptedTags,\n    ConnectionsAcceptErrorsTags: ConnectionsAcceptErrorsTags,\n    ConnectionsErrorsTags: ConnectionsErrorsTags,\n    ConnectionsClosedTags: ConnectionsClosedTags,\n    RelayLatencyTags: RelayLatencyTags,\n    HTTPHanlderBuildLatencyTags: HTTPHanlderBuildLatencyTags,\n    ObjectPoolTags: ObjectPoolTags\n};\n\nfunction InboundCallsRecvdTags(cn, serviceName, endpoint) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.callingService = cn || '';\n    this.service = serviceName;\n    this.endpoint = endpoint;\n}\n\nInboundCallsRecvdTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint');\n};\n\nfunction OutboundCallsAppErrorsTags(serviceName, cn, endpoint, type) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.type = type;\n}\n\nOutboundCallsAppErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction OutboundCallsSuccessTags(serviceName, cn, endpoint) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n}\n\nOutboundCallsSuccessTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint');\n};\n\nfunction OutboundCallsPerAttemptAppErrorsTags(\n    serviceName, cn, endpoint, type, retryCount\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.type = type;\n    this.retryCount = retryCount;\n}\n\nOutboundCallsPerAttemptAppErrorsTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type') + '.' +\n        this.retryCount;\n};\n\nfunction OutboundCallsSystemErrorsTags(\n    serviceName, cn, endpoint, type, retryCount\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.type = type;\n    this.retryCount = retryCount;\n}\n\nOutboundCallsSystemErrorsTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction OutboundCallsOperationalErrorsTags(\n    serviceName, cn, endpoint, type\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.type = type;\n}\n\nOutboundCallsOperationalErrorsTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction OutboundCallsPerAttemptOperationalErrorsTags(\n    serviceName, cn, endpoint, type, retryCount\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.type = type;\n    this.retryCount = retryCount;\n}\n\nOutboundCallsPerAttemptOperationalErrorsTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type') + '.' +\n        this.retryCount;\n};\n\nfunction OutboundCallsRetriesTags(\n    serviceName, cn, endpoint, retryCount\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.retryCount = retryCount;\n}\n\nOutboundCallsRetriesTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        this.retryCount;\n};\n\nfunction OutboundCallsPerAttemptLatencyTags(\n    serviceName, cn, endpoint, remoteAddr, retryCount\n) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n    this.peer = remoteAddr;\n    this.retryCount = retryCount;\n}\n\nOutboundCallsPerAttemptLatencyTags.prototype.toStatKey =\nfunction toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint') + '.' +\n        this.retryCount;\n};\n\nfunction OutboundCallsLatencyTags(serviceName, cn, endpoint) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n}\n\nOutboundCallsLatencyTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint');\n};\n\nfunction OutboundCallsSentTags(serviceName, cn, endpoint) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n}\n\nOutboundCallsSentTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint');\n};\n\nfunction InboundCallsLatencyTags(cn, serviceName, endpoint) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n}\n\nInboundCallsLatencyTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint');\n};\n\nfunction InboundCallsSuccessTags(cn, serviceName, endpoint) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n}\n\nInboundCallsSuccessTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint');\n};\n\nfunction InboundCallsAppErrorsTags(cn, serviceName, endpoint, type) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n    this.type = type;\n}\n\nInboundCallsAppErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction InboundCallsSystemErrorsTags(cn, serviceName, endpoint, type) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n    this.type = type;\n}\n\nInboundCallsSystemErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction InboundRequestSizeTags(cn, serviceName, endpoint) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n}\n\nInboundRequestSizeTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint');\n};\n\nfunction ConnectionsBytesRcvdTags(hostPort, peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n}\n\nConnectionsBytesRcvdTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction InboundResponseSizeTags(cn, serviceName, endpoint) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.callingService = cn;\n    this.service = serviceName;\n    this.endpoint = endpoint;\n}\n\nInboundResponseSizeTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callingService, 'no-calling-service') + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.endpoint, 'no-endpoint');\n};\n\nfunction OutboundRequestSizeTags(serviceName, cn, endpoint) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n}\n\nOutboundRequestSizeTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint');\n};\n\nfunction ConnectionsBytesSentTags(hostPort, peer) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peer;\n}\n\nConnectionsBytesSentTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction OutboundResponseSizeTags(serviceName, cn, endpoint) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.targetService = serviceName;\n    this.service = cn;\n    this.targetEndpoint = endpoint;\n}\n\nOutboundResponseSizeTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.service, 'no-service') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        clean(this.targetEndpoint, 'no-endpoint');\n};\n\nfunction RateLimiterServiceTags(serviceName) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.targetService = serviceName;\n}\n\nRateLimiterServiceTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.targetService, 'no-target-service');\n};\n\nfunction RateLimiterEdgeTags(edgeName) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.edgeName = edgeName;\n}\n\nRateLimiterEdgeTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.edgeName, 'no-edge-name');\n};\n\nfunction RateLimiterEmptyTags() {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n}\n\nRateLimiterEmptyTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix;\n};\n\nfunction InboundProtocolErrorsTags(peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.peerHostPort = peerHostPort;\n}\n\nInboundProtocolErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction ConnectionsActiveTags(hostPort, peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n}\n\nConnectionsActiveTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction ConnectionsInitiatedTags(hostPort, peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n}\n\nConnectionsInitiatedTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction ConnectionsConnectErrorsTags(hostPort, peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n}\n\nConnectionsConnectErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction ConnectionsAcceptedTags(hostPort, peerHostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n}\n\nConnectionsAcceptedTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port');\n};\n\nfunction ConnectionsAcceptErrorsTags(hostPort) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n}\n\nConnectionsAcceptErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.hostPort, 'no-host-port');\n};\n\nfunction ConnectionsErrorsTags(peerHostPort, type) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.peerHostPort = peerHostPort;\n    this.type = type;\n}\n\nConnectionsErrorsTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port') + '.' +\n        clean(this.type, 'no-type');\n};\n\nfunction ConnectionsClosedTags(hostPort, peerHostPort, reason) {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n\n    this.hostPort = hostPort;\n    this.peerHostPort = peerHostPort;\n    this.reason = reason;\n}\n\nConnectionsClosedTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        cleanHostPort(this.peerHostPort, 'no-peer-host-port') + '.' +\n        clean(this.reason, 'no-reason');\n};\n\nfunction RelayLatencyTags() {\n    this.app = null;\n    this.host = null;\n    this.cluster = null;\n    this.version = null;\n}\n\nRelayLatencyTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix;\n};\n\nfunction HTTPHanlderBuildLatencyTags(serviceName, callerName, streamed) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.targetService = serviceName;\n    this.callerName = callerName;\n    this.streamed = streamed;\n}\n\nHTTPHanlderBuildLatencyTags.prototype.toStatKey = function toStatKey(prefix) {\n    return prefix + '.' +\n        clean(this.callerName, 'no-caller-name') + '.' +\n        clean(this.targetService, 'no-target-service') + '.' +\n        (this.streamed ? 'streamed' : 'unstreamed');\n};\n\nfunction ObjectPoolTags(poolName, statType) {\n    this.app = '';\n    this.host = '';\n    this.cluster = '';\n    this.version = '';\n\n    this.poolName = poolName;\n    this.statType = statType;\n\n    this._cachedPrefix = '';\n    this._key = '';\n}\n\nObjectPoolTags.prototype.toStatKey = function toStatKey(prefix) {\n    // prefix should never change but we store it in _cachedPrefix just in case\n    if (!this._key || prefix !== this._cachedPrefix) {\n        this._key = prefix + '.' + this.poolName + '.' + this.statType;\n        this._cachedPrefix = prefix;\n    }\n    return this._key;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/statsd.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\n\nvar STAT_EMIT_PERIOD = 100;\n\nBatchStatsd.clean = clean;\nBatchStatsd.cleanHostPort = cleanHostPort;\nBatchStatsd.BaseStat = BaseStat;\n\nvar LENGTH_ARRAYS = {};\n\nfunction BatchStatsd(options) {\n    assert(options.logger, 'options.logger required');\n    assert(options.timers, 'options.timers required');\n\n    // required: 'app'\n    // optional: 'host', 'cluster', 'version'\n    assert(!options.baseTags || options.baseTags.app,\n        'the stats must have the \"app\" tag');\n\n    this.statsd = options.statsd;\n    this.logger = options.logger;\n    this.timers = options.timers;\n    this.baseTags = new StatTags(options.baseTags);\n\n    this.statsQueue = [];\n    this.batchStatTimer = null;\n    this.boundFlushStats = boundFlushStats;\n\n    var self = this;\n\n    function boundFlushStats() {\n        self.flushStats();\n    }\n}\n\nBatchStatsd.prototype.pushStat = function pushStat(name, type, value, tags) {\n    var self = this;\n\n    tags.app = self.baseTags.app;\n    tags.host = self.baseTags.host;\n    tags.cluster = self.baseTags.cluster;\n    tags.version = self.baseTags.version;\n\n    var stat = new BaseStat(name, type, value, tags);\n\n    self.statsQueue.push(stat);\n\n    return stat;\n};\n\nBatchStatsd.prototype.handleStat = function handleStat(stat) {\n    var self = this;\n\n    if (!self.statsd) {\n        return;\n    }\n\n    var key = stat.tags.toStatKey(stat.name);\n\n    if (stat.type === 'counter') {\n        self.statsd.increment(key, stat.value);\n    } else if (stat.type === 'gauge') {\n        self.statsd.gauge(key, stat.value);\n    } else if (stat.type === 'timing') {\n        self.statsd.timing(key, stat.value);\n    } else {\n        self.logger.error('Trying to emit an invalid stat object', {\n            statType: stat.type,\n            statName: stat.name\n        });\n    }\n};\n\nBatchStatsd.prototype.flushStats = function flushStats() {\n    var self = this;\n\n    if (self.batchStatTimer) {\n        self.timers.clearTimeout(self.batchStatTimer);\n    }\n\n    for (var i = 0; i < self.statsQueue.length; i++) {\n        self.handleStat(self.statsQueue[i]);\n    }\n    self.statsQueue.length = 0;\n\n    self.batchStatTimer = self.timers.setTimeout(\n        self.boundFlushStats, STAT_EMIT_PERIOD\n    );\n};\n\nBatchStatsd.prototype.destroy = function destroy() {\n    var self = this;\n\n    self.flushStats();\n\n    self.timers.clearTimeout(self.batchStatTimer);\n};\n\nmodule.exports = BatchStatsd;\n\nfunction BaseStat(name, type, value, tags) {\n    var self = this;\n\n    self.name = name;\n    self.type = type;\n    self.value = value;\n    self.tags = tags || {};\n}\n\nfunction StatTags(opts) {\n    var self = this;\n\n    self.app = '';\n    self.host = '';\n    self.cluster = '';\n    self.version = '';\n\n    if (opts) {\n        if (opts.app) {\n            self.app = opts.app;\n        }\n        if (opts.host) {\n            self.host = opts.host;\n        }\n        if (opts.cluster) {\n            self.cluster = opts.cluster;\n        }\n        if (opts.version) {\n            self.version = opts.version;\n        }\n    }\n}\n\nfunction clean(str, field) {\n    var copy;\n\n    if (!str) {\n        return field;\n    }\n\n    copy = LENGTH_ARRAYS[str.length];\n    if (!copy) {\n        copy = LENGTH_ARRAYS[str.length] = [];\n    }\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char === ':' ||\n            char === '/' ||\n            char === '.' ||\n            char === '{' ||\n            char === '}'\n        ) {\n            copy[i] = '-';\n        } else {\n            copy[i] = char;\n        }\n    }\n\n    return copy.join('');\n}\n\nfunction cleanHostPort(str, field) {\n    var copy;\n\n    if (!str) {\n        return field;\n    }\n\n    var length = str.indexOf(':');\n\n    copy = LENGTH_ARRAYS[length];\n    if (!copy) {\n        copy = LENGTH_ARRAYS[length] = [];\n    }\n    for (var i = 0; i < length; i++) {\n        var char = str[i];\n\n        if (char === '/' ||\n            char === '.' ||\n            char === '{' ||\n            char === '}'\n        ) {\n            copy[i] = '-';\n        } else {\n            copy[i] = char;\n        }\n    }\n\n    return copy.join('');\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/retry-flags.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = RetryFlags;\n\nfunction RetryFlags(never, onConnectionError, onTimeout) {\n    this.never = never;\n    this.onConnectionError = onConnectionError;\n    this.onTimeout = onTimeout;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/service-name-handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar errors = require('./errors');\nvar assert = require('assert');\nvar ReadResult = require('bufrw').ReadResult;\n\nvar readRes = new ReadResult();\n\nfunction TChannelServiceNameHandler(options) {\n    if (!(this instanceof TChannelServiceNameHandler)) {\n        return new TChannelServiceNameHandler(options);\n    }\n    var self = this;\n\n    assert(typeof options === 'object', 'options required');\n\n    self.channel = options.channel;\n    assert(typeof self.channel === 'object', 'expected options.tchannel to be object');\n\n    self.isBusy = options.isBusy || null;\n    if (self.isBusy) {\n        assert(typeof self.isBusy === 'function', 'expected options.isBusy to be function');\n    }\n}\n\nTChannelServiceNameHandler.prototype.type = 'tchannel.service-name-handler';\n\nTChannelServiceNameHandler.prototype.handleLazily = function handleLazily(conn, reqFrame) {\n    var self = this;\n\n    var res = reqFrame.bodyRW.lazy.poolReadService(readRes, reqFrame);\n    if (res.err) {\n        // TODO: stat?\n        self.channel.logger.warn('failed to lazy read frame serviceName', conn.extendLogInfo({\n            error: res.err\n        }));\n        // TODO: protocol error instead?\n        conn.sendLazyErrorFrameForReq(reqFrame, 'BadRequest', 'failed to read serviceName');\n        return false;\n    }\n\n    var serviceName = res.value;\n    if (!serviceName) {\n        // TODO: reqFrame.extendLogInfo would be nice, especially if it added\n        // things like callerName and arg1\n        self.channel.logger.warn('missing service name in lazy frame', conn.extendLogInfo({}));\n        conn.sendLazyErrorFrameForReq(reqFrame, 'BadRequest', 'missing serviceName');\n        return false;\n    }\n\n    var chan = self.channel.subChannels[serviceName];\n\n    if (chan && chan.handler.handleLazily) {\n        return chan.handler.handleLazily(conn, reqFrame);\n    } else {\n        return false;\n    }\n};\n\nTChannelServiceNameHandler.prototype.handleRequest = function handleRequest(req, buildRes) {\n    var self = this;\n\n    if (self.isBusy) {\n        var busyInfo = self.isBusy(req);\n        if (busyInfo) {\n            buildRes().sendError('Busy', busyInfo);\n            return;\n        }\n    }\n\n    if (!req.serviceName) {\n        buildRes().sendError('BadRequest', 'no service name given');\n        return;\n    }\n    var chan = self.channel.subChannels[req.serviceName];\n    if (chan) {\n        chan.handler.handleRequest(req, buildRes);\n    } else {\n        self.handleDefault(req, buildRes);\n    }\n};\n\nTChannelServiceNameHandler.prototype.handleDefault = function handleDefault(req, buildRes) {\n    var err = errors.NoServiceHandlerError({serviceName: req.serviceName});\n    buildRes().sendError('BadRequest', err.message);\n};\n\nTChannelServiceNameHandler.prototype.register = function register() {\n    throw errors.TopLevelRegisterError();\n};\n\nmodule.exports = TChannelServiceNameHandler;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/object_pool.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar stat = require('../stat-tags');\n\nvar DEFAULT_MAX_SIZE = 1000;\n\nmodule.exports = ObjectPool;\n\nfunction ObjectPool(options) {\n    assert(typeof options === 'object', 'expected options object');\n\n    this.Type = options.Type;\n    assert(typeof this.Type === 'function', 'expected options.Type to be constructor function');\n    assert(typeof this.Type.prototype.reset === 'function', 'expected options.Type to have reset method');\n    assert(typeof this.Type.prototype.clear === 'function', 'expected options.Type to have clear method');\n\n    this.maxSize = options.maxSize || DEFAULT_MAX_SIZE;\n    assert(typeof this.maxSize === 'number', 'expected options.maxSize to be number');\n\n    this.name = options.name || this.Type.name;\n    assert(typeof this.name === 'string', 'expected options.name to be string');\n\n    this.freeList = [];\n    this.outstanding = 0;\n\n    this.freeListStatTags = new stat.ObjectPoolTags(\n        this.name,\n        'free'\n    );\n\n    this.outstandingStatTags = new stat.ObjectPoolTags(\n        this.name,\n        'outstanding'\n    );\n\n    // only used in debug mode\n    this.outstandingList = [];\n}\n\nObjectPool.channel = null;\nObjectPool.reportInterval = null;\nObjectPool.timers = null;\nObjectPool.pools = [];\nObjectPool.timer = null;\nObjectPool.refs = 0;\nObjectPool.debug = false;\n\nObjectPool.setup = function setup(options) {\n    var pool = new ObjectPool(options);\n    options.Type.alloc = alloc;\n\n    options.Type.prototype.free = function freeThisObj() {\n        pool.free(this);\n    };\n\n    ObjectPool.pools.push(pool);\n\n    return pool;\n\n    function alloc() {\n        var obj = pool.get();\n        return obj;\n    }\n};\n\nObjectPool.bootstrap = function bootstrap(options) {\n    if (ObjectPool.refs >= 1) {\n        ObjectPool.refs += 1;\n        return;\n    }\n\n    ObjectPool.refs += 1;\n\n    assert(typeof options === 'object', 'expected options object');\n\n    assert(\n        typeof options.channel === 'object' &&\n        typeof options.channel.emitFastStat === 'function',\n        'expected options.channel to be TChannel instance'\n    );\n    ObjectPool.channel = options.channel;\n\n    assert(\n        typeof options.reportInterval === 'number',\n        'expected options.reportInterval to be number'\n    );\n    ObjectPool.reportInterval = options.reportInterval;\n\n    assert(\n        typeof options.timers === 'object' &&\n        typeof options.timers.setTimeout === 'function',\n        'expected options.timers to be timers object'\n    );\n    ObjectPool.timers = options.timers;\n\n    if (typeof options.debug === 'boolean') {\n        ObjectPool.debug = options.debug;\n    }\n\n    ObjectPool.timer = ObjectPool.timers.setTimeout(\n        ObjectPool.reportStats,\n        ObjectPool.reportInterval\n    );\n};\n\nObjectPool.unref = function unref() {\n    ObjectPool.refs = Math.max(0, ObjectPool.refs - 1);\n    if (ObjectPool.refs === 0) {\n        ObjectPool.timers.clearTimeout(ObjectPool.timer);\n        ObjectPool.timer = null;\n    }\n};\n\nObjectPool.reportStats = function reportStats() {\n    // Iterate over pools, report their current size\n\n    var i;\n    for (i = 0; i < ObjectPool.pools.length; i++) {\n        ObjectPool.pools[i].reportStats(ObjectPool.channel);\n    }\n\n    ObjectPool.timer = ObjectPool.timers.setTimeout(\n        ObjectPool.reportStats,\n        ObjectPool.reportInterval\n    );\n};\n\nObjectPool.prototype.reportStats = function reportStats(channel) {\n    channel.emitFastStat(\n        'tchannel.object-pool',\n        'gauge',\n        this.freeList.length,\n        this.freeListStatTags\n    );\n\n    channel.emitFastStat(\n        'tchannel.object-pool',\n        'gauge',\n        this.outstanding,\n        this.outstandingStatTags\n    );\n};\n\nObjectPool.prototype.get = function get() {\n    var inst;\n    this.outstanding += 1;\n    if (this.freeList.length) {\n        inst = this.freeList.pop();\n        assert(inst._objectPoolIsFreed, 'instance retreived from pool is free');\n        inst._objectPoolIsFreed = false;\n\n        if (ObjectPool.debug) {\n            this.outstandingList.push(inst);\n        }\n\n        return inst;\n    } else {\n        inst = new this.Type();\n        inst._objectPoolIsFreed = false;\n\n        if (ObjectPool.debug) {\n            this.outstandingList.push(inst);\n        }\n\n        return inst;\n    }\n};\n\nObjectPool.prototype.free = function free(inst) {\n    assert(!inst._objectPoolIsFreed, 'object pool double free');\n    inst._objectPoolIsFreed = true;\n\n    inst.clear();\n    if (this.outstanding <= this.maxSize) {\n        this.freeList.push(inst);\n    }\n    this.outstanding -= 1;\n\n    var i;\n    if (ObjectPool.debug) {\n        for (i = 0; i < this.outstandingList.length; i++) {\n            if (this.outstandingList[i] === inst) {\n                this.outstandingList.splice(i, 1);\n                return;\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/retry_ratio_tracker.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = RetryRatioTracker;\n\nvar RateCounter = require('./rate_counter');\n\nvar DEFAULT_RATE_COUNTER_INTERVAL = 30 * 1000;\nvar DEFAULT_RATE_COUNTER_NUM_OF_BUCKETS = 30 * 20;\n\nfunction RetryRatioTracker(options) {\n    var rateCounterOpts = {\n        rateInterval: options.rateCounterInterval || DEFAULT_RATE_COUNTER_INTERVAL,\n        numBuckets: options.rateCounterNumOfBuckets || DEFAULT_RATE_COUNTER_NUM_OF_BUCKETS,\n        timers: options.timers\n    };\n\n    this.retryRateCounter = new RateCounter(rateCounterOpts);\n    this.requestRateCounter = new RateCounter(rateCounterOpts); // counts non-retry requests only\n}\n\nRetryRatioTracker.prototype.isWarmedUp = function isWarmedUp() {\n    return this.requestRateCounter.isWarmedUp() && this.retryRateCounter.isWarmedUp();\n};\n\nRetryRatioTracker.prototype.currentRetryRatio = function currentRetryRatio() {\n    if (this.requestRateCounter.rate === 0) {\n        return 0;\n    }\n    return 1.0 * this.retryRateCounter.rate / this.requestRateCounter.rate;\n};\n\nRetryRatioTracker.prototype.incrementRequest = function incrementRequest(isRetry) {\n    if (isRetry) {\n        this.retryRateCounter.increment();\n    } else {\n        this.requestRateCounter.increment();\n    }\n};\n\nRetryRatioTracker.prototype.destroy = function destroy() {\n    this.retryRateCounter.destroy();\n    this.requestRateCounter.destroy();\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/rate_counter.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = RateCounter;\n\nvar assert = require('assert');\n\nvar DEFAULT_RATE_INTERVAL = 1000;\nvar DEFAULT_NUM_OF_BUCKETS = 20;\n\nfunction RateCounter(options) {\n    assert(options.timers, 'options.timers required');\n\n    var self = this;\n\n    this.index = 0;\n    this.rate = 0; // requests per interval\n    this.numOfBuckets = options.numOfBuckets || DEFAULT_NUM_OF_BUCKETS;\n    this.buckets = [];\n    this.buckets[0] = 0;\n\n    this.timers = options.timers;\n    this.rateInterval = options.rateInterval || DEFAULT_RATE_INTERVAL;\n    this.refreshInterval = this.rateInterval / this.numOfBuckets;\n\n    _refreshAndScheduleNext();\n\n    function _refreshAndScheduleNext() {\n        self._refresh();\n        self.refreshTimer = self.timers.setTimeout(_refreshAndScheduleNext, self.refreshInterval);\n    }\n}\n\nRateCounter.prototype.isWarmedUp = function isWarmedUp() {\n    return this.buckets.length === this.numOfBuckets;\n};\n\nRateCounter.prototype.increment = function increment() {\n    this.buckets[this.index] += 1;\n    this.rate += 1;\n};\n\nRateCounter.prototype.destroy = function destory() {\n    this.timers.clearTimeout(this.refreshTimer);\n    this.refreshTimer = null;\n};\n\nRateCounter.prototype._refresh = function _refresh() {\n    // update the sliding window\n    var next = (this.index + 1) % this.numOfBuckets;\n    if (this.buckets[next]) {\n        // offset the bucket being moved out\n        this.rate -= this.buckets[next];\n    }\n\n    assert(this.rate >= 0, 'rate should always be larger equal to 0');\n    this.index = next;\n    this.buckets[this.index] = 0;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/as/thrift.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar fs = require('fs');\nvar path = require('path');\nvar bufrw = require('bufrw');\nvar Result = require('bufrw/result');\nvar thriftrw = require('thriftrw');\nvar extend = require('xtend');\n\nvar errors = require('../errors.js');\nvar HeaderRW = require('../v2/header.js').header2;\n\nvar metaThriftFile = path.join(__dirname, 'meta.thrift');\n\nmodule.exports = TChannelAsThrift;\n\nfunction TChannelAsThrift(opts) {\n    if (!(this instanceof TChannelAsThrift)) {\n        return new TChannelAsThrift(opts);\n    }\n\n    var self = this;\n\n    assert(opts, 'options required');\n    assert(typeof opts === 'object', 'options must be object');\n\n    self.spec = opts.compiledSpec || new thriftrw.Thrift({\n        entryPoint: opts.entryPoint,\n        idls: opts.idls,\n        source: opts.source,\n        strict: opts.strict,\n        allowFilesystemAccess: true,\n        allowIncludeAlias: opts.allowIncludeAlias,\n        allowOptionalArguments: opts.allowOptionalArguments,\n        defaultAsUndefined: opts.defaultAsUndefined,\n        fs: opts.fs\n    });\n\n    var sources = self.spec.getSources();\n    self.thriftFileName = sources.entryPoint;\n    self.thriftSource = sources.idls[sources.entryPoint];\n\n    self.logger = opts.logger;\n\n    var bossMode = opts && opts.bossMode;\n    self.bossMode = typeof bossMode === 'boolean' ? bossMode : false;\n\n    var logParseFailures = opts && opts.logParseFailures;\n    self.logParseFailures = typeof logParseFailures === 'boolean' ?\n        logParseFailures : true;\n\n    self.channel = opts.channel;\n\n    self.isHealthy = opts.isHealthy;\n    assert(!self.isHealthy || typeof self.isHealthy === 'function',\n        'isHealthy must be a function');\n    assert(!self.isHealthy || self.channel,\n        'channel must be provided with isHealthy');\n\n    var loadMetaAsync = opts.loadMetaAsync !== undefined ?\n        opts.loadMetaAsync : true;\n    if (self.isHealthy && loadMetaAsync) {\n        self.registerHealthAsync();\n    }\n}\n\nTChannelAsThrift.prototype.registerHealthAsync =\nfunction registerHealthAsync() {\n    var self = this;\n\n    fs.readFile(metaThriftFile, 'utf8', onFile);\n\n    function onFile(err, thriftSource) {\n        if (err) {\n            self.channel.logger.fatal('failed to read meta.thrift file', {\n                error: err\n            });\n            return;\n        }\n\n        self.registerMeta(thriftSource);\n    }\n};\n\nTChannelAsThrift.prototype.parseException =\nfunction parseException(request, response, cb) {\n    var self = this;\n\n    response.withArg23(onArgs);\n\n    function onArgs(err, arg2, arg3) {\n        if (err) {\n            return cb(err);\n        }\n\n        parseArgs(arg2, arg3);\n    }\n\n    function parseArgs(arg2, arg3) {\n        var parseResult = self._parse({\n            head: arg2,\n            body: arg3,\n            ok: false,\n            endpoint: request.endpoint,\n            direction: 'in.response'\n        });\n        if (parseResult.err) {\n            return cb(parseResult.err);\n        }\n\n        var v = parseResult.value;\n        var resp = new TChannelThriftResponse(response, v);\n        cb(null, resp);\n    }\n};\n\nTChannelAsThrift.prototype.registerHealthSync =\nfunction registerHealthSync() {\n    var self = this;\n\n    var thriftSource = fs.readFileSync(metaThriftFile, 'utf8');\n    self.registerMeta(thriftSource);\n};\n\nTChannelAsThrift.prototype.registerMeta =\nfunction registerMeta(metaSource) {\n    var self = this;\n\n    var metaSpec = new thriftrw.Thrift({\n        source: metaSource\n    });\n\n    self.register(self.channel, 'Meta::health', self, health, metaSpec);\n    self.register(self.channel, 'Meta::thriftIDL', self, thriftIDL, metaSpec);\n};\n\nTChannelAsThrift.prototype.request = function request(reqOptions) {\n    var self = this;\n\n    assert(self.channel, 'channel is required for thrift.request()');\n    assert(reqOptions &&\n        reqOptions.type !== 'tchannel.request' &&\n        reqOptions.type !== 'tchannel.outgoing-request',\n        'invalid reqOptions to TChannelAsThrift.request');\n\n    var shouldApplicationRetry = reqOptions.shouldThriftRetry;\n    if (shouldApplicationRetry) {\n        reqOptions.shouldApplicationRetry = wrappedShouldRetry;\n    }\n\n    var req = new TChannelThriftRequest({\n        channel: self.channel,\n        reqOptions: reqOptions,\n        tchannelThrift: self\n    });\n\n    return req;\n\n    function wrappedShouldRetry(req2, res, retry, done) {\n        self.parseException(req2, res, onException);\n\n        function onException(err, info) {\n            if (err) {\n                return done(err);\n            }\n\n            var bool = shouldApplicationRetry(info, req, res);\n            if (bool) {\n                retry();\n            } else {\n                done();\n            }\n        }\n    }\n};\n\nTChannelAsThrift.prototype.waitForIdentified =\nfunction waitForIdentified(options, cb) {\n    var self = this;\n\n    assert(self.channel, 'channel is required for waitForIdentified()');\n\n    return self.channel.waitForIdentified(options, cb);\n};\n\nTChannelAsThrift.prototype.register =\nfunction register(channel, name, opts, handle, spec) {\n    var self = this;\n\n    // support register(endpoint, opts, handle)\n    if (typeof channel === 'string') {\n        assert(self.channel, 'channel is required for thrift.register()');\n        assert(spec === undefined, 'must have only 4 arguments');\n\n        spec = handle;\n        handle = opts;\n        opts = name;\n        name = channel;\n        channel = self.channel;\n    }\n\n    if (!self.logger) {\n        self.logger = channel.logger;\n    }\n\n    assert(typeof name === 'string', 'endpoint has to be a string');\n\n    channel.register(name, handleThriftRequest);\n\n    function handleThriftRequest(req, res, inHeadBuffer, inBodyBuffer) {\n        if (req.headers.as !== 'thrift') {\n            return res.sendError('BadRequest',\n                'Expected call request as header to be thrift');\n        }\n\n        // Process incoming thrift body\n        var parseResult = self._parse({\n            head: inHeadBuffer,\n            body: inBodyBuffer,\n            endpoint: name,\n            direction: 'in.request',\n            spec: spec\n        });\n\n        if (parseResult.err) {\n            return res.sendError('BadRequest',\n                parseResult.err.type + ': ' + parseResult.err.message);\n        }\n\n        var v = parseResult.value;\n        handle(opts, req, v.head, v.body, handleThriftResponse);\n\n        function handleThriftResponse(err, thriftRes) {\n            if (err) {\n                self.logger.error('Got unexpected error in handler', {\n                    endpoint: name,\n                    error: err\n                });\n\n                return res.sendError('UnexpectedError', 'Unexpected Error');\n            }\n\n            if (!self.bossMode) {\n                assert(typeof thriftRes.ok === 'boolean',\n                    'expected response.ok to be a boolean');\n                assert(thriftRes.body !== undefined,\n                    'expected response.body to exist');\n\n                if (!thriftRes.ok) {\n                    assert(typeof thriftRes.typeName === 'string',\n                        'expected not-ok response to have typeName');\n                }\n            }\n\n            var stringifyResult = self._stringify({\n                head: thriftRes.head,\n                body: thriftRes.body,\n                ok: thriftRes.ok,\n                typeName: thriftRes.typeName,\n                endpoint: name,\n                direction: 'out.response',\n                spec: spec\n            });\n\n            if (stringifyResult.err) {\n                return res.sendError('UnexpectedError',\n                    'Could not serialize thrift');\n            }\n\n            if (res.setOk(thriftRes.ok)) {\n                res.headers.as = 'thrift';\n                res.send(\n                    stringifyResult.value.head,\n                    stringifyResult.value.body\n                );\n            }\n        }\n    }\n};\n\nTChannelAsThrift.prototype.send =\nfunction send(request, endpoint, outHead, outBody, callback) {\n    var self = this;\n\n    self.logger = self.logger || request.channel.logger;\n\n    assert(typeof endpoint === 'string', 'send requires endpoint');\n    assert(typeof request.serviceName === 'string' &&\n        request.serviceName !== '',\n        'req.serviceName must be a string');\n\n    var stringifyResult = self._stringify({\n        head: outHead,\n        body: outBody,\n        endpoint: endpoint,\n        direction: 'out.request'\n    });\n    if (stringifyResult.err) {\n        return callback(stringifyResult.err);\n    }\n\n    // Punch as=thrift into the transport headers\n    request.headers.as = 'thrift';\n\n    request.send(\n        endpoint,\n        stringifyResult.value.head,\n        stringifyResult.value.body,\n        handleResponse\n    );\n\n    function handleResponse(err, res, arg2, arg3) {\n        if (err) {\n            return callback(err);\n        }\n\n        var parseResult = self._parse({\n            head: arg2,\n            body: arg3,\n            ok: res.ok,\n            endpoint: endpoint,\n            direction: 'in.response'\n        });\n\n        if (parseResult.err) {\n            return callback(parseResult.err);\n        }\n\n        var v = parseResult.value;\n        var resp = new TChannelThriftResponse(res, v);\n\n        callback(null, resp);\n    }\n};\n\nTChannelAsThrift.prototype.getServiceEndpoints = function getEndpoints() {\n    return this.spec.getServiceEndpoints();\n};\n\n/*eslint-disable max-statements */\nTChannelAsThrift.prototype._parse = function parse(opts) {\n    var self = this;\n    var spec = opts.spec || self.spec;\n\n    var argsName = opts.endpoint + '_args';\n    var argsType = spec.getType(argsName);\n\n    var returnName = opts.endpoint + '_result';\n    var resultType = spec.getType(returnName);\n\n    var headRes;\n    if (!opts.head) {\n        headRes = new Result(null, null);\n    } else {\n        headRes = bufrw.fromBufferResult(HeaderRW, opts.head);\n        if (headRes.err) {\n            var headParseErr = errors.ThriftHeadParserError(headRes.err, {\n                endpoint: opts.endpoint,\n                direction: opts.direction,\n                ok: opts.ok,\n                headBuf: opts.head.slice(0, 10)\n            });\n\n            if (self.logParseFailures) {\n                self.logger.warn('Got unexpected invalid thrift arg2', {\n                    endpoint: opts.endpoint,\n                    direction: opts.direction,\n                    ok: opts.ok,\n                    headErr: headParseErr\n                });\n            }\n\n            return new Result(headParseErr);\n        }\n    }\n\n    var bodyRes;\n    var typeName;\n    if (opts.direction === 'in.request') {\n        bodyRes = argsType.fromBufferResult(opts.body);\n    } else if (opts.direction === 'in.response') {\n        bodyRes = resultType.fromBufferResult(opts.body);\n\n        if (bodyRes.value && opts.ok) {\n            bodyRes.value = bodyRes.value.success;\n        } else if (bodyRes.value && !opts.ok) {\n            typeName = onlyKey(bodyRes.value);\n            bodyRes.value = bodyRes.value[typeName];\n        }\n    }\n\n    if (bodyRes.err) {\n        var bodyParseErr = errors.ThriftBodyParserError(bodyRes.err, {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            ok: opts.ok,\n            bodyBuf: opts.body.slice(0, 10)\n        });\n\n        if (self.logParseFailures) {\n            self.logger.warn('Got unexpected invalid thrift for arg3', {\n                endpoint: opts.endpoint,\n                ok: opts.ok,\n                direction: opts.direction,\n                bodyErr: bodyParseErr\n            });\n        }\n\n        return new Result(bodyParseErr);\n    }\n\n    return new Result(null, {\n        head: headRes.value,\n        body: bodyRes.value,\n        typeName: typeName\n    });\n};\n/*eslint-enable max-statements */\n\nTChannelAsThrift.prototype._stringify = function stringify(opts) {\n    var self = this;\n    var spec = opts.spec || self.spec;\n\n    var argsName = opts.endpoint + '_args';\n    var argsType = spec.getType(argsName);\n\n    var returnName = opts.endpoint + '_result';\n    var resultType = spec.getType(returnName);\n\n    opts.head = opts.head || {};\n\n    var headRes = bufrw.toBufferResult(HeaderRW, opts.head);\n    if (headRes.err) {\n        var headStringifyErr = errors.ThriftHeadStringifyError(headRes.err, {\n            endpoint: opts.endpoint,\n            ok: opts.ok,\n            direction: opts.direction,\n            head: opts.head\n        });\n\n        self.logger.error('Got unexpected unserializable thrift for arg2', {\n            endpoint: opts.endpoint,\n            ok: opts.ok,\n            direction: opts.direction,\n            headErr: headStringifyErr\n        });\n        return new Result(headStringifyErr);\n    }\n\n    var bodyRes;\n    if (opts.direction === 'out.request') {\n        bodyRes = argsType.toBufferResult(opts.body);\n    } else if (opts.direction === 'out.response') {\n        var thriftResult = {};\n        if (!opts.ok) {\n            thriftResult[opts.typeName] = opts.body;\n        } else {\n            thriftResult.success = opts.body;\n        }\n\n        bodyRes = resultType.toBufferResult(thriftResult);\n    }\n\n    if (bodyRes.err) {\n        var bodyStringifyErr = errors.ThriftBodyStringifyError(bodyRes.err, {\n            endpoint: opts.endpoint,\n            ok: opts.ok,\n            direction: opts.direction,\n            body: opts.body\n        });\n\n        self.logger.error('Got unexpected unserializable thrift for arg3', {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            ok: opts.ok,\n            bodyErr: bodyStringifyErr\n        });\n        return new Result(bodyStringifyErr);\n    }\n\n    return new Result(null, {\n        head: headRes.value,\n        body: bodyRes.value\n    });\n};\n\nfunction TChannelThriftResponse(response, parseResult) {\n    var self = this;\n\n    self.ok = response.ok;\n    self.head = parseResult.head;\n    self.body = null;\n    self.headers = response.headers;\n    self.body = parseResult.body;\n    self.typeName = parseResult.typeName;\n}\n\nfunction TChannelThriftRequest(options) {\n    var self = this;\n\n    self.channel = options.channel;\n    self.reqOptions = options.reqOptions;\n    self.tchannelThrift = options.tchannelThrift;\n}\n\nTChannelThriftRequest.prototype.send =\nfunction send(endpoint, head, body, callback) {\n    var self = this;\n\n    var outreq = self.channel.request(self.reqOptions);\n    var headers = head;\n    if (self.reqOptions.defaultRequestHeaders) {\n        headers = extend(self.reqOptions.defaultRequestHeaders, head);\n    }\n    self.tchannelThrift.send(outreq, endpoint, headers, body, callback);\n};\n\nfunction health(tchannelThrift, req, head, body, callback) {\n    var status = tchannelThrift.isHealthy();\n    assert(status && typeof status.ok === 'boolean', 'status must have ok field');\n    assert(status && (status.ok || typeof status.message === 'string'),\n        'status.message must be provided when status.ok === false');\n\n    return callback(null, {\n        ok: true,\n        body: {\n            ok: status.ok,\n            message: status.message\n        }\n    });\n}\n\nfunction thriftIDL(tchannelThrift, req, head, body, callback) {\n    return callback(null, {\n        ok: true,\n        body: tchannelThrift.spec.getSources()\n    });\n}\n\n// TODO proper Thriftify result union that reifies as the selected field.\nfunction onlyKey(object) {\n    for (var name in object) {\n        if (object[name] != null) {\n            return name;\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/header.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n/* eslint max-statements: [1, 30] */\n\nvar bufrw = require('bufrw');\nvar inherits = require('util').inherits;\nvar errors = require('../errors');\n\n// TODO: different struct pattern that doesn't realize a temporary list of\n// [key, val] tuples may be better. At the very least, such structure would\n// allow for more precise error reporting.\n\nfunction HeaderRW(countrw, keyrw, valrw, options) {\n    this.countrw = countrw;\n    this.keyrw = keyrw;\n    this.valrw = valrw;\n    this.maxHeaderCount = options.maxHeaderCount;\n    this.maxKeyLength = options.maxKeyLength;\n    bufrw.Base.call(this);\n}\ninherits(HeaderRW, bufrw.Base);\n\nHeaderRW.prototype.poolByteLength = function poolByteLength(destResult, headers) {\n    var length = 0;\n    var keys = Object.keys(headers);\n    var res;\n\n    if (keys.length > this.maxHeaderCount) {\n        return destResult.reset(errors.TooManyHeaders({\n            count: keys.length,\n            maxHeaderCount: this.maxHeaderCount\n        }));\n    }\n\n    length += this.countrw.width;\n\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        res = this.keyrw.byteLength(key);\n        if (res.err) return res;\n        length += res.length;\n\n        res = this.valrw.byteLength(headers[key]);\n        if (res.err) return res;\n        if (res.length > this.maxKeyLength) {\n            return destResult.reset(errors.TransportHeaderTooLong({\n                maxLength: this.maxKeyLength,\n                headerName: key\n            }));\n        }\n        length += res.length;\n    }\n\n    return destResult.reset(null, length);\n};\n\nHeaderRW.prototype.poolWriteInto = function poolWriteInto(destResult, headers, buffer, offset) {\n    var keys = Object.keys(headers);\n    var res;\n\n    res = this.countrw.poolWriteInto(destResult, keys.length, buffer, offset);\n\n    if (keys.length > this.maxHeaderCount) {\n        return destResult.reset(errors.TooManyHeaders({\n            count: keys.length,\n            maxHeaderCount: this.maxHeaderCount,\n            offset: offset,\n            endOffset: res.offset\n        }), offset);\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n        if (res.err) return res;\n        offset = res.offset;\n\n        var key = keys[i];\n        res = this.keyrw.writeInto(key, buffer, offset);\n        if (res.err) return res;\n\n        var keyByteLength = res.offset - offset;\n        if (keyByteLength > this.maxKeyLength) {\n            return destResult.reset(errors.TransportHeaderTooLong({\n                maxLength: this.maxKeyLength,\n                headerName: key,\n                offset: offset,\n                endOffset: res.offset\n            }), offset);\n        }\n        offset = res.offset;\n\n        // TODO consider supporting buffers\n        if (typeof headers[key] !== 'string') {\n            return destResult.reset(errors.InvalidHeaderTypeError({\n                name: key,\n                headerType: typeof headers[key]\n            }), offset);\n        }\n\n        res = this.valrw.poolWriteInto(destResult, headers[key], buffer, offset);\n    }\n\n    return res;\n};\n\nHeaderRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n    var headers = {};\n    var start = 0;\n    var n = 0;\n    var key = '';\n    var val = '';\n    var res;\n\n    res = this.countrw.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    n = res.value;\n\n    if (n > this.maxHeaderCount) {\n        return destResult.reset(errors.TooManyHeaders({\n            count: n,\n            maxHeaderCount: this.maxHeaderCount,\n            offset: offset,\n            endOffset: res.offset\n        }), offset, headers);\n    }\n\n    for (var i = 0; i < n; i++) {\n        start = offset;\n\n        res = this.keyrw.poolReadFrom(destResult, buffer, offset);\n        if (res.err) return res;\n        key = res.value;\n\n        if (!key.length) {\n            return destResult.reset(errors.NullKeyError({\n                offset: offset,\n                endOffset: res.offset\n            }), offset, headers);\n        } else if (res.offset - offset > this.maxKeyLength) {\n            return destResult.reset(errors.TransportHeaderTooLong({\n                maxLength: this.maxKeyLength,\n                headerName: key,\n                offset: offset,\n                endOffset: res.offset\n            }), offset, headers);\n        }\n        offset = res.offset;\n\n        res = this.valrw.poolReadFrom(destResult, buffer, offset);\n        if (res.err) return res;\n        val = res.value;\n\n        if (headers[key] !== undefined) {\n            return destResult.reset(errors.DuplicateHeaderKeyError({\n                offset: start,\n                endOffset: res.offset,\n                key: key,\n                value: val,\n                priorValue: headers[key]\n            }), offset, headers);\n        }\n        offset = res.offset;\n\n        headers[key] = val;\n    }\n\n    return destResult.reset(null, offset, headers);\n};\n\nHeaderRW.prototype.poolLazyRead = function poolLazyRead(destResult, frame, offset) {\n    // TODO: conspire with Call(Request,Response) to memoize headers start/end\n    // offsets, maybe even start of each key?\n\n    var res = this.countrw.poolReadFrom(destResult, frame.buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // TODO: Pool these KeyVals objects\n    var keyvals = new KeyVals(frame.buffer, res.value);\n    for (var i = 0; i < keyvals.length; i++) {\n        res = this.keyrw.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) return res;\n        var keyOffset = res.offset;\n        var keyLength = res.value;\n        offset = res.offset + res.value;\n\n        res = this.valrw.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) return res;\n        var valOffset = res.offset;\n        var valLength = res.value;\n        offset = res.offset + res.value;\n\n        keyvals.add(keyOffset, keyLength, valOffset, valLength);\n    }\n\n    keyvals.offset = offset;\n\n    return destResult.reset(null, offset, keyvals);\n};\n\nHeaderRW.prototype.poolLazySkip = function poolLazySkip(destResult, frame, offset) {\n    // TODO: conspire with Call(Request,Response) to memoize headers start/end\n    // offsets, maybe even start of each key?\n\n    var res = this.countrw.poolReadFrom(destResult, frame.buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    var n = res.value;\n\n    for (var i = 0; i < n; i++) {\n        res = this.keyrw.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) return res;\n        offset = res.offset + res.value;\n\n        res = this.valrw.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) return res;\n        offset = res.offset + res.value;\n    }\n\n    return destResult.reset(null, offset, null);\n};\n\nmodule.exports = HeaderRW;\n\n// nh:1 (hk~1 hv~1){nh}\nmodule.exports.header1 = new HeaderRW(bufrw.UInt8, bufrw.str1, bufrw.str1, {\n    maxHeaderCount: 128,\n    maxKeyLength: 16\n});\n\n// nh:2 (hk~2 hv~2){nh}\nmodule.exports.header2 = new HeaderRW(bufrw.UInt16BE, bufrw.str2, bufrw.str2, {\n    maxHeaderCount: Infinity,\n    maxKeyLength: Infinity\n});\n\nfunction KeyVals(buffer, length) {\n    this.length = length;\n    this.buffer = buffer;\n    this.data = new Array(this.length * 4);\n    this.index = 0;\n    this.offset = 0;\n}\n\nKeyVals.prototype.add =\nfunction add(keyOffset, keyLength, valOffset, valLength) {\n    if (this.index < this.data.length) {\n        this.data[this.index++] = keyOffset;\n        this.data[this.index++] = keyLength;\n        this.data[this.index++] = valOffset;\n        this.data[this.index++] = valLength;\n    }\n};\n\nKeyVals.prototype.getValue =\nfunction getValue(key) {\n    // assert Buffer.isBuffer(key)\n\n    for (\n        var i = 0;\n        i < this.data.length;\n        i += 4\n    ) {\n        var keyLength = this.data[i + 1];\n        if (key.length !== keyLength) {\n            continue;\n        }\n\n        var keyOffset = this.data[i];\n        var found = true;\n        for (\n            var j = 0, offset = keyOffset;\n            j < keyLength;\n            j++, offset++\n        ) {\n            if (key[j] !== this.buffer[offset]) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            var valOffset = this.data[i + 2];\n            var valLength = this.data[i + 3];\n            return this.buffer.slice(\n                valOffset,\n                valOffset + valLength\n            );\n        }\n    }\n\n    return undefined;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/as/json.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar assert = require('assert');\nvar Result = require('bufrw/result');\nvar cyclicStringify = require('json-stringify-safe');\nvar extend = require('xtend');\n\nvar errors = require('../errors.js');\n\nmodule.exports = TChannelJSON;\n\nfunction TChannelJSON(options) {\n    if (!(this instanceof TChannelJSON)) {\n        return new TChannelJSON(options);\n    }\n\n    var self = this;\n\n    // lazily populated from tchannel\n    self.logger = null;\n\n    var bossMode = options && options.bossMode;\n    self.bossMode = typeof bossMode === 'boolean' ? bossMode : false;\n\n    var logParseFailures = options && options.logParseFailures;\n    self.logParseFailures = typeof logParseFailures === 'boolean' ?\n        logParseFailures : true;\n\n    // only used in request()\n    self.channel = options && options.channel;\n}\n\nfunction TChannelJSONRequest(options) {\n    var self = this;\n\n    self.channel = options.channel;\n    self.reqOptions = options.reqOptions;\n    self.tchannelJSON = options.tchannelJSON;\n}\n\nTChannelJSONRequest.prototype.send =\nfunction send(endpoint, head, body, callback) {\n    var self = this;\n\n    var outreq = self.channel.request(self.reqOptions);\n    var headers = head;\n    if (self.reqOptions.defaultRequestHeaders) {\n        headers = extend(self.reqOptions.defaultRequestHeaders, head);\n    }\n    self.tchannelJSON.send(outreq, endpoint, headers, body, callback);\n};\n\nTChannelJSON.prototype.request = function request(reqOptions) {\n    var self = this;\n\n    assert(self.channel, 'channel is required for json.request()');\n\n    var req = new TChannelJSONRequest({\n        channel: self.channel,\n        reqOptions: reqOptions,\n        tchannelJSON: self\n    });\n\n    return req;\n};\n\n/*eslint max-params: [2, 5]*/\nTChannelJSON.prototype.send = function send(\n    req, endpoint, head, body, callback\n) {\n\n    var self = this;\n\n    if (!self.logger) {\n        self.logger = req.channel.logger;\n    }\n\n    assert(typeof endpoint === 'string', 'endpoint must be a string');\n    assert(typeof req.serviceName === 'string' && req.serviceName !== '',\n        'req.serviceName must be a string');\n    assert(body !== undefined, 'must send a body');\n\n    var stringifyResult = self._stringify({\n        head: head,\n        body: body,\n        endpoint: endpoint,\n        direction: 'out.request'\n    });\n    if (stringifyResult.err) {\n        return callback(stringifyResult.err);\n    }\n\n    req.headers.as = 'json';\n\n    req.send(\n        new Buffer(endpoint),\n        new Buffer(stringifyResult.value.head || ''),\n        new Buffer(stringifyResult.value.body || ''),\n        onResponse\n    );\n\n    function onResponse(err, resp, arg2, arg3) {\n        if (err) {\n            return callback(err);\n        }\n\n        var parseResult = self._parse({\n            head: arg2.toString('utf8'),\n            body: arg3.toString('utf8'),\n            endpoint: endpoint,\n            direction: 'in.response'\n        });\n\n        if (parseResult.err) {\n            return callback(parseResult.err);\n        }\n\n        var v = parseResult.value;\n        var response = new TChannelJSONResponse(resp, v);\n\n        callback(null, response);\n    }\n};\n\nfunction TChannelJSONResponse(response, parseResult) {\n    var self = this;\n\n    self.ok = response.ok;\n    self.head = parseResult.head;\n    self.body = null;\n\n    if (response.ok) {\n        self.body = parseResult.body;\n    } else {\n        self.body = errors.ReconstructedError(parseResult.body);\n    }\n\n    self.headers = response.headers;\n}\n\nTChannelJSON.prototype.register = function register(\n    tchannel, arg1, opts, handlerFunc\n) {\n    var self = this;\n\n    if (!self.logger) {\n        self.logger = tchannel.logger;\n    }\n\n    assert(typeof arg1 === 'string', 'endpoint has to be a string');\n\n    tchannel.register(arg1, endpointHandler);\n\n    function endpointHandler(req, res, arg2, arg3) {\n        if (req.headers.as !== 'json') {\n            var message = 'Expected call request as header to be json';\n            return res.sendError('BadRequest', message);\n        }\n\n        var parseResult = self._parse({\n            head: arg2.toString('utf8'),\n            body: arg3.toString('utf8'),\n            endpoint: arg1,\n            direction: 'in.request'\n        });\n\n        if (parseResult.err) {\n            var message2 = parseResult.err.type + ': ' +\n                parseResult.err.message;\n            return res.sendError('BadRequest', message2);\n        }\n\n        var v = parseResult.value;\n        handlerFunc(opts, req, v.head, v.body, onResponse);\n\n        function onResponse(err, respObject) {\n            if (err) {\n                self.logger.error('Got unexpected error in handler', {\n                    endpoint: arg1,\n                    error: err\n                });\n                return res.sendError('UnexpectedError', 'Unexpected Error');\n            }\n\n            if (!self.bossMode) {\n                assert(typeof respObject.ok === 'boolean',\n                    'expected respObject to have an `ok` boolean');\n                assert(respObject.body !== undefined,\n                    'expected respObject to have a body');\n            } else if (typeof respObject.ok !== 'boolean' ||\n                       respObject.body === undefined) {\n                respObject.body = errors.InvalidJSONBody({\n                    head: respObject.head,\n                    body: respObject.body\n                });\n            }\n\n            var stringifyResult = self._stringify({\n                head: respObject.head,\n                body: respObject.body,\n                endpoint: arg1,\n                direction: 'out.response'\n            });\n\n            if (stringifyResult.err) {\n                return res.sendError('UnexpectedError',\n                    'Could not JSON stringify');\n            }\n\n            if (res.setOk(respObject.ok)) {\n                res.headers.as = 'json';\n                res.send(\n                    stringifyResult.value.head,\n                    stringifyResult.value.body\n                );\n            }\n        }\n    }\n};\n\nTChannelJSON.prototype._stringify = function stringify(opts) {\n    var self = this;\n\n    var headR = safeJSONStringify(opts.head);\n    if (headR.err) {\n        var headStringifyErr = errors.JSONHeadStringifyError(headR.err, {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            head: cyclicStringify(opts.head)\n        });\n\n        self.logger.error('Got unexpected unserializable JSON for arg2', {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            headErr: headStringifyErr\n        });\n        return new Result(headStringifyErr);\n    }\n\n    var bodyR = safeJSONStringify(opts.body);\n    if (bodyR.err) {\n        var bodyStringifyErr = errors.JSONBodyStringifyError(bodyR.err, {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            body: cyclicStringify(opts.body)\n        });\n\n        self.logger.error('Got unexpected unserializable JSON for arg3', {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            bodyErr: bodyStringifyErr\n        });\n        return new Result(bodyStringifyErr);\n    }\n\n    return new Result(null, {\n        head: headR.value,\n        body: bodyR.value\n    });\n};\n\nTChannelJSON.prototype._parse = function parse(opts) {\n    var self = this;\n\n    var headR = safeJSONParse(opts.head);\n    if (headR.err) {\n        var headParseErr = errors.JSONHeadParserError(headR.err, {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            headStr: opts.head.slice(0, 10)\n        });\n\n        if (self.logParseFailures) {\n            self.logger.warn('Got unexpected invalid JSON for arg2', {\n                endpoint: opts.endpoint,\n                direction: opts.direction,\n                headErr: headParseErr\n            });\n        }\n\n        return new Result(headParseErr);\n    }\n\n    var bodyR = safeJSONParse(opts.body);\n    if (bodyR.err) {\n        var bodyParseErr = errors.JSONBodyParserError(bodyR.err, {\n            endpoint: opts.endpoint,\n            direction: opts.direction,\n            bodyStr: opts.body.slice(0, 10)\n        });\n\n        if (self.logParseFailures) {\n            self.logger.warn('Got unexpected invalid JSON for arg3', {\n                endpoint: opts.endpoint,\n                direction: opts.direction,\n                bodyErr: bodyParseErr\n            });\n        }\n\n        return new Result(bodyParseErr);\n    }\n\n    return new Result(null, {\n        head: headR.value,\n        body: bodyR.value\n    });\n};\n\nfunction safeJSONStringify(obj) {\n    var str;\n\n    // jscs:disable\n    try {\n        str = JSON.stringify(obj);\n    } catch (e) {\n        return new Result(e);\n    }\n    // jscs:enable\n\n    return new Result(null, str);\n}\n\nfunction safeJSONParse(str) {\n    if (str === '') {\n        return new Result(null, null);\n    }\n\n    var json;\n\n    // jscs:disable\n    try {\n        json = JSON.parse(str);\n    } catch (e) {\n        return new Result(e);\n    }\n    // jscs:enable\n\n    return new Result(null, json);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/connection.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar Buffer = require('buffer').Buffer;\nvar process = require('process');\nvar bufrw = require('bufrw');\nvar extend = require('xtend');\nvar ReadMachine = require('bufrw/stream/read_machine');\nvar inherits = require('util').inherits;\n\nvar stat = require('./stat-tags.js');\nvar EventEmitter = require('./lib/event_emitter');\nvar v2 = require('./v2');\nvar errors = require('./errors');\nvar States = require('./reqres_states');\nvar Operations = require('./operations');\n\nvar CONNECTION_BASE_IDENTIFIER = 0;\nvar MAX_PENDING_SOCKET_WRITE_REQ = 100;\n\nfunction TChannelConnection(\n    channel, socket, direction, socketRemoteAddr, socketInitTimeout\n) {\n    assert(!channel.destroyed, 'refuse to create connection for destroyed channel');\n\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.timedOutEvent = this.defineEvent('timedOut');\n    this.pingResponseEvent = this.defineEvent('pingResonse');\n\n    this.draining = false;\n    this.drainReason = '';\n\n    this.closing = false;\n    this.closeError = null;\n    this.closeEvent = this.defineEvent('close');\n\n    this.channel = channel;\n    this.options = this.channel.options;\n    this.logger = channel.logger;\n    this.random = channel.random;\n    this.timers = channel.timers;\n    this.direction = direction;\n    this.socketInitTimeout = socketInitTimeout || this.channel.initTimeout;\n    this.socketRemoteAddr = socketRemoteAddr;\n    this.remoteName = null; // filled in by identify message\n\n    this.ops = new Operations({\n        timers: this.timers,\n        logger: this.logger,\n        random: this.random,\n        initTimeout: this.socketInitTimeout,\n        connectionStalePeriod: this.options.connectionStalePeriod,\n        maxTombstoneTTL: this.options.maxTombstoneTTL,\n        connection: this\n    });\n\n    this.guid = ++CONNECTION_BASE_IDENTIFIER + '~';\n\n    this.tracer = this.channel.tracer;\n    this.identifiedEvent = this.defineEvent('identified');\n\n    if (direction === 'out') {\n        if (this.channel.emitConnectionMetrics) {\n            this.channel.emitFastStat(\n                'tchannel.connections.initiated',\n                'counter',\n                1,\n                new stat.ConnectionsInitiatedTags(\n                    this.channel.hostPort || '0.0.0.0:0',\n                    socketRemoteAddr\n                ));\n        }\n    } else if (this.channel.emitConnectionMetrics) {\n        this.channel.emitFastStat(\n            'tchannel.connections.accepted',\n            'counter',\n            1,\n            new stat.ConnectionsAcceptedTags(\n                this.channel.hostPort,\n                socketRemoteAddr\n            ));\n    }\n\n    this.socket = socket;\n    this.ephemeral = false;\n    this.initHeaders = null;\n\n    var self = this;\n    // TODO: prototype this options shape\n    var opts = {\n        logger: this.channel.logger,\n        random: this.channel.random,\n        timers: this.channel.timers,\n        hostPort: this.channel.hostPort,\n        requireAs: this.channel.requireAs,\n        requireCn: this.channel.requireCn,\n        tracer: this.tracer,\n        processName: this.options.processName,\n        connection: this,\n        handleCallLazily: handleCallLazily\n    };\n\n    this.handler = new v2.Handler(opts);\n\n    this.mach = ReadMachine(bufrw.UInt16BE, v2.Frame.RW);\n\n    this.setupSocket();\n    this.setupHandler();\n    this.start();\n\n    function handleCallLazily(frame) {\n        return self.handleCallLazily(frame);\n    }\n}\ninherits(TChannelConnection, EventEmitter);\n\nTChannelConnection.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    info = self.channel.extendLogInfo(info);\n\n    info.connGUID = self.guid;\n    info.connDirection = self.direction;\n    info.socketRemoteAddr = self.socketRemoteAddr;\n    info.remoteName = self.remoteName;\n    info.connClosing = self.closing;\n\n    return info;\n};\n\nTChannelConnection.prototype.drain =\nfunction drain(reason, callback) {\n    var self = this;\n\n    self._drain(reason);\n\n    if (callback) {\n        if (self.ops.hasDrained()) {\n            process.nextTick(callback);\n        } else {\n            self.ops.drainEvent.on(callback);\n        }\n    }\n};\n\nTChannelConnection.prototype._drain =\nfunction _drain(reason, exempt) {\n    var self = this;\n\n    self.draining = true;\n    self.drainReason = reason;\n    self.ops.draining = true;\n\n    if (self.remoteName) {\n        sendDrainingFrame();\n    } else {\n        self.identifiedEvent.on(sendDrainingFrame);\n    }\n\n    function sendDrainingFrame() {\n        self.handler.sendErrorFrame(\n            v2.Frame.NullId, null,\n            'Declined',\n            'draining: ' + self.drainReason);\n    }\n};\n\n// create a request\nTChannelConnection.prototype.request =\nfunction connBaseRequest(options) {\n    var self = this;\n\n    assert(self.remoteName, 'cannot make request unless identified');\n    options.remoteAddr = self.remoteName;\n\n    // TODO: use this to protect against >4Mi outstanding messages edge case\n    // (e.g. zombie operation bug, incredible throughput, or simply very long\n    // timeout\n    // assert(!self.requests.out[id], 'duplicate frame id in flight');\n\n    // options.checksumType = options.checksum;\n\n    var req = self.buildOutRequest(options);\n    if (self.draining && (\n        !self.channel.drainExempt ||\n        !self.channel.drainExempt(req)\n    )) {\n        req.drained = true;\n        req.drainReason = self.drainReason;\n    }\n    self.ops.addOutReq(req);\n    req.peer.invalidateScore('conn.request');\n    return req;\n};\n\nTChannelConnection.prototype.handleCallRequest = function handleCallRequest(req) {\n    var self = this;\n\n    req.remoteAddr = self.remoteName;\n    self.ops.addInReq(req);\n\n    if (self.draining && (\n        !self.channel.drainExempt ||\n        !self.channel.drainExempt(req)\n    )) {\n        var res = self.buildResponse(req, {});\n        res.sendError('Declined', 'connection draining: ' + self.drainReason);\n        return;\n    }\n\n    process.nextTick(runHandler);\n\n    function runHandler() {\n        self.runHandler(req);\n    }\n};\n\nTChannelConnection.prototype.handleCallLazily = function handleCallLazily(frame) {\n    var self = this;\n    var op = null;\n\n    switch (frame.type) {\n        case v2.Types.CallRequest:\n            return self.channel.handler.handleLazily &&\n                   self.channel.handler.handleLazily(self, frame);\n        case v2.Types.CallResponse:\n        case v2.Types.CallResponseCont:\n        case v2.Types.ErrorResponse:\n            op = self.ops.getOutReq(frame.id);\n            break;\n        case v2.Types.CallRequestCont:\n            op = self.ops.getInReq(frame.id);\n            break;\n        default:\n            return false;\n    }\n\n    if (!op || !op.handleFrameLazily) {\n        return false;\n    }\n    op.handleFrameLazily(frame);\n    return true;\n};\n\nTChannelConnection.prototype.runHandler = function runHandler(req) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.recvd',\n        'counter',\n        1,\n        new stat.InboundCallsRecvdTags(\n            req.callerName,\n            req.serviceName,\n            req.endpoint\n        )\n    );\n\n    self.channel.handler.handleRequest(req, buildResponse);\n    function buildResponse(options) {\n        return self.buildResponse(req, options || {});\n    }\n};\n\nTChannelConnection.prototype.buildResponse =\nfunction buildResponse(req, options) {\n    var self = this;\n\n    if (req.res && req.res.state !== States.Initial) {\n        req.errorEvent.emit(req, errors.ResponseAlreadyStarted({\n            state: req.res.state,\n            reason: 'buildResponse called twice',\n            codeString: req.res.codeString,\n            responseMessage: req.res.message\n        }));\n        return req.res;\n    }\n\n    return self._buildResponse(req, options);\n};\n\nTChannelConnection.prototype._buildResponse =\nfunction _buildResponse(req, options) {\n    var self = this;\n\n    options.channel = self.channel;\n    options.inreq = req;\n\n    // TODO give this options a well defined type\n    req.res = self.buildOutResponse(req, options);\n\n    req.res.errorEvent.on(onError);\n    req.res.finishEvent.on(opDone);\n\n    if (!req.forwardTrace) {\n        self.captureResponseSpans(req.res);\n    }\n\n    return req.res;\n\n    function opDone() {\n        self.onReqDone(req);\n    }\n\n    function onError(err) {\n        self.onResponseError(err, req);\n    }\n};\n\nTChannelConnection.prototype.captureResponseSpans =\nfunction captureResponseSpans(res) {\n    var self = this;\n\n    res.spanEvent.on(handleSpanFromRes);\n\n    function handleSpanFromRes(span) {\n        self.handleSpanFromRes(span);\n    }\n};\n\nfunction isStringOrBuffer(x) {\n    return typeof x === 'string' || Buffer.isBuffer(x);\n}\n\nTChannelConnection.prototype.handleSpanFromRes =\nfunction handleSpanFromRes(span) {\n    var self = this;\n\n    self.channel.tracer.report(span);\n};\n\nTChannelConnection.prototype.onResponseError =\nfunction onResponseError(err, req) {\n    var self = this;\n\n    var reqTimedOut = req.err &&\n                      errors.classify(req.err) === 'Timeout';\n\n    // don't log if we get further timeout errors for already timed out response\n    if (reqTimedOut && errors.classify(err) === 'Timeout') {\n        return;\n    }\n\n    var loggingOptions = req.extendLogInfo(req.res.extendLogInfo({\n        error: err\n    }));\n\n    if (req.res.state === States.Done) {\n        var arg2 = isStringOrBuffer(req.res.arg2) ?\n            req.res.arg2 : 'streaming';\n        var arg3 = isStringOrBuffer(req.res.arg3) ?\n            req.res.arg3 : 'streaming';\n\n        loggingOptions.bufArg2 = arg2.slice(0, 50);\n        loggingOptions.arg2 = String(arg2).slice(0, 50);\n        loggingOptions.bufArg3 = arg3.slice(0, 50);\n        loggingOptions.arg3 = String(arg3).slice(0, 50);\n    }\n\n    if ((err.type === 'tchannel.response-already-started' ||\n        err.type === 'tchannel.response-already-done') &&\n        reqTimedOut\n    ) {\n        self.logger.info(\n            'error for timed out outgoing response', loggingOptions\n        );\n    } else {\n        self.logger.error(\n            'outgoing response has an error', loggingOptions\n        );\n    }\n};\n\nTChannelConnection.prototype.onReqDone = function onReqDone(req) {\n    var self = this;\n\n    var inreq = self.ops.popInReq(req.id);\n\n    if (inreq === req) {\n        return;\n    }\n\n    // incoming req that timed out are already cleaned up\n    if (req.err && errors.classify(req.err) === 'Timeout') {\n        return;\n    }\n\n    if (inreq) {\n        // we popped something else\n        self.logger.warn('mismatched conn.onReqDone', self.extendLogInfo(req.extendLogInfo({})));\n        return;\n    }\n\n    // there was nothing to pop\n    if (self.closing) {\n        // this happens because TChannelConnection#resetAll calls popInReq on\n        // all conn.requests.in, and is okay\n        return;\n    }\n\n    self.logger.warn('orphaned conn.onReqDone', self.extendLogInfo(req.extendLogInfo({})));\n};\n\nTChannelConnection.prototype.setLazyHandling = function setLazyHandling(enabled) {\n    var self = this;\n\n    // TODO: push down read machine concern into handler entirely;\n    // boundary should just be self.handler.handleChunk in\n    // onSocketChunk under setupSocket; then the switching logic\n    // moves wholly into a `self.handler.setLazyHandling(bool)`\n    if (enabled && self.mach.chunkRW !== v2.LazyFrame.RW) {\n        self.mach.chunkRW = v2.LazyFrame.RW;\n    } else if (!enabled && self.mach.chunkRW !== v2.Frame.RW) {\n        self.mach.chunkRW = v2.Frame.RW;\n    }\n    self.handler.useLazyFrames(enabled);\n};\n\nTChannelConnection.prototype.setupSocket = function setupSocket() {\n    var self = this;\n\n    self.socket.setNoDelay(true);\n    // TODO: stream the data with backpressure\n    // when you add data event listener you go into\n    // a deoptimized mode and you have lost all\n    // backpressure on the stream\n    self.socket.on('data', onSocketChunk);\n    self.socket.on('close', onSocketClose);\n    self.socket.on('error', onSocketError);\n\n    // TODO: move to method for function optimization\n    function onSocketChunk(chunk) {\n        var err = self.mach.handleChunk(chunk);\n        if (err) {\n            self.sendProtocolError('read', err);\n        }\n    }\n\n    // TODO: move to method for function optimization\n    function onSocketClose() {\n        self.resetAll(errors.SocketClosedError({\n            reason: 'remote closed',\n            socketRemoteAddr: self.socketRemoteAddr,\n            direction: self.direction,\n            remoteName: self.remoteName\n        }));\n\n        if (self.ephemeral) {\n            var peer = self.channel.peers.get(self.socketRemoteAddr);\n            if (peer) {\n                peer.close(noop);\n            }\n            self.channel.peers.delete(self.socketRemoteAddr);\n        }\n    }\n\n    function onSocketError(err) {\n        self.onSocketError(err);\n    }\n};\n\nfunction noop() {}\n\nTChannelConnection.prototype.setupHandler = function setupHandler() {\n    var self = this;\n\n    self.setLazyHandling(self.channel.options.useLazyHandling);\n\n    self.handler.write = function write(buf) {\n        self.writeToSocket(buf);\n    };\n\n    self.mach.emit = handleReadFrame;\n\n    self.handler.writeErrorEvent.on(onWriteError);\n    self.handler.errorEvent.on(onHandlerError);\n    self.handler.errorFrameEvent.on(onErrorFrame);\n    self.handler.callIncomingRequestEvent.on(onCallRequest);\n    self.handler.callIncomingResponseEvent.on(onCallResponse);\n    self.handler.pingIncomingResponseEvent.on(onPingResponse);\n    self.handler.callIncomingErrorFrameEvent.on(onCallErrorFrame);\n\n    // TODO: restore dumping from old:\n    // var stream = self.socket;\n    // if (dumpEnabled) {\n    //     stream = stream.pipe(Spy(process.stdout, {\n    //         prefix: '>>> ' + self.remoteAddr + ' '\n    //     }));\n    // }\n    // stream = stream\n    //     .pipe(self.reader)\n    //     .pipe(self.handler)\n    //     ;\n    // if (dumpEnabled) {\n    //     stream = stream.pipe(Spy(process.stdout, {\n    //         prefix: '<<< ' + self.remoteAddr + ' '\n    //     }));\n    // }\n    // stream = stream\n    //     .pipe(self.socket)\n    //     ;\n\n    function onWriteError(err) {\n        self.onWriteError(err);\n    }\n\n    function onHandlerError(err) {\n        self.onHandlerError(err);\n    }\n\n    function onErrorFrame(errFrame) {\n        self.onErrorFrame(errFrame);\n    }\n\n    function handleReadFrame(frame) {\n        self.handleReadFrame(frame);\n    }\n\n    function onCallRequest(req) {\n        self.handleCallRequest(req);\n    }\n\n    function onCallResponse(res) {\n        self.onCallResponse(res);\n    }\n\n    function onPingResponse(res) {\n        self.handlePingResponse(res);\n    }\n\n    function onCallErrorFrame(errFrame) {\n        self.onCallErrorFrame(errFrame);\n    }\n};\n\nfunction getSocketBuffer(socket) {\n    var writableState = socket._writableState;\n\n    // node >=4 has getBuffer()\n    if (typeof writableState.getBuffer === 'function') {\n        return writableState.getBuffer();\n    } else {\n        // Node 0.10 has `.buffer`\n        return writableState.buffer;\n    }\n}\n\nTChannelConnection.prototype.writeToSocket =\nfunction writeToSocket(buf) {\n    var self = this;\n\n    var buffer = getSocketBuffer(self.socket);\n\n    if (buffer.length > MAX_PENDING_SOCKET_WRITE_REQ) {\n        var error = errors.SocketWriteFullError({\n            pendingWrites: buffer.length\n        });\n        self.logger.warn('resetting connection due to write backup',\n            self.extendLogInfo({\n                pendingWrites: buffer.length,\n                totalFastBufferBytes: self.socket._writableState.length,\n                lastBufferLength: buf.length,\n                error: error\n            })\n        );\n\n        // NUKE THE SOCKET\n        self.resetAll(error);\n        return;\n    }\n\n    self.socket.write(buf);\n};\n\nTChannelConnection.prototype.sendProtocolError =\nfunction sendProtocolError(type, err) {\n    var self = this;\n\n    assert(type === 'write' || type === 'read',\n        'Got invalid type: ' + type);\n\n    var protocolError;\n\n    if (type === 'read') {\n        protocolError = errors.TChannelReadProtocolError(err, {\n            remoteName: self.remoteName,\n            localName: self.channel.hostPort,\n            frameId: err.frameId\n        });\n\n        self.channel.emitFastStat(\n            'tchannel.inbound.protocol-errors',\n            'counter',\n            1,\n            new stat.InboundProtocolErrorsTags(self.socketRemoteAddr)\n        );\n\n        self.handler.sendErrorFrame(\n            protocolError.frameId || v2.Frame.NullId, null,\n            'ProtocolError', protocolError.message);\n\n        self.resetAll(protocolError);\n    } else if (type === 'write') {\n        protocolError = errors.TChannelWriteProtocolError(err, {\n            remoteName: self.remoteName,\n            localName: self.channel.hostPort,\n            frameId: err.frameId\n        });\n\n        // TODO: what if you have a write error in a call req cont frame\n        self.resetAll(protocolError);\n    }\n};\n\nTChannelConnection.prototype.onWriteError = function onWriteError(err) {\n    var self = this;\n\n    self.sendProtocolError('write', err);\n};\n\nTChannelConnection.prototype.onErrorFrame = function onErrorFrame(errFrame) {\n    var self = this;\n\n    // TODO: too coupled to v2\n\n    switch (errFrame.body.code) {\n\n    case v2.ErrorResponse.Codes.ProtocolError:\n        var CodeErrorType = v2.ErrorResponse.CodeErrors[errFrame.body.code];\n        self.resetAll(new CodeErrorType({\n            originalId: errFrame.id,\n            message: String(errFrame.body.message)\n        }));\n        return;\n\n    case v2.ErrorResponse.Codes.Declined:\n        var match = /^draining:\\s*(.+)$/.exec(errFrame.body.message);\n        if (match) {\n            self.draining = true;\n            self.drainReason = 'remote draining: ' + match[1];\n            // TODO:\n            // - info log?\n            // - invaliadet peer score?\n            return;\n        }\n        logUnhandled(v2.ErrorResponse.CodeNames[errFrame.body.code]);\n        break;\n\n    case v2.ErrorResponse.Codes.BadRequest:\n    case v2.ErrorResponse.Codes.Busy:\n    case v2.ErrorResponse.Codes.Cancelled:\n    case v2.ErrorResponse.Codes.NetworkError:\n    case v2.ErrorResponse.Codes.Timeout:\n    case v2.ErrorResponse.Codes.UnexpectedError:\n    case v2.ErrorResponse.Codes.Unhealthy:\n        logUnhandled(v2.ErrorResponse.CodeNames[errFrame.body.code]);\n        return;\n\n    default:\n        logUnhandled('unknown');\n    }\n\n    function logUnhandled(codeName) {\n        self.logger.warn('unhandled error frame', self.extendLogInfo({\n            id: errFrame.id,\n            errorCode: errFrame.body.code,\n            errorCodeName: codeName,\n            errorTracing: errFrame.body.tracing,\n            errorMessage: errFrame.body.message\n        }));\n    }\n};\n\nTChannelConnection.prototype.onHandlerError = function onHandlerError(err) {\n    var self = this;\n\n    if (err.isParseError) {\n        self.sendProtocolError('read', err);\n        return;\n    }\n\n    self.resetAll(err);\n};\n\nTChannelConnection.prototype.handlePingResponse = function handlePingResponse(resFrame) {\n    var self = this;\n    // TODO: explicit type\n    self.pingResponseEvent.emit(self, {id: resFrame.id});\n};\n\nTChannelConnection.prototype.handleReadFrame = function handleReadFrame(frame) {\n    var self = this;\n\n    if (!self.closing) {\n        self.ops.resetLastTimeoutTime();\n    }\n\n    self.handler.handleFrame(frame);\n};\n\nTChannelConnection.prototype.onCallResponse = function onCallResponse(res) {\n    var self = this;\n\n    var req = self.ops.getOutReq(res.id);\n    if (res.state === States.Done || res.state === States.Error) {\n        self.ops.popOutReq(res.id, res);\n    } else {\n        self._deferPopOutReq(res);\n    }\n\n    if (!req) {\n        self.logUnknownCallResponse(res);\n        return;\n    }\n\n    if (self.tracer && !req.forwardTrace) {\n        // TODO: better annotations\n        req.span.annotate('cr');\n        self.tracer.report(req.span);\n        res.span = req.span;\n    }\n\n    req.emitResponse(res);\n};\n\nTChannelConnection.prototype.logUnknownCallResponse =\nfunction logUnknownCallResponse(res) {\n    var self = this;\n\n    var logger = self.channel.logger;\n    var tombstone = self.ops.getOutTombstone(res.id);\n    var info = self.extendLogInfo(res.extendLogInfo({\n        responseHeaders: res.headers\n    }));\n\n    if (tombstone) {\n        info = tombstone.extendLogInfo(info);\n        logger.info('got call response for timed out call request', info);\n    } else {\n        logger.warn('got unexpected call response without call request', info);\n    }\n};\n\nTChannelConnection.prototype._deferPopOutReq = function _deferPopOutReq(res) {\n    var self = this;\n    var called = false;\n\n    res.errorEvent.on(popOutReq);\n    res.finishEvent.on(popOutReq);\n\n    // TODO: move to method\n    function popOutReq() {\n        if (called) {\n            return;\n        }\n\n        called = true;\n        self.ops.popOutReq(res.id, res);\n    }\n};\n\nTChannelConnection.prototype.ping = function ping() {\n    var self = this;\n    return self.handler.sendPingRequest();\n};\n\nTChannelConnection.prototype.onCallErrorFrame =\nfunction onCallErrorFrame(errFrame) {\n    var self = this;\n\n    var id = errFrame.id;\n    var req = self.ops.getOutReq(id);\n    // TODO: req could rarely be a lazy req, then maybe call req.handleFrameLazily\n\n    var CodeErrorType = v2.ErrorResponse.CodeErrors[errFrame.body.code];\n    var err = new CodeErrorType({\n        originalId: id,\n        message: String(errFrame.body.message),\n        remoteAddr: self.remoteName\n    });\n\n    if (req) {\n        if (req.res) {\n            req.res.errorEvent.emit(req.res, err);\n        } else {\n            // Only popOutReq if there is no call response object yet\n            req = self.ops.popOutReq(id, err);\n            req.emitError(err);\n        }\n    } else {\n        self.logUnknownErrorFrame(err, id);\n    }\n};\n\nTChannelConnection.prototype.logUnknownErrorFrame =\nfunction logUnknownErrorFrame(err, id) {\n    var self = this;\n\n    var logger = self.channel.logger;\n    var tombstone = self.ops.getOutTombstone(id);\n    var level = errors.logLevel(err, err.codeName);\n\n    // Do not log about incoming timeouts for tombstones\n    if (err.codeName === 'Timeout' && tombstone) {\n        return;\n    }\n\n    var info = self.extendLogInfo({\n        error: err,\n        isErrorFrame: err.isErrorFrame\n    });\n\n    if (level === 'error') {\n        logger.error('got unexpected errorframe without call request', info);\n    } else if (level === 'warn') {\n        logger.warn('got errorframe without call request', info);\n    } else if (level === 'info') {\n        logger.info('got expected errorframe without call request', info);\n    }\n};\n\nTChannelConnection.prototype.start = function start() {\n    var self = this;\n    if (self.direction === 'out') {\n        self.handler.sendInitRequest();\n        self.handler.initResponseEvent.on(onOutIdentified);\n    } else {\n        self.handler.initRequestEvent.on(onInIdentified);\n    }\n\n    var now = self.timers.now();\n    var initOp = new InitOperation(self, now, self.socketInitTimeout);\n    var initTo = self.channel.timeHeap.update(initOp, now);\n\n    function onOutIdentified(init) {\n        initTo.cancel();\n        self.onOutIdentified(init);\n    }\n\n    function onInIdentified(init) {\n        initTo.cancel();\n        self.onInIdentified(init);\n    }\n};\n\nTChannelConnection.prototype.onOutIdentified = function onOutIdentified(init) {\n    var self = this;\n\n    if (init.hostPort === '0.0.0.0:0') {\n        return self.emit('error', errors.EphemeralInitResponse({\n            hostPort: init.hostPort,\n            socketRemoteAddr: self.socketRemoteAddr,\n            processName: init.processName\n        }));\n    }\n\n    self.initHeaders = init;\n    self.remoteName = init.hostPort;\n    self.identifiedEvent.emit(self, {\n        hostPort: init.hostPort,\n        processName: init.processName\n    });\n};\n\nTChannelConnection.prototype.onInIdentified = function onInIdentified(init) {\n    var self = this;\n    if (init.hostPort === '0.0.0.0:0') {\n        self.ephemeral = true;\n        self.remoteName = '' + self.socket.remoteAddress + ':' + self.socket.remotePort;\n        assert(self.remoteName !== self.channel.hostPort,\n              'should not be able to receive ephemeral connection from self');\n    } else {\n        self.remoteName = init.hostPort;\n    }\n\n    self.initHeaders = init;\n    self.channel.peers.add(self.remoteName).addConnection(self);\n    self.identifiedEvent.emit(self, {\n        hostPort: self.remoteName,\n        processName: init.processName\n    });\n};\n\nTChannelConnection.prototype.close = function close(callback) {\n    var self = this;\n    if (self.socket.destroyed) {\n        callback();\n    } else {\n        self.socket.once('close', callback);\n        self.resetAll(errors.LocalSocketCloseError());\n    }\n};\n\nTChannelConnection.prototype.onSocketError = function onSocketError(err) {\n    var self = this;\n    if (!self.closing) {\n        self.resetAll(errors.SocketError(err, {\n            hostPort: self.channel.hostPort,\n            direction: self.direction,\n            socketRemoteAddr: self.socketRemoteAddr\n        }));\n    }\n};\n\nTChannelConnection.prototype.nextFrameId = function nextFrameId() {\n    var self = this;\n    return self.handler.nextFrameId();\n};\n\nTChannelConnection.prototype.buildOutRequest = function buildOutRequest(options) {\n    var self = this;\n    var req = self.handler.buildOutRequest(options);\n    req.errorEvent.on(onReqError);\n    return req;\n\n    function onReqError(err) {\n        // The timeout path already popped the error\n        if (self.ops.getOutReq(req.id)) {\n            self.ops.popOutReq(req.id, err);\n        }\n    }\n};\n\nTChannelConnection.prototype.buildOutResponse = function buildOutResponse(req, options) {\n    var self = this;\n\n    options = options || {};\n    options.inreq = req;\n    options.channel = self.channel;\n    options.logger = self.logger;\n    options.random = self.random;\n    options.timers = self.timers;\n\n    options.tracing = req.tracing;\n    options.span = req.span;\n    options.checksumType = req.checksum && req.checksum.type;\n\n    // TODO: take over popInReq on req/res error?\n    return self.handler.buildOutResponse(req, options);\n};\n\n// this connection is completely broken, and is going away\n// In addition to erroring out all of the pending work, we reset the state\n// in case anybody stumbles across this object in a core dump.\nTChannelConnection.prototype.resetAll = function resetAll(err) {\n    /*eslint complexity: [2, 20], max-statements: [2, 40]*/\n    var self = this;\n\n    self.ops.destroy();\n\n    err = err || errors.TChannelConnectionCloseError();\n\n    if (self.closing) {\n        return;\n    }\n\n    self.closing = true;\n    self.closeError = err;\n    self.socket.destroy();\n\n    var requests = self.ops.getRequests();\n    var pending = self.ops.getPending();\n\n    var inOpKeys = Object.keys(requests.in);\n    var outOpKeys = Object.keys(requests.out);\n\n    if (!err) {\n        err = errors.UnknownConnectionReset();\n    }\n\n    if (!self.remoteName && self.channel.emitConnectionMetrics) {\n        if (self.direction === 'out') {\n            self.channel.emitFastStat(\n                'tchannel.connections.connect-errors',\n                'counter',\n                1,\n                new stat.ConnectionsConnectErrorsTags(\n                    self.channel.hostPort || '0.0.0.0:0',\n                    self.socketRemoteAddr\n                ));\n        } else {\n            self.channel.emitFastStat(\n                'tchannel.connections.accept-errors',\n                'counter',\n                1,\n                new stat.ConnectionsAcceptErrorsTags(self.channel.hostPort));\n        }\n    } else if (self.channel.emitConnectionMetrics) {\n        if (err.type !== 'tchannel.socket-local-closed') {\n            self.channel.emitFastStat(\n                'tchannel.connections.errors',\n                'counter',\n                1,\n                new stat.ConnectionsErrorsTags(\n                    self.remoteName,\n                    err.type // TODO unified error type\n                )\n            );\n        }\n\n        self.channel.emitFastStat(\n            'tchannel.connections.closed',\n            'counter',\n            1,\n            new stat.ConnectionsClosedTags(\n                self.channel.hostPort || '0.0.0.0:0',\n                self.remoteName,\n                err.type // TODO unified reason type\n            )\n        );\n    }\n\n    var logInfo = self.extendLogInfo({\n        error: err,\n        numInOps: inOpKeys.length,\n        numOutOps: outOpKeys.length,\n        inPending: pending.in,\n        outPending: pending.out\n    });\n\n    // requests that we've received we can delete, but these reqs may have started their\n    //   own outgoing work, which is hard to cancel. By setting this.closing, we make sure\n    //   that once they do finish that their callback will swallow the response.\n    inOpKeys.forEach(function eachInOp(id) {\n        self.ops.popInReq(id);\n        // TODO: support canceling pending handlers\n        // TODO report or handle or log errors or something\n    });\n\n    // for all outgoing requests, forward the triggering error to the user callback\n    outOpKeys.forEach(function eachOutOp(id) {\n        var req = self.ops.popOutReq(id);\n        if (!req) {\n            return;\n        }\n        req.emitError(makeReqError(req));\n    });\n\n    function makeReqError(req) {\n        var reqErr = err;\n        if (reqErr.type === 'tchannel.socket-local-closed') {\n            reqErr = errors.TChannelLocalResetError(reqErr);\n        } else {\n            reqErr = errors.TChannelConnectionResetError(reqErr);\n        }\n        return req.extendLogInfo(self.extendLogInfo(reqErr));\n    }\n\n    self.ops.clear();\n\n    var errorCodeName = errors.classify(err);\n    if (errorCodeName !== 'NetworkError' &&\n        errorCodeName !== 'ProtocolError'\n    ) {\n        self.logger.warn('resetting connection', logInfo);\n        self.errorEvent.emit(self, err);\n    } else if (\n        err.type !== 'tchannel.socket-local-closed' &&\n        err.type !== 'tchannel.socket-closed'\n    ) {\n        logInfo.error = extend(err);\n        logInfo.error.message = err.message;\n        self.logger.info('resetting connection', logInfo);\n    }\n\n    self.closeEvent.emit(self, err);\n};\n\nfunction InitOperation(connection, time, timeout) {\n    var self = this;\n\n    self.connection = connection;\n    self.time = time;\n    self.timeout = timeout;\n}\n\nInitOperation.prototype.onTimeout = function onTimeout(now) {\n    var self = this;\n\n    // noop if identify succeeded\n    if (self.connection.remoteName || self.connection.closing) {\n        return;\n    }\n\n    var elapsed = now - self.time;\n    var err = errors.ConnectionTimeoutError({\n        start: self.time,\n        elapsed: elapsed,\n        timeout: self.timeout\n    });\n\n    self.connection.logger.warn('destroying due to init timeout', self.connection.extendLogInfo({\n        error: err\n    }));\n    self.connection.resetAll(err);\n};\n\nTChannelConnection.prototype.sendLazyErrorFrameForReq =\nfunction sendLazyErrorFrameForReq(reqFrame, codeString, message) {\n    var self = this;\n\n    var res = reqFrame.bodyRW.lazy.readTracing(reqFrame);\n    var tracing = res.err ? v2.Tracing.emptyTracing : res.value;\n\n    self.sendLazyErrorFrame(reqFrame.id, tracing, codeString, message);\n\n    var now = self.channel.timers.now();\n    self._observeInboundErrorFrame(reqFrame, now, codeString);\n};\n\nTChannelConnection.prototype._observeInboundErrorFrame =\nfunction _observeInboundErrorFrame(reqFrame, now, codeName) {\n    var self = this;\n\n    var serviceName = reqFrame.bodyRW.lazy\n        .readServiceStr(reqFrame);\n    var callerName = reqFrame.bodyRW.lazy\n        .readCallerNameStr(reqFrame);\n    var endpoint = reqFrame.bodyRW.lazy\n        .readArg1Str(reqFrame);\n\n    if (!callerName || !serviceName || endpoint === null) {\n        return;\n    }\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.latency',\n        'timing',\n        now - reqFrame.start,\n        new stat.InboundCallsLatencyTags(\n            callerName,\n            serviceName,\n            endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.system-errors',\n        'counter',\n        1,\n        new stat.InboundCallsSystemErrorsTags(\n            callerName,\n            serviceName,\n            endpoint,\n            codeName\n        )\n    );\n};\n\nTChannelConnection.prototype.sendLazyErrorFrame =\nfunction sendLazyErrorFrame(id, tracing, codeString, message) {\n    var self = this;\n\n    self.handler.sendErrorFrame(id, tracing, codeString, message);\n};\n\nmodule.exports = TChannelConnection;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/index.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n\nmodule.exports.VERSION = 2;\n\nvar Types = {};\nmodule.exports.Types = Types;\n\nvar RetryFlags = require('../retry-flags.js');\nvar Frame = require('./frame');\nvar LazyFrame = require('./lazy_frame');\n\nmodule.exports.CallFlags = require('./call_flags');\n\nvar init = require('./init');\nTypes.InitRequest = init.Request.TypeCode;\nTypes.InitResponse = init.Response.TypeCode;\nFrame.Types[Types.InitRequest] = init.Request;\nFrame.Types[Types.InitResponse] = init.Response;\nmodule.exports.InitRequest = init.Request;\nmodule.exports.InitResponse = init.Response;\n\nvar call = require('./call');\nTypes.CallRequest = call.Request.TypeCode;\nTypes.CallResponse = call.Response.TypeCode;\nFrame.Types[Types.CallRequest] = call.Request;\nFrame.Types[Types.CallResponse] = call.Response;\nmodule.exports.CallRequest = call.Request;\nmodule.exports.CallResponse = call.Response;\nmodule.exports.MaxArg1Size = 0x4000;\n\nvar Cancel = require('./cancel');\nTypes.Cancel = Cancel.TypeCode;\nFrame.Types[Types.Cancel] = Cancel;\nmodule.exports.Cancel = Cancel;\n\nvar cont = require('./cont');\nTypes.CallRequestCont = cont.RequestCont.TypeCode;\nTypes.CallResponseCont = cont.ResponseCont.TypeCode;\nFrame.Types[Types.CallRequestCont] = cont.RequestCont;\nFrame.Types[Types.CallResponseCont] = cont.ResponseCont;\nmodule.exports.CallRequestCont = cont.RequestCont;\nmodule.exports.CallResponseCont = cont.ResponseCont;\n\nvar Claim = require('./claim');\nTypes.Claim = Claim.TypeCode;\nFrame.Types[Types.Claim] = Claim;\nmodule.exports.Claim = Claim;\n\nvar ping = require('./ping');\nTypes.PingRequest = ping.Request.TypeCode;\nTypes.PingResponse = ping.Response.TypeCode;\nFrame.Types[Types.PingRequest] = ping.Request;\nFrame.Types[Types.PingResponse] = ping.Response;\nmodule.exports.PingRequest = ping.Request;\nmodule.exports.PingResponse = ping.Response;\n\nvar ErrorResponse = require('./error_response');\nTypes.ErrorResponse = ErrorResponse.TypeCode;\nFrame.Types[Types.ErrorResponse] = ErrorResponse;\nmodule.exports.ErrorResponse = ErrorResponse;\n\nmodule.exports.Checksum = require('./checksum');\n\nmodule.exports.Frame = Frame;\nmodule.exports.LazyFrame = LazyFrame;\n\nmodule.exports.parseRetryFlags = function parseRetryFlags(val) {\n    val = val || 'c';\n    var never = val.indexOf('n') > -1;\n    var onConnectionError = !never && val.indexOf('c') > -1;\n    var onTimeout = !never && val.indexOf('t') > -1;\n\n    return new RetryFlags(\n        never, onConnectionError, onTimeout\n    );\n};\n\nmodule.exports.encodeRetryFlags = function encodeRetryFlags(retryFlags) {\n    if (!retryFlags) return '';\n    var re = '';\n    if (retryFlags.never) {\n        re += 'n';\n    } else {\n        if (retryFlags.onConnectionError) re += 'c';\n        if (retryFlags.onTimeout) re += 't';\n    }\n    return re;\n};\n\nmodule.exports.Handler = require('./handler');\n\nmodule.exports.Tracing = require('./tracing.js');\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/frame.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n/* eslint max-statements: [1, 30] */\n\nFrame.Overhead = 0x10;\nFrame.MaxSize = 0xffff;\nFrame.MaxBodySize = Frame.MaxSize - Frame.Overhead;\nFrame.MaxId = 0xfffffffe;\nFrame.NullId = 0xffffffff;\n\nFrame.Types = {};\nmodule.exports = Frame;\n\nvar bufrw = require('bufrw');\nvar errors = require('../errors');\n\nvar Types = require('./index.js').Types;\n\nfunction Frame(id, body) {\n    this.isLazy = false;\n    this.size = 0;\n    this.type = (body && body.type) || 0;\n    if (id === null || id === undefined) {\n        this.id = Frame.NullId;\n    } else {\n        this.id = id;\n    }\n    this.body = body;\n}\n\n// size:2: type:1 reserved:1 id:4 reserved:8 ...\nFrame.RW = bufrw.Base(frameLength, readFrameFrom, writeFrameInto, true);\n\nfunction frameLength(destResult, frame) {\n    var body = frame.body;\n    var bodyRW = body.constructor.RW;\n\n    var length = 0;\n    length += bufrw.UInt16BE.width; // size:2:\n    length += bufrw.UInt8.width;    // type:1\n    length += 1;                    // reserved:1\n    length += bufrw.UInt32BE.width; // id:4\n    length += 8;                    // reserved:8 ...\n\n    var res = bodyRW.poolByteLength(destResult, body);\n    if (!res.err) {\n        res.length += length;\n    }\n    return res;\n}\n\nfunction readFrameFrom(destResult, buffer, offset) {\n    // TODO: pool Frame object\n    var frame = new Frame();\n\n    var res;\n\n    res = bufrw.UInt16BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    frame.size = res.value;\n\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    frame.type = res.value;\n\n    var BodyType = Frame.Types[frame.type];\n    if (!BodyType) {\n        return destResult.reset(errors.InvalidFrameTypeError({\n            typeNumber: frame.type\n        }), offset - 1);\n    }\n\n    offset += 1;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    frame.id = res.value;\n\n    offset += 8;\n\n    res = BodyType.RW.poolReadFrom(destResult, buffer, offset);\n    if (res.err) {\n        if (frame.type === Types.CallRequest ||\n            frame.type === Types.CallRequestCont\n        ) {\n            // TODO: wrapped?\n            res.err.frameId = frame.id;\n        }\n        return res;\n    }\n    offset = res.offset;\n    frame.body = res.value;\n\n    res.value = frame;\n    return res;\n}\n\nfunction writeFrameInto(destResult, frame, buffer, offset) {\n    var body = frame.body;\n    var bodyRW = body.constructor.RW;\n\n    var start = offset;\n    var end = offset;\n    var res;\n\n    // skip size, write later\n    offset += bufrw.UInt16BE.width;\n\n    res = bufrw.UInt8.poolWriteInto(destResult, frame.type, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    end = offset + 1;\n    buffer.fill(0, offset, end);\n    offset = end;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, frame.id, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    end = offset + 8;\n    buffer.fill(0, offset, end);\n    offset = end;\n\n    res = bodyRW.poolWriteInto(destResult, body, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    frame.size = res.offset - start;\n    res = bufrw.UInt16BE.poolWriteInto(destResult, frame.size, buffer, start);\n    if (res.err) return res;\n    res.offset = offset;\n\n    return res;\n}\n\n// TODO: pool below\nFrame.fromBuffer = function fromBuffer(buffer) {\n    return bufrw.fromBuffer(Frame.RW, buffer, 0);\n};\n\nFrame.prototype.byteLength = function byteLength() {\n    return bufrw.byteLength(Frame.RW, this);\n};\n\nFrame.prototype.intoBuffer = function intoBuffer(buffer) {\n    return bufrw.intoBuffer(Frame.RW, this, buffer);\n};\n\nFrame.prototype.toBuffer = function toBuffer() {\n    return bufrw.toBuffer(Frame.RW, this);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/lazy_frame.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar bufrw = require('bufrw');\nvar errors = require('../errors');\n\nvar Frame = require('./frame.js');\nvar Types = require('./index.js').Types;\n\nmodule.exports = LazyFrame;\n\nfunction LazyFrame(size, type, id, buffer) {\n    this.isLazy = true;\n    this.size = size;\n    this.type = type;\n    this.id = id;\n    this.buffer = buffer;\n    this.start = null;\n\n    this.body = null;\n    this.bodyRW = null;\n    this.cache = new CallRequestCache();\n    this.circuit = null;\n}\n\nfunction CallRequestCache() {\n    this.serviceStr = null;\n    this.callerNameStr = null;\n    this.routingDelegateStr = null;\n    this.arg1Str = null;\n    this.ttlValue = null;\n    this.tracingValue = null;\n\n    this.headerStartOffset = null;\n    this.csumStartOffset = null;\n\n    this.cnValueOffset = null;\n    this.rdValueOffset = null;\n\n    this.lastError = null;\n}\n\n// size:2 type:1 reserved:1 id:4 reserved:8 ...\nLazyFrame.RW = bufrw.Base(lazyFrameLength, readLazyFrameFrom, writeLazyFrameInto);\n\nLazyFrame.TypeOffset = 2;\nLazyFrame.IdOffset = 2 + 1 + 1;\nLazyFrame.BodyOffset = Frame.Overhead;\n\nLazyFrame.prototype.setId = function setId(id) {\n    assert.ok(this.buffer, 'must have a buffer supplied');\n    this.id = id;\n    this.buffer.writeUInt32BE(this.id, LazyFrame.IdOffset);\n};\n\nLazyFrame.prototype.readBody = function readBody() {\n    if (this.body) {\n        return bufrw.ReadResult.just(this.body);\n    }\n\n    if (!this.buffer) {\n        // TODO: typed error\n        return bufrw.ReadResult.error(new Error('no buffer to read from'));\n    }\n\n    var res = this.bodyRW.readFrom(this.buffer, LazyFrame.BodyOffset);\n\n    if (res.err) {\n        if (this.type === Types.CallRequest ||\n            this.type === Types.CallRequestCont\n        ) {\n            // TODO: wrapped?\n            res.err.frameId = this.id;\n        }\n    } else {\n        this.body = res.value;\n    }\n\n    return res;\n};\n\nfunction lazyFrameLength(lazyFrame) {\n    return bufrw.LengthResult.just(lazyFrame.size);\n}\n\nfunction readLazyFrameFrom(buffer, offset) {\n    var start = offset;\n\n    // size:2:\n    if (buffer.length < offset + 2) {\n        return bufrw.ReadResult.shortError(\n            offset + 2, buffer.length, offset\n        );\n    }\n    var size = buffer.readUInt16BE(offset);\n    offset += size;\n\n    if (buffer.length < offset) {\n        return bufrw.ReadResult.shortError(\n            offset, buffer.length, start\n        );\n    }\n    var frameBuffer = buffer.slice(start, offset);\n\n    // type:1\n    var type = frameBuffer.readUInt8(LazyFrame.TypeOffset);\n\n    // id:4\n    var id = frameBuffer.readUInt32BE(LazyFrame.IdOffset);\n\n    var lazyFrame = new LazyFrame(size, type, id, frameBuffer);\n    var BodyType = Frame.Types[lazyFrame.type];\n\n    if (!BodyType) {\n        return bufrw.ReadResult.error(errors.InvalidFrameTypeError({\n            typeNumber: lazyFrame.type\n        }), offset + LazyFrame.TypeOffset);\n    }\n\n    lazyFrame.bodyRW = BodyType.RW;\n\n    return bufrw.ReadResult.just(offset, lazyFrame);\n}\n\nfunction writeLazyFrameInto(lazyFrame, buffer, offset) {\n    if (!lazyFrame.buffer) {\n        return bufrw.WriteResult.error(errors.CorruptWriteLazyFrame({\n            context: 'missing buffer'\n        }));\n    }\n\n    var remain = buffer.length - offset;\n    if (lazyFrame.size > remain) {\n        return bufrw.WriteResult.shortError(lazyFrame.size, remain, offset);\n    }\n\n    offset += lazyFrame.buffer.copy(buffer, offset, 0, lazyFrame.size);\n    return bufrw.WriteResult.just(offset);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/call_flags.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = {\n    Fragment: 0x01\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/init.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n\nvar bufrw = require('bufrw');\nvar header = require('./header');\nvar errors = require('../errors');\n\nmodule.exports.Request = InitRequest;\nmodule.exports.Response = InitResponse;\n\nvar RequiredHeaderFields = ['host_port', 'process_name'];\n\nfunction InitRequest(version, headers) {\n    this.type = InitRequest.TypeCode;\n    this.version = version || 0;\n    this.headers = headers || {};\n}\n\nInitRequest.TypeCode = 0x01;\n\nInitRequest.RW = bufrw.Struct(InitRequest, [\n    {call: {poolWriteInto: writeFieldGuard}},\n    {name: 'version', rw: bufrw.UInt16BE}, // version:2\n    {name: 'headers', rw: header.header2}, // nh:2 (hk~2 hv~2){nh}\n    {call: {poolReadFrom: readFieldGuard}}\n]);\n\n// TODO: MissingInitHeaderError check / guard\n\nfunction InitResponse(version, headers) {\n    this.type = InitResponse.TypeCode;\n    this.version = version || 0;\n    this.headers = headers || {};\n}\n\nInitResponse.TypeCode = 0x02;\n\nInitResponse.RW = bufrw.Struct(InitResponse, [\n    {call: {poolWriteInto: writeFieldGuard}},\n    {name: 'version', rw: bufrw.UInt16BE}, // version:2\n    {name: 'headers', rw: header.header2}, // nh:2 (hk~2 hv~2){nh}\n    {call: {poolReadFrom: readFieldGuard}}\n]);\n\nfunction writeFieldGuard(destResult, initBody, buffer, offset) {\n    var err = requiredFieldGuard(initBody.headers);\n    if (err) return destResult.reset(err, offset);\n    else return destResult.reset(null, offset);\n}\n\nfunction readFieldGuard(destResult, initBody, buffer, offset) {\n    var err = requiredFieldGuard(initBody.headers);\n    if (err) return destResult.reset(err, offset);\n    else return destResult.reset(null, offset);\n}\n\nfunction requiredFieldGuard(headers) {\n    for (var i = 0; i < RequiredHeaderFields.length; i++) {\n        var field = RequiredHeaderFields[i];\n        if (headers[field] === undefined) {\n            return errors.MissingInitHeaderError({field: field});\n        }\n    }\n    return null;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/call.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n/* eslint max-params: [2, 7] */\n/* eslint max-statements: [1, 50] */\n\nvar bufrw = require('bufrw');\nvar Buffer = require('buffer').Buffer;\nvar process = global.process;\n\nvar errors = require('../errors');\nvar ArgsRW = require('./args');\nvar Checksum = require('./checksum');\nvar header = require('./header');\nvar Tracing = require('./tracing');\nvar Frame = require('./frame');\nvar CallFlags = require('./call_flags');\nvar argsrw = new ArgsRW();\n\nvar ReadResult = bufrw.ReadResult;\nvar WriteResult = bufrw.WriteResult;\nvar readRes = new ReadResult(); // shared read result\n\nvar CN_VALUE = new Buffer('cn').readUInt16BE(0, false);\nvar RD_VALUE = new Buffer('rd').readUInt16BE(0, false);\n\nvar ResponseCodes = {\n    OK: 0x00,\n    Error: 0x01\n};\n\nvar NODE_VERSION = process.versions.node;\nvar NODE_VERSION_PARTS = NODE_VERSION.split('.');\n\nvar fastBufferToString = allNodeToString;\nif (NODE_VERSION_PARTS[1] === '10' && NODE_VERSION_PARTS[2] >= '32') {\n    fastBufferToString = node10ToString;\n}\n\nfunction node10ToString(fastBuf, start, end) {\n    var slowBuf = fastBuf.parent;\n\n    return slowBuf.utf8Slice(\n        start + fastBuf.offset,\n        end + fastBuf.offset\n    );\n}\n\nfunction allNodeToString(buf, start, end) {\n    return buf.toString('utf8', start, end);\n}\n\n// Calls a pooled function and conveniently allocates a response object for it\nfunction allocifyPoolFn(fn, ResultCons) {\n    return allocFn;\n\n    function allocFn(arg1, arg2, arg3) {\n        return fn(new ResultCons(), arg1, arg2, arg3);\n    }\n}\n\nmodule.exports.Request = CallRequest;\nmodule.exports.Response = CallResponse;\n\n// TODO: validate transport header names?\n// TODO: Checksum-like class for tracing\n\n// flags:1 ttl:4 tracing:24 traceflags:1 service~1 nh:1 (hk~1 hv~1){nh} csumtype:1 (csum:4){0,1} (arg~2)*\nfunction CallRequest(flags, ttl, tracing, service, headers, csum, args) {\n    this.type = CallRequest.TypeCode;\n    this.flags = flags || 0;\n    this.ttl = ttl || 0;\n    this.tracing = tracing || Tracing.emptyTracing;\n    this.service = service || '';\n    this.headers = headers || {};\n    this.csum = Checksum.objOrType(csum);\n    this.args = args || [];\n    this.cont = null;\n}\n\nCallRequest.Cont = require('./cont').RequestCont;\nCallRequest.TypeCode = 0x03;\nCallRequest.RW = bufrw.Base(callReqLength, readCallReqFrom, writeCallReqInto, true);\n\nCallRequest.RW.lazy = {};\n\nCallRequest.RW.lazy.flagsOffset = Frame.Overhead;\nCallRequest.RW.lazy.poolReadFlags = function poolReadFlags(destResult, frame) {\n    // flags:1\n    return bufrw.UInt8.poolReadFrom(destResult, frame.buffer, CallRequest.RW.lazy.flagsOffset);\n};\n\nCallRequest.RW.lazy.readFlags = allocifyPoolFn(CallRequest.RW.lazy.poolReadFlags, ReadResult);\n\nCallRequest.RW.lazy.ttlOffset = CallRequest.RW.lazy.flagsOffset + 1;\nCallRequest.RW.lazy.readTTL = function readTTL(frame) {\n    if (frame.cache.ttlValue !== null) {\n        return frame.cache.ttlValue;\n    }\n\n    var offset = CallRequest.RW.lazy.ttlOffset;\n    if (frame.size < offset + 4) {\n        return 0;\n    }\n    var ttl = frame.buffer.readUInt32BE(offset, false);\n\n    frame.cache.ttlValue = ttl;\n\n    return ttl;\n};\nCallRequest.RW.lazy.poolWriteTTL = function poolWriteTTL(destResult, ttl, frame) {\n    // ttl:4\n    return bufrw.UInt32BE.poolWriteInto(destResult, ttl, frame.buffer, CallRequest.RW.lazy.ttlOffset);\n};\n\nCallRequest.RW.lazy.writeTTL = allocifyPoolFn(CallRequest.RW.lazy.poolWriteTTL, WriteResult);\n\nCallRequest.RW.lazy.tracingOffset = CallRequest.RW.lazy.ttlOffset + 4;\nCallRequest.RW.lazy.poolReadTracing = function poolLazyReadTracing(destResult, frame) {\n    // tracing:24 traceflags:1\n    return Tracing.RW.poolReadFrom(destResult, frame.buffer, CallRequest.RW.lazy.tracingOffset);\n};\n\nCallRequest.RW.lazy.readTracing = allocifyPoolFn(CallRequest.RW.lazy.poolReadTracing, ReadResult);\n\nCallRequest.RW.lazy.serviceOffset = CallRequest.RW.lazy.tracingOffset + 25;\nCallRequest.RW.lazy.poolReadService = function poolLazyReadService(destResult, frame) {\n    // service~1\n    return bufrw.str1.poolReadFrom(destResult, frame.buffer, CallRequest.RW.lazy.serviceOffset);\n};\n\nCallRequest.RW.lazy.readService = allocifyPoolFn(CallRequest.RW.lazy.poolReadService, ReadResult);\n\nCallRequest.RW.lazy.poolReadTracingValue = function poolReadTracingValue(destResult, frame) {\n    if (frame.cache.tracingValue !== null) {\n        return frame.cache.tracingValue;\n    }\n\n    var offset = CallRequest.RW.lazy.tracingOffset;\n\n    if (frame.size < offset + 25) {\n        return null;\n    }\n\n    var spanid1 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var spanid2 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var parentid1 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var parentid2 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var traceid1 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var traceid2 = frame.buffer.readUInt32BE(offset, false);\n    offset += 4;\n\n    var flags = frame.buffer.readUInt8(offset, false);\n    offset += 1;\n\n    // TODO: pool these objects\n    var tracing = new TracingInfo(\n        [spanid1, spanid2],\n        [parentid1, parentid2],\n        [traceid1, traceid2],\n        flags\n    );\n\n    frame.cache.tracingValue = tracing;\n\n    return tracing;\n};\n\nCallRequest.RW.lazy.readTracingValue = allocifyPoolFn(CallRequest.RW.lazy.poolReadTracingValue, ReadResult);\n\nfunction TracingInfo(spanid, parentid, traceid, flags) {\n    this.spanid = spanid;\n    this.parentid = parentid;\n    this.traceid = traceid;\n    this.flags = flags;\n}\n\nCallRequest.RW.lazy.readServiceStr = function lazyReadServiceStr(frame) {\n    if (frame.cache.serviceStr !== null) {\n        return frame.cache.serviceStr;\n    }\n\n    var headerStartOffset = findHeaderStartOffset(frame);\n    if (!headerStartOffset) {\n        return null;\n    }\n\n    if (frame.size < headerStartOffset) {\n        return null;\n    }\n    var serviceNameStr = fastBufferToString(\n        frame.buffer,\n        CallRequest.RW.lazy.serviceOffset + 1,\n        headerStartOffset\n    );\n\n    frame.cache.serviceStr = serviceNameStr;\n\n    return serviceNameStr;\n};\n\nfunction findHeaderStartOffset(frame) {\n    if (frame.cache.headerStartOffset) {\n        return frame.cache.headerStartOffset;\n    }\n\n    var offset = CallRequest.RW.lazy.serviceOffset;\n    if (frame.size < offset + 1) {\n        return 0;\n    }\n    var strLength = frame.buffer.readUInt8(offset, false);\n    offset += strLength + 1;\n\n    frame.cache.headerStartOffset = offset;\n    return offset;\n}\n\nfunction scanAndSkipHeaders(frame) {\n    var offset = findHeaderStartOffset(frame);\n    if (!offset) {\n        return false;\n    }\n\n    if (frame.size < offset + 1) {\n        return false;\n    }\n    var nh = frame.buffer.readUInt8(offset, false);\n    offset += 1;\n\n    var cnValueOffset = 0;\n    var rdValueOffset = 0;\n\n    for (var i = 0; i < nh; i++) {\n        if (frame.size < offset + 1) {\n            return false;\n        }\n        var keyLength = frame.buffer.readUInt8(offset, false);\n        offset += 1;\n        if (frame.size < keyLength + offset) {\n            return false;\n        }\n\n        var keyValue = null;\n\n        if (!cnValueOffset && keyLength === 2) {\n            keyValue = keyValue || frame.buffer.readUInt16BE(offset, false);\n            if (keyValue === CN_VALUE) {\n                cnValueOffset = offset + keyLength;\n            }\n        }\n\n        if (!rdValueOffset && keyLength === 2) {\n            keyValue = keyValue || frame.buffer.readUInt16BE(offset, false);\n            if (keyValue === RD_VALUE) {\n                rdValueOffset = offset + keyLength;\n            }\n        }\n\n        offset += keyLength;\n\n        if (frame.size < offset + 1) {\n            return false;\n        }\n        var valueLength = frame.buffer.readUInt8(offset, false);\n        offset += 1;\n        if (frame.size < valueLength + offset) {\n            return false;\n        }\n\n        offset += valueLength;\n    }\n\n    frame.cache.cnValueOffset = cnValueOffset;\n    frame.cache.rdValueOffset = rdValueOffset;\n    frame.cache.csumStartOffset = offset;\n    return true;\n}\n\nCallRequest.RW.lazy.readCallerNameStr =\nfunction readCallerNameStr(frame) {\n    /*eslint complexity: [2, 20]*/\n    if (frame.cache.callerNameStr !== null) {\n        return frame.cache.callerNameStr;\n    }\n\n    if (frame.cache.cnValueOffset === null) {\n        var success = scanAndSkipHeaders(frame);\n        if (!success) {\n            return null;\n        }\n    }\n\n    var offset = frame.cache.cnValueOffset;\n    if (!offset) {\n        return null;\n    }\n\n    var callerNameStr = readUInt8String(frame, offset);\n    if (!callerNameStr) {\n        return null;\n    }\n\n    frame.cache.callerNameStr = callerNameStr;\n    return callerNameStr;\n};\n\nCallRequest.RW.lazy.readRoutingDelegateStr =\nfunction readRoutingDelegateStr(frame) {\n    /*eslint complexity: [2, 20]*/\n    if (frame.cache.routingDelegateStr !== null) {\n        return frame.cache.routingDelegateStr;\n    }\n\n    if (frame.cache.rdValueOffset === null) {\n        var success = scanAndSkipHeaders(frame);\n        if (!success) {\n            return null;\n        }\n    }\n\n    var offset = frame.cache.rdValueOffset;\n    if (!offset) {\n        return null;\n    }\n\n    var routingDelegateStr = readUInt8String(frame, offset);\n    if (!routingDelegateStr) {\n        return null;\n    }\n\n    frame.cache.routingDelegateStr = routingDelegateStr;\n    return routingDelegateStr;\n};\n\nfunction readUInt8String(frame, offset) {\n    if (frame.size < offset + 1) {\n        return null;\n    }\n    var valueLength = frame.buffer.readUInt8(offset, false);\n    offset += 1;\n\n    var end = offset + valueLength;\n    if (frame.size < end) {\n        return null;\n    }\n\n    return fastBufferToString(frame.buffer, offset, end);\n}\n\nCallRequest.RW.lazy.readArg1Str = function readArg1Str(frame) {\n    if (frame.cache.arg1Str !== null) {\n        return frame.cache.arg1Str;\n    }\n\n    if (!frame.cache.csumStartOffset) {\n        var success = scanAndSkipHeaders(frame);\n        if (!success) {\n            frame.cache.lastError = 'Could not scan & skip headers';\n            return null;\n        }\n    }\n\n    var offset = frame.cache.csumStartOffset;\n\n    if (frame.size < offset + 1) {\n        frame.cache.lastError = 'Could not read csum type';\n        return null;\n    }\n    var csumType = frame.buffer.readUInt8(offset, false);\n    offset += 1;\n\n    if (csumType !== Checksum.Types.None) {\n        offset += Checksum.offsetWidth(csumType);\n    }\n\n    if (frame.size < offset + 2) {\n        frame.cache.lastError = 'Could not read arg1 size';\n        return null;\n    }\n    var arg1Length = frame.buffer.readUInt16BE(offset, false);\n    offset += 2;\n\n    var end = offset + arg1Length;\n\n    if (frame.size < end) {\n        frame.cache.lastError = 'Could not read arg1 itself';\n        return null;\n    }\n    var arg1Str = fastBufferToString(frame.buffer, offset, end);\n\n    frame.cache.arg1Str = arg1Str;\n\n    return arg1Str;\n};\n\nCallRequest.RW.lazy.poolReadHeaders = function poolReadHeaders(destResult, frame) {\n    // last fixed offset\n    var offset = CallRequest.RW.lazy.serviceOffset;\n\n    if (frame.cache.headerStartOffset !== null) {\n        offset = frame.cache.headerStartOffset;\n    } else {\n        // SKIP service~1\n        var res = bufrw.str1.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) {\n            return res;\n        }\n        offset = res.offset + res.value;\n        frame.cache.headerStartOffset = offset;\n    }\n\n    // READ nh:1 (hk~1 hv~1){nh}\n    return header.header1.poolLazyRead(destResult, frame, offset);\n};\n\nCallRequest.RW.lazy.readHeaders = allocifyPoolFn(CallRequest.RW.lazy.poolReadHeaders, ReadResult);\n\nCallRequest.RW.lazy.poolReadArg1 = function poolReadArg1(destResult, frame, headers) {\n    var res = null;\n    var offset = 0;\n\n    // TODO: memoize computed offsets on frame between readService, readArg1,\n    // and any others\n\n    if (headers) {\n        offset = headers.offset;\n    } else {\n        // last fixed offset\n        offset = CallRequest.RW.lazy.serviceOffset;\n\n        // SKIP service~1\n        res = bufrw.str1.sizerw.poolReadFrom(destResult, frame.buffer, offset);\n        if (res.err) {\n            return res;\n        }\n        offset = res.offset + res.value;\n\n        // SKIP nh:1 (hk~1 hv~1){nh}\n        res = header.header1.poolLazySkip(destResult, frame, offset);\n        if (res.err) {\n            return res;\n        }\n        offset = res.offset;\n    }\n\n    // SKIP csumtype:1 (csum:4){0,1}\n    res = Checksum.RW.poolLazySkip(destResult, frame, offset);\n    if (res.err) {\n        return res;\n    }\n    offset = res.offset;\n\n    // READ arg~2\n    return argsrw.argrw.poolReadFrom(destResult, frame.buffer, offset);\n};\n\nCallRequest.RW.lazy.readArg1 = allocifyPoolFn(CallRequest.RW.lazy.poolReadArg1, ReadResult);\n\nCallRequest.RW.lazy.isFrameTerminal = function isFrameTerminal(frame) {\n    var flags = CallRequest.RW.lazy.poolReadFlags(readRes, frame);\n    var frag = flags.value & CallFlags.Fragment;\n    return !frag;\n};\n\nfunction callReqLength(destResult, body) {\n    var res;\n    var length = 0;\n\n    // flags:1\n    length += bufrw.UInt8.width;\n\n    // ttl:4\n    length += bufrw.UInt32BE.width;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolByteLength(destResult, body.tracing);\n    if (res.err) return res;\n    length += res.length;\n\n    // service~1\n    res = bufrw.str1.poolByteLength(destResult, body.service);\n    if (res.err) return res;\n    length += res.length;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolByteLength(destResult, body.headers);\n    if (res.err) return res;\n    length += res.length;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolByteLength(destResult, body);\n    if (!res.err) res.length += length;\n\n    return res;\n}\n\nfunction readCallReqFrom(destResult, buffer, offset) {\n    var res;\n    var body = new CallRequest();\n\n    // flags:1\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.flags = res.value;\n\n    // ttl:4\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n\n    if (res.value <= 0) {\n        return destResult.reset(errors.InvalidTTL({\n            ttl: res.value,\n            isParseError: true\n        }), offset, body);\n    }\n\n    offset = res.offset;\n    body.ttl = res.value;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.tracing = res.value;\n\n    // service~1\n    res = bufrw.str1.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.service = res.value;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.headers = res.value;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolReadFrom(destResult, body, buffer, offset);\n    if (!res.err) res.value = body;\n\n    return res;\n}\n\nfunction writeCallReqInto(destResult, body, buffer, offset) {\n    var start = offset;\n    var res;\n\n    // flags:1 -- filled in later after argsrw\n    offset += bufrw.UInt8.width;\n\n    if (body.ttl <= 0) {\n        return destResult.reset(errors.InvalidTTL({\n            ttl: body.ttl\n        }), offset);\n    }\n\n    // ttl:4\n    res = bufrw.UInt32BE.poolWriteInto(destResult, body.ttl, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolWriteInto(destResult, body.tracing, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // service~1\n    res = bufrw.str1.poolWriteInto(destResult, body.service, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolWriteInto(destResult, body.headers, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)* -- (may mutate body.flags)\n    res = argsrw.poolWriteInto(destResult, body, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // now we know the final flags, write them\n    res = bufrw.UInt8.poolWriteInto(destResult, body.flags, buffer, start);\n    if (!res.err) res.offset = offset;\n\n    return res;\n}\n\nCallRequest.prototype.verifyChecksum = function verifyChecksum() {\n    return this.csum.verify(this.args);\n};\n\n// flags:1 code:1 tracing:24 traceflags:1 nh:1 (hk~1 hv~1){nh} csumtype:1 (csum:4){0,1} (arg~2)*\nfunction CallResponse(flags, code, tracing, headers, csum, args) {\n    this.type = CallResponse.TypeCode;\n    this.flags = flags || 0;\n    this.code = code || CallResponse.Codes.OK;\n    this.tracing = tracing || Tracing.emptyTracing;\n    this.headers = headers || {};\n    this.csum = Checksum.objOrType(csum);\n    this.args = args || [];\n    this.cont = null;\n}\n\nCallResponse.Cont = require('./cont').ResponseCont;\nCallResponse.TypeCode = 0x04;\nCallResponse.Codes = ResponseCodes;\nCallResponse.RW = bufrw.Base(callResLength, readCallResFrom, writeCallResInto, true);\n\nCallResponse.RW.lazy = {};\n\nCallResponse.RW.lazy.flagsOffset = Frame.Overhead;\nCallResponse.RW.lazy.poolReadFlags = function poolReadFlags(destResult, frame) {\n    // flags:1\n    return bufrw.UInt8.poolReadFrom(destResult, frame.buffer, CallResponse.RW.lazy.flagsOffset);\n};\n\nCallResponse.RW.lazy.readFlags = allocifyPoolFn(CallResponse.RW.lazy.poolReadFlags, ReadResult);\n\nCallResponse.RW.lazy.codeOffset = CallResponse.RW.lazy.flagsOffset + 1;\nCallResponse.RW.lazy.poolReadCode = function poolReadCode(destResult, frame) {\n    // code:1\n    return bufrw.UInt8.poolReadFrom(destResult, frame.buffer, CallResponse.RW.lazy.codeOffset);\n};\n// TODO: readCode?\n\nCallResponse.RW.lazy.tracingOffset = CallResponse.RW.lazy.codeOffset + 1;\nCallResponse.RW.lazy.poolReadTracing = function poolLazyReadTracing(destResult, frame) {\n    // tracing:24 traceflags:1\n    return Tracing.RW.poolReadFrom(destResult, frame.buffer, CallResponse.RW.lazy.tracingOffset);\n};\n\nCallResponse.RW.lazy.readTracing = allocifyPoolFn(CallResponse.RW.lazy.poolReadTracing, ReadResult);\n\nCallResponse.RW.lazy.headersOffset = CallResponse.RW.lazy.tracingOffset + 25;\n\nCallResponse.RW.lazy.poolReadHeaders = function poolReadHeaders(destResult, frame) {\n    // last fixed offset\n    var offset = CallResponse.RW.lazy.headersOffset;\n\n    // TODO: memoize computed offsets on frame between readService, readArg1,\n    // and any others\n\n    // READ nh:1 (hk~1 hv~1){nh}\n    return header.header1.poolLazyRead(destResult, frame, offset);\n};\n\nCallResponse.RW.lazy.readHeaders = allocifyPoolFn(CallResponse.RW.lazy.readHeaders, ReadResult);\n\nCallResponse.RW.lazy.poolReadArg1 = function poolReadArg1(destResult, frame, headers) {\n    var res = null;\n    var offset = 0;\n\n    if (headers) {\n        offset = headers.offset;\n    } else {\n        // last fixed offset\n        offset = CallResponse.RW.lazy.headersOffset;\n\n        // TODO: memoize computed offsets on frame between readService, readArg1,\n        // and any others\n\n        // SKIP nh:1 (hk~1 hv~1){nh}\n        res = header.header1.poolLazySkip(destResult, frame, offset);\n        if (res.err) {\n            return res;\n        }\n        offset = res.offset;\n    }\n\n    // SKIP csumtype:1 (csum:4){0,1}\n    res = Checksum.RW.poolLazySkip(destResult, frame, offset);\n    if (res.err) {\n        return res;\n    }\n    offset = res.offset;\n\n    // READ arg~2\n    return argsrw.argrw.poolReadFrom(destResult, frame.buffer, offset);\n};\n\nCallResponse.RW.lazy.readArg1 = allocifyPoolFn(CallResponse.RW.lazy.readarg1, ReadResult);\n\nCallResponse.RW.lazy.isFrameTerminal = function isFrameTerminal(frame) {\n    var flags = CallResponse.RW.lazy.poolReadFlags(readRes, frame);\n    var frag = flags.value & CallFlags.Fragment;\n    return !frag;\n};\n\nfunction callResLength(destResult, body) {\n    var res;\n    var length = 0;\n\n    // flags:1\n    length += bufrw.UInt8.width;\n    // code:1\n    length += bufrw.UInt8.width;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolByteLength(destResult, body.tracing);\n    if (res.err) return res;\n    length += res.length;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolByteLength(destResult, body.headers);\n    if (res.err) return res;\n    length += res.length;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolByteLength(destResult, body);\n    if (!res.err) res.length += length;\n\n    return res;\n}\n\nfunction readCallResFrom(destResult, buffer, offset) {\n    var res;\n    var body = new CallResponse();\n\n    // flags:1\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.flags = res.value;\n\n    // code:1\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.code = res.value;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.tracing = res.value;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.headers = res.value;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolReadFrom(destResult, body, buffer, offset);\n    if (!res.err) res.value = body;\n\n    return res;\n}\n\nfunction writeCallResInto(destResult, body, buffer, offset) {\n    var start = offset;\n    var res;\n\n    // flags:1 -- filled in later after argsrw\n    offset += bufrw.UInt8.width;\n\n    // code:1\n    res = bufrw.UInt8.poolWriteInto(destResult, body.code, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // tracing:24 traceflags:1\n    res = Tracing.RW.poolWriteInto(destResult, body.tracing, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // nh:1 (hk~1 hv~1){nh}\n    res = header.header1.poolWriteInto(destResult, body.headers, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)* -- (may mutate body.flags)\n    res = argsrw.poolWriteInto(destResult, body, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // now we know the final flags, write them\n    res = bufrw.UInt8.poolWriteInto(destResult, body.flags, buffer, start);\n    if (!res.err) res.offset = offset;\n\n    return res;\n}\n\nCallResponse.prototype.verifyChecksum = function verifyChecksum() {\n    return this.csum.verify(this.args);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/args.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar bufrw = require('bufrw');\nvar Buffer = require('buffer').Buffer;\nvar Checksum = require('./checksum');\nvar Flags = require('./call_flags');\nvar errors = require('../errors');\n\nvar Base = bufrw.Base;\nvar LengthResult = bufrw.LengthResult;\n\n/* eslint-disable curly */\n\nfunction ArgRW(sizerw) {\n    Base.call(this);\n    this.sizerw = sizerw;\n    this.strrw = bufrw.String(this.sizerw, 'utf8');\n    this.bufrw = bufrw.VariableBuffer(this.sizerw, true);\n}\n\ninherits(ArgRW, bufrw.Base);\n\nArgRW.prototype.poolByteLength = function poolByteLength(destResult, arg) {\n    if (typeof arg === 'string') {\n        return this.strrw.poolByteLength(destResult, arg);\n    } else {\n        return this.bufrw.poolByteLength(destResult, arg);\n    }\n};\n\nArgRW.prototype.poolWriteInto = function poolWriteInto(destResult, arg, buffer, offset) {\n    if (typeof arg === 'string') {\n        return this.strrw.poolWriteInto(destResult, arg, buffer, offset);\n    } else {\n        return this.bufrw.poolWriteInto(destResult, arg, buffer, offset);\n    }\n};\n\nArgRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n    return this.bufrw.poolReadFrom(destResult, buffer, offset);\n};\n\nvar arg2 = new ArgRW(bufrw.UInt16BE);\n\nfunction ArgsRW(argrw) {\n    argrw = argrw || arg2;\n    assert(argrw.sizerw && argrw.sizerw.width, 'invalid argrw');\n    bufrw.Base.call(this);\n    this.argrw = argrw;\n    this.overhead = this.argrw.sizerw.width;\n}\ninherits(ArgsRW, bufrw.Base);\n\nArgsRW.prototype.poolByteLength = function poolByteLength(destResult, body) {\n    var length = 0;\n    var res;\n\n    res = Checksum.RW.poolByteLength(destResult, body.csum);\n    if (res.err) return res;\n    length += res.length;\n\n    if (body.args === null) {\n        return destResult.reset(null, length);\n    }\n\n    if (!Array.isArray(body.args)) {\n        return destResult.reset(null, errors.InvalidArgumentError({\n            argType: typeof body.args,\n            argConstructor: body.args.constructor.name\n        }));\n    }\n\n    for (var i = 0; i < body.args.length; i++) {\n        res = this.argrw.poolByteLength(destResult, body.args[i]);\n        if (res.err) return res;\n        length += res.length;\n    }\n\n    return destResult.reset(null, length);\n};\n\nvar lenres = new LengthResult();\nArgsRW.prototype.poolWriteInto = function poolWriteInto(destResult, body, buffer, offset) {\n    var start = offset;\n    var res;\n\n    lenres = Checksum.RW.poolByteLength(lenres, body.csum);\n    if (lenres.err) return destResult.replace(lenres.err);\n    offset += lenres.length;\n\n    if (body.cont === null) {\n        res = this.writeFragmentInto(destResult, body, buffer, offset);\n        if (res.err) return res;\n        offset = res.offset;\n    } else {\n        // assume that something else already did the fragmentation correctly\n        for (var i = 0; i < body.args.length; i++) {\n            res = this.argrw.poolWriteInto(destResult, body.args[i], buffer, offset);\n            if (res.err) return res;\n            var buf = buffer.slice(offset + this.overhead, res.offset);\n            body.csum.update1(buf, body.csum.val);\n            offset = res.offset;\n        }\n    }\n\n    res = Checksum.RW.poolWriteInto(destResult, body.csum, buffer, start);\n    if (!res.err) res.offset = offset;\n\n    return res;\n};\n\nArgsRW.prototype.poolReadFrom = function poolReadFrom(destResult, body, buffer, offset) {\n    var res;\n\n    // TODO: missing symmetry: verify csum (requires prior somehow)\n\n    res = Checksum.RW.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.csum = res.value;\n\n    body.args = [];\n    while (offset < buffer.length) {\n        res = this.argrw.poolReadFrom(destResult, buffer, offset);\n        if (res.err) return res;\n        offset = res.offset;\n        body.args.push(res.value);\n    }\n\n    return destResult.reset(null, offset, body);\n};\n\nArgsRW.prototype.writeFragmentInto = function writeFragmentInto(destResult, body, buffer, offset) {\n    var res;\n    var i = 0;\n    var remain = buffer.length - offset;\n\n    do {\n        var arg = body.args[i] || Buffer(0);\n        if (!Buffer.isBuffer(arg)) {\n            arg = new Buffer(arg);\n        }\n        var min = this.overhead + arg.length ? 1 : 0;\n        if (remain < min) break;\n        var need = this.overhead + arg.length;\n        if (need > remain) {\n            var j = remain - this.overhead;\n            body.args[i] = arg.slice(0, j);\n            body.cont = new body.constructor.Cont(\n                body.flags & Flags.Fragment,\n                body.csum, // share on purpose\n                body.args.splice(i + 1)\n            );\n            body.cont.args.unshift(arg.slice(j));\n            body.flags |= Flags.Fragment;\n            arg = body.args[i];\n        }\n        res = this.argrw.poolWriteInto(destResult, arg, buffer, offset);\n        if (res.err) return res;\n        var buf = buffer.slice(offset + this.overhead, res.offset);\n        body.csum.update1(buf, body.csum.val);\n        offset = res.offset;\n        remain = buffer.length - offset;\n    } while (remain >= this.overhead && ++i < body.args.length);\n\n    return res || destResult.reset(null, offset);\n};\n\nmodule.exports = ArgsRW;\nmodule.exports.ArgRW = ArgRW;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/checksum.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n\nvar assert = require('assert');\nvar farm32 = require('farmhash').fingerprint32;\nvar crc32 = require('crc').crc32;\nvar crc32c = require('sse4_crc32').calculate;\nvar bufrw = require('bufrw');\nvar bufrwErrors = require('bufrw/errors');\nvar errors = require('../errors');\n\nmodule.exports = Checksum;\n\n// csumtype:1 (csum:4){0,1}\nfunction Checksum(type, val) {\n    this.type = type;\n    this.val = val || 0;\n    switch (this.type) {\n        case 0x00:\n            this._compute = this._computeNone;\n            break;\n        case 0x01:\n            this._compute = this._computeCrc32;\n            break;\n        case 0x02:\n            this._compute = this._computeFarm32;\n            break;\n        case 0x03:\n            this._compute = this._computeCrc32C;\n            break;\n        default:\n            assert(false, 'invalid checksum type ' + this.type);\n    }\n}\n\nChecksum.objOrType = function objOrType(arg) {\n    if (arg instanceof Checksum) {\n        return arg;\n    }\n    if (arg === undefined || arg === null) {\n        return new Checksum(Checksum.Types.None);\n    }\n    assert(typeof arg === 'number',\n           'expected a Checksum object or a valid checksum type');\n    switch (arg) {\n        case 0x00:\n        case 0x01:\n        case 0x02:\n        case 0x03:\n            return new Checksum(arg);\n        default:\n            assert(false, 'expected a Checksum object or a valid checksum type');\n    }\n};\n\nChecksum.offsetWidth = function offsetWidth(type) {\n    switch (type) {\n        case 0x00:\n            return 0;\n        case 0x01:\n        case 0x02:\n        case 0x03:\n            return 4;\n        default:\n            assert(false, 'expected valid checksum type');\n    }\n};\n\nChecksum.Types = Object.create(null);\nChecksum.Types.None = 0x00;\nChecksum.Types.CRC32 = 0x01;\nChecksum.Types.Farm32 = 0x02;\nChecksum.Types.CRC32C = 0x03;\n\n// csumtype:1 (csum:4){0,1}\n\nvar rwCases = Object.create(null);\nrwCases[Checksum.Types.None] = bufrw.Null;\nrwCases[Checksum.Types.CRC32] = bufrw.UInt32BE;\nrwCases[Checksum.Types.Farm32] = bufrw.UInt32BE;\nrwCases[Checksum.Types.CRC32C] = bufrw.UInt32BE;\n\nChecksum.RW = bufrw.Switch(bufrw.UInt8, rwCases, {\n    cons: Checksum,\n    valKey: 'type',\n    dataKey: 'val'\n});\n\nChecksum.RW.poolLazySkip = function poolLazySkip(destResult, frame, offset) {\n    var res = bufrw.UInt8.poolReadFrom(destResult, frame.buffer, offset);\n    if (res.err) {\n        return res;\n    }\n    offset = res.offset;\n\n    var caseRW = rwCases[res.value];\n    if (!caseRW) {\n        res.err = bufrwErrors.InvalidSwitchValue({\n            value: res.value\n        });\n        return res;\n    }\n\n    offset += caseRW.width;\n    res.offset = offset;\n    res.value = null;\n    return res;\n};\n\nChecksum.prototype.compute = function compute(args, prior) {\n    if (typeof prior !== 'number') prior = 0;\n    if (this.type === Checksum.Types.None) {\n        return 0;\n    } else {\n        var csum = prior;\n        for (var i = 0; i < args.length; i++) {\n            csum = this._compute(args[i], csum);\n        }\n        return csum;\n    }\n};\n\nChecksum.prototype._computeNone = function _computeNone() {\n    return 0;\n};\n\nChecksum.prototype._computeCrc32 = function _computeCrc32(arg, prior) {\n    if (prior === 0) prior = undefined;\n    return crc32(arg, prior);\n};\n\nChecksum.prototype._computeCrc32C = function _computeCrc32C(arg, prior) {\n    return crc32c(arg, prior);\n};\n\nChecksum.prototype._computeFarm32 = function _computeFarm32(arg, prior) {\n    return farm32(arg, prior);\n};\n\nChecksum.prototype.update1 = function update1(arg, prior) {\n    this.val = this._compute(arg, prior);\n};\n\nChecksum.prototype.update = function update(args, prior) {\n    this.val = this.compute(args, prior);\n};\n\nChecksum.prototype.verify = function verify(args, prior) {\n    if (this.type === Checksum.Types.None) {\n        return null;\n    }\n    var val = this.compute(args, prior);\n    if (val === this.val) {\n        return null;\n    } else {\n        return errors.ChecksumError({\n            checksumType: this.type,\n            expectedValue: this.val,\n            actualValue: val\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/tracing.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n/* eslint max-statements: [1, 31] */\n\nvar bufrw = require('bufrw');\nvar Buffer = require('buffer').Buffer;\n\nmodule.exports = Tracing;\n\nvar emptySpanId = Buffer(8);\nvar emptyParentId = Buffer(8);\nvar emptyTraceId = Buffer(8);\nemptySpanId.fill(0);\nemptyParentId.fill(0);\nemptyTraceId.fill(0);\n\nfunction Tracing(spanid, parentid, traceid, flags) {\n    this.spanid = spanid || [0, 0];\n    this.parentid = parentid || [0, 0];\n    this.traceid = traceid || [0, 0];\n    this.flags = flags || 0;\n}\n\nTracing.RW = bufrw.Base(tracingByteLength, readTracingFrom, writeTracingInto, true);\n\nfunction tracingByteLength(destResult) {\n    return destResult.reset(\n        null,\n        8 + // spanid:8\n        8 + // parentid:8\n        8 + // traceid:8\n        1   // flags:1\n    );\n}\n\nfunction writeTracingInto(destResult, tracing, buffer, offset) {\n    var res;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.spanid[0], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.spanid[1], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.parentid[0], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.parentid[1], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.traceid[0], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt32BE.poolWriteInto(destResult, tracing.traceid[1], buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    res = bufrw.UInt8.poolWriteInto(destResult, tracing.flags, buffer, offset);\n\n    return res;\n}\n\nfunction readTracingFrom(destResult, buffer, offset) {\n    var tracing = new Tracing();\n    var res;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.spanid[0] = res.value;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.spanid[1] = res.value;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.parentid[0] = res.value;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.parentid[1] = res.value;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.traceid[0] = res.value;\n\n    res = bufrw.UInt32BE.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.traceid[1] = res.value;\n\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    tracing.flags = res.value;\n\n    return destResult.reset(null, offset, tracing);\n}\n\nTracing.emptyTracing = new Tracing();\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/cont.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\nvar Checksum = require('./checksum');\nvar ArgsRW = require('./args');\nvar Frame = require('./frame');\nvar CallFlags = require('./call_flags');\nvar argsrw = new ArgsRW();\n\n/* eslint-disable curly */\n\n// flags:1 csumtype:1 (csum:4){0,1} (arg~2)+\nfunction CallRequestCont(flags, csum, args) {\n    this.type = CallRequestCont.TypeCode;\n    this.flags = flags || 0;\n    this.csum = Checksum.objOrType(csum);\n    this.args = args || [];\n    this.cont = null;\n}\n\nCallRequestCont.TypeCode = 0x13;\nCallRequestCont.Cont = CallRequestCont;\nCallRequestCont.RW = bufrw.Base(callReqContLength, readCallReqContFrom, writeCallReqContInto, true);\n\nCallRequestCont.RW.lazy = {};\n\nCallRequestCont.RW.lazy.flagsOffset = Frame.Overhead;\nCallRequestCont.RW.lazy.readFlags = function readFlags(frame) {\n    // flags:1\n    return bufrw.UInt8.readFrom(frame.buffer, CallRequestCont.RW.lazy.flagsOffset);\n};\n\nCallRequestCont.RW.lazy.isFrameTerminal = function isFrameTerminal(frame) {\n    var flags = CallRequestCont.RW.lazy.readFlags(frame);\n    var frag = flags.value & CallFlags.Fragment;\n    return !frag;\n};\n\nfunction callReqContLength(destResult, body) {\n    var res;\n    var length = 0;\n\n    // flags:1\n    length += bufrw.UInt8.width;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolByteLength(destResult, body);\n    if (!res.err) res.length += length;\n\n    return res;\n}\n\nfunction readCallReqContFrom(destResult, buffer, offset) {\n    var res;\n    // TODO: allow these to be pooled\n    var body = new CallRequestCont();\n\n    // flags:1\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.flags = res.value;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolReadFrom(destResult, body, buffer, offset);\n    if (!res.err) res.value = body;\n\n    return res;\n}\n\nfunction writeCallReqContInto(destResult, body, buffer, offset) {\n    var start = offset;\n    var res;\n\n    // flags:1 -- skip for now, write args frist\n    offset += bufrw.UInt8.width;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)* -- (may mutate body.flags)\n    res = argsrw.poolWriteInto(destResult, body, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // now we know the final flags, write them\n    res = bufrw.UInt8.poolWriteInto(destResult, body.flags, buffer, start);\n    if (!res.err) res.offset = offset;\n\n    return res;\n}\n\nCallRequestCont.prototype.verifyChecksum = function verifyChecksum(prior) {\n    return this.csum.verify(this.args, prior);\n};\n\n// flags:1 csumtype:1 (csum:4){0,1} (arg~2)+\nfunction CallResponseCont(flags, csum, args) {\n    this.type = CallResponseCont.TypeCode;\n    this.flags = flags || 0;\n    this.csum = Checksum.objOrType(csum);\n    this.args = args || [];\n    this.cont = null;\n}\n\nCallResponseCont.TypeCode = 0x14;\nCallResponseCont.Cont = CallResponseCont;\nCallResponseCont.RW = bufrw.Base(callResContLength, readCallResContFrom, writeCallResContInto, true);\n\nCallResponseCont.RW.lazy = {};\n\nCallResponseCont.RW.lazy.flagsOffset = Frame.Overhead;\nCallResponseCont.RW.lazy.readFlags = function readFlags(frame) {\n    // flags:1\n    return bufrw.UInt8.readFrom(frame.buffer, CallResponseCont.RW.lazy.flagsOffset);\n};\n\nCallResponseCont.RW.lazy.isFrameTerminal = function isFrameTerminal(frame) {\n    var flags = CallResponseCont.RW.lazy.readFlags(frame);\n    var frag = flags.value & CallFlags.Fragment;\n    return !frag;\n};\n\nfunction callResContLength(destResult, body) {\n    var res;\n    var length = 0;\n\n    // flags:1\n    length += bufrw.UInt8.width;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolByteLength(destResult, body);\n    if (!res.err) res.length += length;\n\n    return res;\n}\n\nfunction readCallResContFrom(destResult, buffer, offset) {\n    var res;\n    var body = new CallResponseCont();\n\n    // flags:1\n    res = bufrw.UInt8.poolReadFrom(destResult, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n    body.flags = res.value;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)*\n    res = argsrw.poolReadFrom(destResult, body, buffer, offset);\n    if (!res.err) res.value = body;\n\n    return res;\n}\n\nfunction writeCallResContInto(destResult, body, buffer, offset) {\n    var start = offset;\n    var res;\n\n    // flags:1 -- skip for now, write args frist\n    offset += bufrw.UInt8.width;\n\n    // csumtype:1 (csum:4){0,1} (arg~2)* -- (may mutate body.flags)\n    res = argsrw.poolWriteInto(destResult, body, buffer, offset);\n    if (res.err) return res;\n    offset = res.offset;\n\n    // now we know the final flags, write them\n    res = bufrw.UInt8.poolWriteInto(destResult, body.flags, buffer, start);\n    if (!res.err) res.offset = offset;\n\n    return res;\n}\n\nCallResponseCont.prototype.verifyChecksum = function verifyChecksum(prior) {\n    return this.csum.verify(this.args, prior);\n};\n\nmodule.exports.RequestCont = CallRequestCont;\nmodule.exports.ResponseCont = CallResponseCont;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/cancel.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\nvar Tracing = require('./tracing');\n\n// ttl:4 tracing:25 why~2\nfunction Cancel(ttl, tracing, why) {\n    this.type = Cancel.TypeCode;\n    this.ttl = ttl || 0;\n    this.tracing = tracing || Tracing.emptyTracing;\n    this.why = why || '';\n}\n\nCancel.TypeCode = 0xc0;\n\nCancel.RW = bufrw.Struct(Cancel, [\n    {name: 'ttl', rw: bufrw.UInt32BE}, // ttl:4\n    {name: 'tracing', rw: Tracing.RW}, // tracing:25\n    {name: 'why', rw: bufrw.str2}      // why~2\n]);\n\nmodule.exports = Cancel;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/claim.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\nvar Tracing = require('./tracing');\n\n// ttl:4 tracing:25\nfunction Claim(ttl, tracing) {\n    this.type = Claim.TypeCode;\n    this.ttl = ttl || 0;\n    this.tracing = tracing || Tracing.emptyTracing;\n}\n\nClaim.TypeCode = 0xc1;\n\nClaim.RW = bufrw.Struct(Claim, [\n    {name: 'ttl', rw: bufrw.UInt32BE}, // ttl:4\n    {name: 'tracing', rw: Tracing.RW}  // tracing:25\n]);\n\nmodule.exports = Claim;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/ping.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\n\nmodule.exports.Request = PingRequest;\nmodule.exports.Response = PingResponse;\n\nfunction PingRequest() {\n    this.type = PingRequest.TypeCode;\n}\n\nPingRequest.TypeCode = 0xd0;\nPingRequest.RW = bufrw.Struct(PingRequest, []);\n\nfunction PingResponse() {\n    this.type = PingResponse.TypeCode;\n}\n\nPingResponse.TypeCode = 0xd1;\nPingResponse.RW = bufrw.Struct(PingResponse, []);\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/error_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\nvar Frame = require('./frame');\nvar Tracing = require('./tracing');\n\nvar errors = require('../errors');\n\n// TODO: enforce message ID of this frame is Frame.NullId when\n// errorBody.code.ProtocolError = ErrorResponse.Codes.ProtocolError\n\n// code:1 tracing:25 message~2\nfunction ErrorResponse(code, tracing, message) {\n    this.code = code || 0;\n    this.tracing = tracing || Tracing.emptyTracing;\n    this.type = ErrorResponse.TypeCode;\n    this.message = message || '';\n}\n\nErrorResponse.TypeCode = 0xff;\n\nvar Codes = Object.create(null);\n// 0x00 not a valid value for \"code\", do not use.\nCodes.Timeout = 0x01;\nCodes.Cancelled = 0x02;\nCodes.Busy = 0x03;\nCodes.Declined = 0x04;\nCodes.UnexpectedError = 0x05;\nCodes.BadRequest = 0x06;\nCodes.NetworkError = 0x07;\nCodes.Unhealthy = 0x08;\nCodes.ProtocolError = 0xff;\n\nvar CodeNames = Object.create(null);\nCodeNames[Codes.Timeout] = 'Timeout';\nCodeNames[Codes.Cancelled] = 'Cancelled';\nCodeNames[Codes.Busy] = 'Busy';\nCodeNames[Codes.Declined] = 'Declined';\nCodeNames[Codes.UnexpectedError] = 'UnexpectedError';\nCodeNames[Codes.BadRequest] = 'BadRequest';\nCodeNames[Codes.NetworkError] = 'NetworkError';\nCodeNames[Codes.ProtocolError] = 'ProtocolError';\nCodeNames[Codes.Unhealthy] = 'Unhealthy';\n\nfunction TimeoutError(opts) {\n    this.name = 'TchannelTimeoutError';\n    this.fullType = 'tchannel.timeout';\n    this.type = 'tchannel.timeout';\n    this.message = 'TChannel timeout';\n    this.isErrorFrame = true;\n    this.codeName = 'Timeout';\n    this.errorCode = Codes.Timeout;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction CancelledError(opts) {\n    this.name = 'TchannelCancelledError';\n    this.fullType = 'tchannel.cancelled';\n    this.type = 'tchannel.cancelled';\n    this.message = 'TChannel cancelled';\n    this.isErrorFrame = true;\n    this.codeName = 'Cancelled';\n    this.errorCode = Codes.Cancelled;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction BusyError(opts) {\n    this.name = 'TchannelBusyError';\n    this.fullType = 'tchannel.busy';\n    this.type = 'tchannel.busy';\n    this.message = 'TChannel busy';\n    this.isErrorFrame = true;\n    this.codeName = 'Busy';\n    this.errorCode = Codes.Busy;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction DeclinedError(opts) {\n    this.name = 'TchannelDeclinedError';\n    this.fullType = 'tchannel.declined';\n    this.type = 'tchannel.declined';\n    this.message = 'TChannel declined';\n    this.isErrorFrame = true;\n    this.codeName = 'Declined';\n    this.errorCode = Codes.Declined;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction UnexpectedErrorError(opts) {\n    this.name = 'TchannelUnexpectedError';\n    this.fullType = 'tchannel.unexpected';\n    this.type = 'tchannel.unexpected';\n    this.message = 'TChannel unexpected error';\n    this.isErrorFrame = true;\n    this.codeName = 'UnexpectedError';\n    this.errorCode = Codes.UnexpectedError;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction BadRequestError(opts) {\n    this.name = 'TchannelBadRequestError';\n    this.fullType = 'tchannel.bad-request';\n    this.type = 'tchannel.bad-request';\n    this.message = 'TChannel BadRequest';\n    this.isErrorFrame = true;\n    this.codeName = 'BadRequest';\n    this.errorCode = Codes.BadRequest;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction NetworkErrorError(opts) {\n    this.name = 'TchannelNetworkError';\n    this.fullType = 'tchannel.network';\n    this.type = 'tchannel.network';\n    this.message = 'TChannel network error';\n    this.isErrorFrame = true;\n    this.codeName = 'NetworkError';\n    this.errorCode = Codes.NetworkError;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction ProtocolErrorError(opts) {\n    this.name = 'TchannelProtocolError';\n    this.fullType = 'tchannel.protocol';\n    this.type = 'tchannel.protocol';\n    this.message = 'TChannel protocol error';\n    this.isErrorFrame = true;\n    this.codeName = 'ProtocolError';\n    this.errorCode = Codes.ProtocolError;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nfunction UnhealthyError(opts) {\n    this.name = 'TchannelUnhealthyError';\n    this.fullType = 'tchannel.unhealthy';\n    this.type = 'tchannel.unhealthy';\n    this.message = 'TChannel unhealthy';\n    this.isErrorFrame = true;\n    this.codeName = 'Unhealthy';\n    this.errorCode = Codes.Unhealthy;\n    this.originalId = null;\n    this.remoteAddr = null;\n    if (opts) {\n        if (opts.message !== undefined) {\n            this.message = opts.message;\n        }\n        if (opts.originalId !== undefined) {\n            this.originalId = opts.originalId;\n        }\n        if (opts.remoteAddr !== undefined) {\n            this.remoteAddr = opts.remoteAddr;\n        }\n    }\n}\n\nvar CodeErrors = Object.create(null);\nCodeErrors[Codes.Timeout] = TimeoutError;\nCodeErrors[Codes.Cancelled] = CancelledError;\nCodeErrors[Codes.Busy] = BusyError;\nCodeErrors[Codes.Declined] = DeclinedError;\nCodeErrors[Codes.UnexpectedError] = UnexpectedErrorError;\nCodeErrors[Codes.BadRequest] = BadRequestError;\nCodeErrors[Codes.NetworkError] = NetworkErrorError;\nCodeErrors[Codes.ProtocolError] = ProtocolErrorError;\nCodeErrors[Codes.Unhealthy] = UnhealthyError;\n\nErrorResponse.Codes = Codes;\nErrorResponse.CodeNames = CodeNames;\nErrorResponse.CodeErrors = CodeErrors;\n\nErrorResponse.RW = bufrw.Struct(ErrorResponse, [\n    {call: {poolWriteInto: function writeGuard(destResult, body, buffer, offset) {\n        if (CodeNames[body.code] === undefined) {\n            return destResult.reset(errors.InvalidErrorCodeError({\n                errorCode: body.code,\n                tracing: body.tracing\n            }), offset);\n        }\n        return destResult.reset(null, offset);\n    }}},\n    {name: 'code', rw: bufrw.UInt8},    // code:1\n    {name: 'tracing', rw: Tracing.RW},  // tracing:25\n    {name: 'message', rw: bufrw.str2},  // message~2\n    {call: {poolWriteInto: function writeGuard(destResult, body, buffer, offset) {\n        if (CodeNames[body.code] === undefined) {\n            destResult.reset(errors.InvalidErrorCodeError({\n                errorCode: body.code,\n                tracing: body.tracing\n            }), offset);\n        }\n        return destResult.reset(null, offset);\n    }}}\n]);\n\nErrorResponse.RW.lazy = {};\n\nErrorResponse.RW.lazy.isFrameTerminal = function isFrameTerminal() {\n    return true;\n};\n\nErrorResponse.RW.lazy.codeOffset = Frame.Overhead;\nErrorResponse.RW.lazy.readCode = function readCode(frame) {\n    // code:1\n    return bufrw.UInt8.readFrom(frame.buffer, ErrorResponse.RW.lazy.codeOffset);\n};\n\nErrorResponse.RW.lazy.tracingOffset = ErrorResponse.RW.lazy.codeOffset + 1;\nErrorResponse.RW.lazy.readTracing = function readTracing(frame) {\n    // tracing:25\n    return Tracing.RW.readFrom(frame.buffer, ErrorResponse.RW.lazy.tracingOffset);\n};\n\nErrorResponse.RW.lazy.mesasgeOffset = ErrorResponse.RW.lazy.tracingOffset + 25;\nErrorResponse.RW.lazy.readMessage = function readMessage(frame) {\n    // mesasge~2\n    return bufrw.str2.readFrom(frame.buffer, ErrorResponse.RW.lazy.mesasgeOffset);\n};\n\nmodule.exports = ErrorResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint max-statements: [1, 40] max-params: [1, 11] */\n/* eslint-disable curly */\n\nvar EventEmitter = require('../lib/event_emitter');\nvar Buffer = require('buffer').Buffer;\nvar stat = require('../stat-tags.js');\nvar util = require('util');\nvar assert = require('assert');\nvar process = require('process');\n\nvar HostPort = require('../host-port.js');\nvar OutRequest = require('./out_request').OutRequest;\nvar OutResponse = require('./out_response').OutResponse;\nvar StreamingOutRequest = require('./out_request').StreamingOutRequest;\nvar StreamingOutResponse = require('./out_response').StreamingOutResponse;\nvar InRequest = require('../in_request');\nvar InResponse = require('../in_response');\nvar States = require('../reqres_states');\nvar StreamingInRequest = require('../streaming_in_request');\nvar StreamingInResponse = require('../streaming_in_response');\n\nvar WriteResult = require('bufrw').WriteResult;\n\nvar v2 = require('./index');\nvar errors = require('../errors');\n\nvar TCHANNEL_LANGUAGE = 'node';\nvar TCHANNEL_LANGUAGE_VERSION = process.version.slice(1);\nvar TCHANNEL_VERSION = require('../package.json').version;\n\nvar SERVER_TIMEOUT_DEFAULT = 100;\nvar GLOBAL_WRITE_BUFFER = new Buffer(v2.Frame.MaxSize);\n\nmodule.exports = TChannelV2Handler;\n\nfunction TChannelV2Handler(options) {\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.errorFrameEvent = this.defineEvent('errorFrame');\n    this.callIncomingErrorFrameEvent = this.defineEvent('callIncomingErrorFrame');\n    this.callIncomingRequestEvent = this.defineEvent('callIncomingRequest');\n    this.callIncomingResponseEvent = this.defineEvent('callIncomingResponse');\n    this.cancelEvent = this.defineEvent('cancel');\n    this.initRequestEvent = this.defineEvent('initRequest');\n    this.initResponseEvent = this.defineEvent('initResponse');\n    this.claimEvent = this.defineEvent('claim');\n    this.pingIncomingRequestEvent = this.defineEvent('pingIncomingRequest');\n    this.pingIncomingResponseEvent = this.defineEvent('pingIncomingResponse');\n    this.writeErrorEvent = this.defineEvent('writeError'); // TODO: could use default throw behavior\n\n    this.options = options || {};\n    this.logger = this.options.logger;\n    this.random = this.options.random;\n    this.timers = this.options.timers;\n    this.tracer = this.options.tracer;\n    this.hostPort = this.options.hostPort;\n    this.processName = this.options.processName;\n    this.connection = this.options.connection;\n    this.remoteName = null; // filled in by identify message\n    this.lastSentFrameId = 0;\n    // TODO: GC these... maybe that's up to TChannel itself wrt ops\n    this.streamingReq = Object.create(null);\n    this.streamingRes = Object.create(null);\n\n    this.handleCallLazily = this.options.handleCallLazily || null;\n    this.handleFrame = this.handleEagerFrame;\n\n    this.requireAs = this.options.requireAs === false ? false : true;\n    this.requireCn = this.options.requireCn === false ? false : true;\n\n    var self = this;\n    this.boundOnReqError = onReqError;\n    this.boundOnResError = onResError;\n\n    function onReqError(err, req) {\n        self.onReqError(err, req);\n    }\n\n    function onResError(err, res) {\n        self.onResError(err, res);\n    }\n}\n\nutil.inherits(TChannelV2Handler, EventEmitter);\n\nTChannelV2Handler.prototype.justExtendLogInfo = function extendLogInfo(info) {\n    info.handlerLastSentFrameId = this.lastSentFrameId;\n    info.handlerIsLazy = this.handleFrame === this.handleLazyFrame;\n    info.canHandleLazyCalls = !!this.handleCallLazily;\n    info.handlerRequireAs = this.requireAs;\n    info.handlerRequireCn = this.requireCn;\n    return info;\n};\n\nTChannelV2Handler.prototype.extendLogInfo = function extendLogInfo(info) {\n    info = this.justExtendLogInfo(info);\n\n    // adds remoteName, hostPort, remoteAddr, etc\n    info = this.connection.extendLogInfo(info);\n\n    return info;\n};\n\nTChannelV2Handler.prototype.write = function write() {\n    this.errorEvent.emit(this, new Error('write not implemented'));\n};\n\nTChannelV2Handler.prototype.writeCopy = function writeCopy(buffer, start, end) {\n    // TODO: Optimize, allocating SlowBuffer here is slow\n    var copy = new Buffer(end - start);\n    buffer.copy(copy, 0, start, end);\n    this.write(copy);\n};\n\nvar writeRes = new WriteResult();\nTChannelV2Handler.prototype.pushFrame = function pushFrame(frame) {\n    var writeBuffer = GLOBAL_WRITE_BUFFER;\n    var res = v2.Frame.RW.poolWriteInto(writeRes, frame, writeBuffer, 0);\n    var err = res.err;\n    if (err) {\n        if (!Buffer.isBuffer(err.buffer)) {\n            var bufCopy = new Buffer(res.offset);\n            writeBuffer.copy(bufCopy, 0, 0, res.offset);\n            err.buffer = bufCopy;\n        }\n        if (typeof err.offset !== 'number') err.offset = res.offset;\n        this.writeErrorEvent.emit(this, err);\n    } else {\n        this.writeCopy(writeBuffer, 0, res.offset);\n    }\n};\n\nTChannelV2Handler.prototype.nextFrameId = function nextFrameId() {\n    this.lastSentFrameId = (this.lastSentFrameId + 1) % v2.Frame.MaxId;\n    return this.lastSentFrameId;\n};\n\nTChannelV2Handler.prototype.useLazyFrames = function useLazyFrames(enabled) {\n    if (enabled) {\n        this.handleFrame = this.handleLazyFrame;\n    } else {\n        this.handleFrame = this.handleEagerFrame;\n    }\n};\n\nTChannelV2Handler.prototype.handleLazyFrame = function handleLazyFrame(frame) {\n    frame.start = Date.now();\n\n    switch (frame.type) {\n        // TODO: make some lazy type handlers?\n        // case v2.Types.InitRequest:\n        // case v2.Types.InitResponse:\n        // case v2.Types.Cancel:\n        // case v2.Types.Claim:\n        // case v2.Types.PingRequest:\n        // case v2.Types.PingResponse:\n\n        case v2.Types.CallRequest:\n        case v2.Types.CallResponse:\n        case v2.Types.CallRequestCont:\n        case v2.Types.CallResponseCont:\n        case v2.Types.ErrorResponse:\n            if (this.handleCallLazily && this.handleCallLazily(frame)) {\n                return;\n            }\n            break;\n        default:\n            break;\n    }\n\n    var res = frame.readBody();\n    if (res.err) {\n        this.errorEvent.emit(this, res.err);\n        return;\n    }\n\n    this.handleEagerFrame(frame);\n};\n\n/* eslint-disable complexity */\nTChannelV2Handler.prototype.handleEagerFrame = function handleEagerFrame(frame) {\n    switch (frame.body.type) {\n        case v2.Types.InitRequest:\n            return this.handleInitRequest(frame);\n        case v2.Types.InitResponse:\n            return this.handleInitResponse(frame);\n        case v2.Types.CallRequest:\n            return this.handleCallRequest(frame);\n        case v2.Types.CallResponse:\n            return this.handleCallResponse(frame);\n        case v2.Types.Cancel:\n            return this.handleCancel(frame);\n        case v2.Types.CallRequestCont:\n            return this.handleCallRequestCont(frame);\n        case v2.Types.CallResponseCont:\n            return this.handleCallResponseCont(frame);\n        case v2.Types.Claim:\n            return this.handleClaim(frame);\n        case v2.Types.PingRequest:\n            return this.handlePingRequest(frame);\n        case v2.Types.PingResponse:\n            return this.handlePingResponse(frame);\n        case v2.Types.ErrorResponse:\n            return this.handleError(frame);\n        default:\n            return this.errorEvent.emit(this, errors.TChannelUnhandledFrameTypeError({\n                typeCode: frame.body.type\n            }));\n    }\n};\n/* eslint-enable complexity */\n\nTChannelV2Handler.prototype.handleInitRequest = function handleInitRequest(reqFrame) {\n    if (this.remoteName !== null) {\n        return this.errorEvent.emit(this, errors.DuplicateInitRequestError());\n    }\n    var headers = reqFrame.body.headers;\n    var init = {\n        hostPort: headers.host_port,\n        processName: headers.process_name,\n        tchannelLanguage: headers.tchannel_language,\n        tchannelLanguageVersion: headers.tchannel_language_version,\n        tchannelVersion: headers.tchannel_version\n    };\n\n    var reason = HostPort.validateHostPort(init.hostPort, true);\n    if (reason) {\n        return this.errorEvent.emit(this, errors.InvalidInitHostPortError({\n            hostPort: init.hostPort,\n            reason: reason\n        }));\n    }\n\n    this.sendInitResponse(reqFrame);\n    this.remoteName = init.hostPort;\n    this.initRequestEvent.emit(this, init);\n};\n\nTChannelV2Handler.prototype.handleInitResponse = function handleInitResponse(resFrame) {\n    if (this.remoteName !== null) {\n        return this.errorEvent.emit(this, errors.DuplicateInitResponseError());\n    }\n    var headers = resFrame.body.headers;\n    var init = {\n        hostPort: headers.host_port,\n        processName: headers.process_name,\n        tchannelLanguage: headers.tchannel_language,\n        tchannelLanguageVersion: headers.tchannel_language_version,\n        tchannelVersion: headers.tchannel_version\n    };\n    this.remoteName = init.hostPort;\n    this.initResponseEvent.emit(this, init);\n};\n\nTChannelV2Handler.prototype.handleCallRequest = function handleCallRequest(reqFrame) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.CallReqBeforeInitReqError());\n        return;\n    }\n\n    var req = this.buildInRequest(reqFrame);\n\n    var err = this.checkCallReqFrame(reqFrame);\n    if (err) {\n        req.errorEvent.emit(req, err);\n        return;\n    }\n\n    if (this._handleCallFrame(req, reqFrame, this.streamingReq)) {\n        this.callIncomingRequestEvent.emit(this, req);\n    }\n\n    var channel = this.connection.channel;\n    channel.emitFastStat(\n        'tchannel.inbound.request.size',\n        'counter',\n        reqFrame.size,\n        new stat.InboundRequestSizeTags(\n            req.callerName,\n            req.serviceName,\n            req.endpoint\n        )\n    );\n\n    this.emitBytesRecvd(reqFrame);\n};\n\nTChannelV2Handler.prototype.emitBytesRecvd =\nfunction emitBytesRecvd(frame) {\n    var channel = this.connection.channel;\n    if (channel.emitConnectionMetrics) {\n        channel.emitFastStat(\n            'tchannel.connections.bytes-recvd',\n            'counter',\n            frame.size,\n            new stat.ConnectionsBytesRcvdTags(\n                channel.hostPort || '0.0.0.0:0',\n                this.connection.socketRemoteAddr\n            )\n        );\n    }\n};\n\nTChannelV2Handler.prototype.checkCallResFrame = function checkCallResFrame(resFrame) {\n    if (!resFrame.body ||\n        !resFrame.body.headers ||\n        !resFrame.body.headers.as\n    ) {\n        if (this.requireAs) {\n            return errors.InAsHeaderRequired({\n                frame: 'response'\n            });\n        } else {\n            this.logger.warn('Expected \"as\" for incoming response', this.extendLogInfo({\n                code: resFrame.body.code,\n                endpoint: String(resFrame.body.args[0])\n            }));\n        }\n    }\n\n    return this.checkCallFrameArgs(resFrame);\n};\n\nTChannelV2Handler.prototype.checkCallReqFrame = function checkCallReqFrame(reqFrame) {\n    if (!reqFrame.body ||\n        !reqFrame.body.headers ||\n        !reqFrame.body.headers.as\n    ) {\n        if (this.requireAs) {\n            return errors.InAsHeaderRequired({\n                frame: 'request'\n            });\n        } else {\n            this.logger.warn('Expected \"as\" header for incoming req', this.extendLogInfo({\n                arg1: String(reqFrame.body.args[0]),\n                serviceName: reqFrame.body.service,\n                callerName: reqFrame.body.headers.cn\n            }));\n        }\n    }\n\n    if (!reqFrame.body ||\n        !reqFrame.body.headers ||\n        !reqFrame.body.headers.cn\n    ) {\n        if (this.requireCn) {\n            return errors.InCnHeaderRequired();\n        } else {\n            this.logger.warn('Expected \"cn\" header for incoming req', this.extendLogInfo({\n                arg1: String(reqFrame.body.args[0]),\n                serviceName: reqFrame.body.service\n            }));\n        }\n    }\n\n    return this.checkCallFrameArgs(reqFrame);\n};\n\nTChannelV2Handler.prototype.checkCallFrameArgs = function checkCallFrameArgs(frame) {\n    if (frame.body.args &&\n        frame.body.args[0] &&\n        frame.body.args[0].length > v2.MaxArg1Size\n    ) {\n        return errors.Arg1OverLengthLimit({\n            length: frame.body.args[0].length,\n            limit: v2.MaxArg1Size\n        });\n    }\n\n    return null;\n};\n\nTChannelV2Handler.prototype.handleCallResponse = function handleCallResponse(resFrame) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.CallResBeforeInitResError());\n        return;\n    }\n\n    var res = this.buildInResponse(resFrame);\n\n    var err = this.checkCallResFrame(resFrame);\n    if (err) {\n        res.errorEvent.emit(res, err);\n        return;\n    }\n\n    var req = this.connection.ops.getOutReq(res.id);\n\n    var channel = this.connection.channel;\n\n    channel.emitFastStat(\n        'tchannel.inbound.response.size',\n        'counter',\n        resFrame.size,\n        new stat.InboundResponseSizeTags(\n            req ? req.callerName : '',\n            req ? req.serviceName : '',\n            req ? req.endpoint : ''\n        )\n    );\n\n    this.emitBytesRecvd(resFrame);\n\n    res.remoteAddr = this.remoteName;\n    if (this._handleCallFrame(res, resFrame, this.streamingRes)) {\n        this.callIncomingResponseEvent.emit(this, res);\n    }\n};\n\n// TODO  we should implement clearing of this.streaming{Req,Res}\nTChannelV2Handler.prototype.handleCancel = function handleCancel(frame) {\n    this.cancelEvent.emit(this, frame);\n};\n\nTChannelV2Handler.prototype.handleCallRequestCont = function handleCallRequestCont(reqFrame, callback) {\n    if (this.remoteName === null) {\n        return this.errorEvent.emit(this, errors.CallReqContBeforeInitReqError());\n    }\n    var id = reqFrame.id;\n    var req = this.streamingReq[id];\n    if (!req) {\n        // TODO: maybe we should send an error frame directed at the missing\n        // request id?  Currently the handler -> connection boundary only\n        // supports \"close them all\" error handling.  If instead we added an\n        // option for errors classified as 'BadRequest' to resolve through\n        // something like `var refId = errors.badRequestRefId(err); if (refId\n        // !== undefined) ...` then we could support it.\n        return this.errorEvent.emit(this, errors.OrphanCallRequestCont({\n            frameId: id\n        }));\n    }\n\n    this._handleCallFrame(req, reqFrame, this.streamingReq);\n\n    var channel = this.connection.channel;\n    channel.emitFastStat(\n        'tchannel.inbound.request.size',\n        'counter',\n        reqFrame.size,\n        new stat.InboundRequestSizeTags(\n            req.callerName,\n            req.serviceName,\n            req.endpoint\n        )\n    );\n\n    this.emitBytesRecvd(reqFrame);\n};\n\nTChannelV2Handler.prototype.handleCallResponseCont = function handleCallResponseCont(resFrame) {\n    if (this.remoteName === null) {\n        return this.errorEvent.emit(this, errors.CallResContBeforeInitResError());\n    }\n    var id = resFrame.id;\n    var res = this.streamingRes[id];\n    if (!res) {\n        // TODO: see note in #handleCallRequestCont\n        return this.errorEvent.emit(this, errors.OrphanCallResponseCont({\n            frameId: id\n        }));\n    }\n\n    var req = this.connection.ops.getOutReq(res.id);\n    var channel = this.connection.channel;\n\n    channel.emitFastStat(\n        'tchannel.inbound.response.size',\n        'counter',\n        resFrame.size,\n        new stat.InboundResponseSizeTags(\n            req ? req.callerName : '',\n            req ? req.serviceName : '',\n            req ? req.endpoint : ''\n        )\n    );\n\n    this.emitBytesRecvd(resFrame);\n\n    this._handleCallFrame(res, resFrame, this.streamingRes);\n};\n\nTChannelV2Handler.prototype.handleClaim = function handleClaim(frame) {\n    this.claimEvent.emit(this, frame);\n};\n\nTChannelV2Handler.prototype.handlePingRequest = function handlePingRequest(pingFrame) {\n    this.pingIncomingRequestEvent.emit(this, pingFrame);\n    this.sendPingReponse(pingFrame);\n};\n\nTChannelV2Handler.prototype.handlePingResponse = function handlePingResponse(pingFrame) {\n    this.pingIncomingResponseEvent.emit(this, pingFrame);\n};\n\nTChannelV2Handler.prototype.handleError = function handleError(errFrame, callback) {\n    if (errFrame.id === v2.Frame.NullId) {\n        // error frame not associated with a prior frame\n        this.errorFrameEvent.emit(this, errFrame);\n        return;\n    }\n\n    delete this.streamingReq[errFrame.id];\n    delete this.streamingRes[errFrame.id];\n    this.callIncomingErrorFrameEvent.emit(this, errFrame);\n};\n\nTChannelV2Handler.prototype._checkCallFrame = function _checkCallFrame(r, frame) {\n    // TODO: this obsoletes similar checks in StreamingIn{Request,Response}#handleFrame\n    if (r.state === States.Done) {\n        return errors.UnexpectedCallFrameAfterDone({\n            frameId: frame.id,\n            frameType: frame.body.type\n        });\n    } else if (r.state === States.Error) {\n        return errors.UnexpectedCallFrameAfterError({\n            frameId: frame.id,\n            frameType: frame.body.type\n        });\n    }\n\n    var checksum = r.checksum;\n    if (checksum.type !== frame.body.csum.type) {\n        return errors.ChecksumTypeChanged({\n            initialChecksumType: checksum.type,\n            newChecksumType: frame.body.csum.type\n        });\n    }\n\n    return frame.body.verifyChecksum(checksum.val);\n};\n\nTChannelV2Handler.prototype._handleCallFrame = function _handleCallFrame(r, frame, streamingColl) {\n    var isLast = true;\n    var err = this._checkCallFrame(r, frame);\n\n    if (!err) {\n        // TODO: refactor r.handleFrame to just take the whole frame? or should\n        // it be (checksum, args)\n        isLast = !(frame.body.flags & v2.CallFlags.Fragment);\n        r.checksum = frame.body.csum;\n        err = r.handleFrame(frame.body.args, isLast);\n    }\n\n    if (err) {\n        // TODO wrap context\n        r.errorEvent.emit(r, err);\n        delete streamingColl[r.id];\n        return false;\n    }\n\n    if (isLast) {\n        delete streamingColl[r.id];\n    } else if (!streamingColl[r.id]) {\n        streamingColl[r.id] = r;\n    } else {\n        assert(streamingColl[r.id] === r);\n    }\n\n    return true;\n};\n\nTChannelV2Handler.prototype.sendInitRequest = function sendInitRequest() {\n    var id = this.nextFrameId(); // TODO: assert(id === 1)?\n    var hostPort = this.hostPort || '0.0.0.0:0';\n    var processName = this.processName;\n    /* eslint-disable camelcase */\n    var body = new v2.InitRequest(v2.VERSION, {\n        host_port: hostPort,\n        process_name: processName,\n        tchannel_language: TCHANNEL_LANGUAGE,\n        tchannel_language_version: TCHANNEL_LANGUAGE_VERSION,\n        tchannel_version: TCHANNEL_VERSION\n    });\n    /* eslint-enable camelcase */\n    var reqFrame = new v2.Frame(id, body);\n    this.pushFrame(reqFrame);\n};\n\nTChannelV2Handler.prototype.sendInitResponse = function sendInitResponse(reqFrame) {\n    var id = reqFrame.id;\n    var hostPort = this.hostPort;\n    var processName = this.processName;\n    /* eslint-disable camelcase */\n    var body = new v2.InitResponse(v2.VERSION, {\n        host_port: hostPort,\n        process_name: processName,\n        tchannel_language: TCHANNEL_LANGUAGE,\n        tchannel_language_version: TCHANNEL_LANGUAGE_VERSION,\n        tchannel_version: TCHANNEL_VERSION\n    });\n    /* eslint-enable camelcase */\n    var resFrame = new v2.Frame(id, body);\n    this.pushFrame(resFrame);\n};\n\nTChannelV2Handler.prototype.sendCallRequestFrame =\nfunction sendCallRequestFrame(req, flags, args) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.SendCallReqBeforeIdentifiedError());\n        return null;\n    }\n\n    var err = this.verifyCallRequestFrame(req, args);\n    if (err) {\n        return err;\n    }\n\n    var reqBody = new v2.CallRequest(\n        flags, req.timeout, req.tracing, req.serviceName, req.headers,\n        req.checksum.type, args\n    );\n    req.checksum = this.sendCallBodies(\n        req.id, reqBody, null,\n        'tchannel.outbound.request.size', new stat.OutboundRequestSizeTags(\n            req.serviceName,\n            req.callerName,\n            req.endpoint\n        ));\n\n    return null;\n};\n\nTChannelV2Handler.prototype.emitBytesSent =\nfunction emitBytesSent(size) {\n    var channel = this.connection.channel;\n    if (channel.emitConnectionMetrics) {\n        channel.emitFastStat(\n            'tchannel.connections.bytes-sent',\n            'counter',\n            size,\n            new stat.ConnectionsBytesSentTags(\n                channel.hostPort || '0.0.0.0:0',\n                this.connection.socketRemoteAddr\n            )\n        );\n    }\n};\n\nTChannelV2Handler.prototype.verifyCallRequestFrame =\nfunction verifyCallRequestFrame(req, args) {\n    if (!req.headers || !req.headers.as) {\n        if (this.requireAs) {\n            return errors.OutAsHeaderRequired();\n        } else {\n            this.logger.error('Expected \"as\" header to be set for request', this.justExtendLogInfo(req.extendLogInfo({\n            })));\n        }\n    }\n\n    if (!req.callerName) {\n        if (this.requireCn) {\n            return errors.OutCnHeaderRequired();\n        } else {\n            this.logger.error('Expected \"cn\" header to be set for request', this.justExtendLogInfo(req.extendLogInfo({\n            })));\n        }\n    }\n\n    return null;\n};\n\nTChannelV2Handler.prototype.sendCallResponseFrame =\nfunction sendCallResponseFrame(res, flags, args) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.SendCallResBeforeIdentifiedError());\n        return null;\n    }\n\n    var err = this.validateCallResponseFrame(res);\n    if (err) {\n        return err;\n    }\n\n    var req = res.inreq;\n    var resBody = new v2.CallResponse(\n        flags, res.code, res.tracing, res.headers,\n        res.checksum.type, args);\n    res.checksum = this.sendCallBodies(\n        res.id, resBody, null,\n        'tchannel.outbound.response.size', new stat.OutboundResponseSizeTags(\n            req.serviceName,\n            req.callerName,\n            req.endpoint\n        ));\n};\n\nTChannelV2Handler.prototype.validateCallResponseFrame =\nfunction validateCallResponseFrame(res) {\n    if (this.requireAs) {\n        // TODO: consider returning typed error like for req frame validate\n        assert(res.headers && res.headers.as,\n            'Expected the \"as\" transport header to be set for response');\n    } else if (!res.headers || !res.headers.as) {\n        this.logger.error('Expected \"as\" header to be set for response', this.justExtendLogInfo(res.extendLogInfo({\n        })));\n    }\n\n    return null;\n};\n\nTChannelV2Handler.prototype.sendCallRequestContFrame = function sendCallRequestContFrame(req, flags, args) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.SendCallReqContBeforeIdentifiedError());\n        return;\n    }\n\n    var reqBody = new v2.CallRequestCont(flags, req.checksum.type, args);\n    req.checksum = this.sendCallBodies(\n        req.id, reqBody, req.checksum,\n        'tchannel.outbound.request.size', new stat.OutboundRequestSizeTags(\n            req ? req.serviceName : '',\n            req ? req.callerName : '',\n            req ? req.endpoint : ''\n        ));\n};\n\nTChannelV2Handler.prototype.sendCallResponseContFrame = function sendCallResponseContFrame(res, flags, args) {\n    if (this.remoteName === null) {\n        this.errorEvent.emit(this, errors.SendCallResContBeforeIdentifiedError());\n        return;\n    }\n\n    var req = res.inreq;\n    var resBody = new v2.CallResponseCont(flags, res.checksum.type, args);\n    res.checksum = this.sendCallBodies(\n        res.id, resBody, res.checksum,\n        'tchannel.outbound.response.size', new stat.OutboundResponseSizeTags(\n            req.serviceName,\n            req.callerName,\n            req.endpoint\n        ));\n};\n\nTChannelV2Handler.prototype.sendCallBodies =\nfunction sendCallBodies(id, body, checksum, chanStat, tags) {\n    var channel = this.connection.channel;\n    var frame;\n\n    var size = 0;\n    /* eslint-disable no-cond-assign */\n    do {\n        if (checksum) {\n            body.csum = checksum;\n        }\n\n        frame = new v2.Frame(id, body);\n        this.pushFrame(frame);\n        size += frame.size;\n        checksum = body.csum;\n    } while (body = body.cont);\n    /* eslint-enable no-cond-assign */\n\n    if (chanStat) {\n        channel.emitFastStat(chanStat, 'counter', size, tags);\n    }\n    this.emitBytesSent(size);\n\n    return checksum;\n};\n\nTChannelV2Handler.prototype.sendPingRequest = function sendPingRequest() {\n    var id = this.nextFrameId();\n    var body = new v2.PingRequest();\n    var reqFrame = new v2.Frame(id, body);\n    this.pushFrame(reqFrame);\n    return id;\n};\n\nTChannelV2Handler.prototype.sendPingReponse = function sendPingReponse(res) {\n    var body = new v2.PingResponse();\n    var resFrame = new v2.Frame(res.id, body);\n    this.pushFrame(resFrame);\n};\n\nTChannelV2Handler.prototype.sendErrorFrame = function sendErrorFrame(id, tracing, codeString, message) {\n    var code = v2.ErrorResponse.Codes[codeString];\n    if (code === undefined) {\n        this.logger.error('invalid error frame code string', this.extendLogInfo({\n            codeString: codeString\n        }));\n        code = v2.ErrorResponse.Codes.UnexpectedError;\n        message = 'UNKNOWN CODE(' + codeString + '): ' + message;\n    }\n    var errBody = new v2.ErrorResponse(code, tracing, message);\n    var errFrame = new v2.Frame(id, errBody);\n    this.pushFrame(errFrame);\n};\n\nTChannelV2Handler.prototype.buildOutRequest = function buildOutRequest(options) {\n    var id = this.nextFrameId();\n\n    if (options.checksumType === null) {\n        options.checksumType = v2.Checksum.Types.CRC32C;\n    }\n    if (!options.checksum) {\n        options.checksum = new v2.Checksum(options.checksumType);\n    }\n    if (!options.headers.re) {\n        options.headers.re = v2.encodeRetryFlags(options.retryFlags);\n    }\n\n    if (options.streamed) {\n        return new StreamingOutRequest(this, id, options);\n    } else {\n        return new OutRequest(this, id, options);\n    }\n};\n\nTChannelV2Handler.prototype.buildOutResponse = function buildOutResponse(req, options) {\n    if (!options) options = {};\n\n    options.inreq = req;\n    options.channel = req.channel;\n    options.logger = this.logger;\n    options.random = this.random;\n    options.timers = this.timers;\n\n    options.tracing = req.tracing;\n    options.span = req.span;\n    options.checksumType = req.checksum.type;\n    if (!options.checksum) {\n        options.checksum = new v2.Checksum(req.checksum.type);\n    }\n    if (options.streamed) {\n        return new StreamingOutResponse(this, req.id, options);\n    } else {\n        return new OutResponse(this, req.id, options);\n    }\n};\n\nTChannelV2Handler.prototype.buildInRequest = function buildInRequest(reqFrame) {\n    var opts = new InRequestOptions(\n        this.connection.channel,\n        reqFrame.body.ttl || SERVER_TIMEOUT_DEFAULT,\n        reqFrame.body.tracing,\n        reqFrame.body.service,\n        reqFrame.body.headers,\n        new v2.Checksum(reqFrame.body.csum.type),\n        v2.parseRetryFlags(reqFrame.body.headers.re),\n        this.connection,\n        this.hostPort,\n        this.tracer,\n        reqFrame.body.flags\n    );\n\n    var req;\n    if (reqFrame.body.flags & v2.CallFlags.Fragment) {\n        req = new StreamingInRequest(reqFrame.id, opts);\n    } else {\n        req = new InRequest(reqFrame.id, opts);\n    }\n\n    req.errorEvent.on(this.boundOnReqError);\n\n    return req;\n};\n\nTChannelV2Handler.prototype.onReqError = function onReqError(err, req) {\n    var codeName = errors.classify(err);\n    if (codeName &&\n        codeName !== 'ProtocolError'\n    ) {\n        // TODO: move req to error state?\n        if (!req.res) {\n            req.res = this.buildOutResponse(req);\n        }\n        req.res.sendError(codeName, err.message);\n    } else {\n        this.errorEvent.emit(this, err);\n    }\n};\n\nTChannelV2Handler.prototype.onResError = function onResError(err, res) {\n    // TODO: wrap errors to clarify \"errors on responses to req...\" ?\n    var req = this.connection.ops.getOutReq(res.id);\n    req.errorEvent.emit(req, err);\n};\n\nTChannelV2Handler.prototype.buildInResponse = function buildInResponse(resFrame) {\n    var opts = {\n        logger: this.logger,\n        random: this.random,\n        timers: this.timers,\n        code: resFrame.body.code,\n        checksum: new v2.Checksum(resFrame.body.csum.type),\n        streamed: resFrame.body.flags & v2.CallFlags.Fragment,\n        flags: resFrame.body.flags,\n        headers: resFrame.body.headers\n    };\n\n    var res;\n    if (opts.streamed) {\n        res = new StreamingInResponse(resFrame.id, opts);\n    } else {\n        res = new InResponse(resFrame.id, opts);\n    }\n\n    res.errorEvent.on(this.boundOnResError);\n\n    return res;\n};\n\nfunction InRequestOptions(\n    channel, timeout, tracing, serviceName, headers, checksum,\n    retryFlags, connection, hostPort, tracer, flags\n) {\n    this.channel = channel;\n    this.timeout = timeout;\n    this.tracing = tracing;\n    this.serviceName = serviceName;\n    this.headers = headers;\n    this.checksum = checksum;\n    this.retryFlags = retryFlags;\n    this.connection = connection;\n    this.hostPort = hostPort;\n    this.tracer = tracer;\n    this.flags = flags;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/out_request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\n\nvar OutRequest = require('../out_request');\nvar StreamingOutRequest = require('../streaming_out_request');\n\nvar CallFlags = require('./call_flags');\nvar v2 = require('./index');\nvar errors = require('../errors');\n\nfunction V2OutRequest(handler, id, options) {\n    OutRequest.call(this, id, options);\n    this.handler = handler;\n}\n\ninherits(V2OutRequest, OutRequest);\n\nfunction V2StreamingOutRequest(handler, id, options) {\n    StreamingOutRequest.call(this, id, options);\n    this.handler = handler;\n}\n\ninherits(V2StreamingOutRequest, StreamingOutRequest);\n\nV2OutRequest.prototype._sendCallRequest =\nV2StreamingOutRequest.prototype._sendCallRequest =\nfunction _sendCallRequest(args, isLast) {\n    var err = null;\n\n    var flags = 0;\n    if (!isLast) {\n        flags |= CallFlags.Fragment;\n    }\n\n    if (args && args[0] && args[0].length > v2.MaxArg1Size) {\n        err = errors.Arg1OverLengthLimit({\n            length: args[0].length,\n            limit: v2.MaxArg1Size\n        });\n    } else {\n        err = this.handler.sendCallRequestFrame(this, flags, args);\n    }\n\n    if (err) {\n        this.operations.popOutReq(this.id);\n        this.emitError(err);\n    }\n};\n\nV2OutRequest.prototype._sendCallRequestCont =\nV2StreamingOutRequest.prototype._sendCallRequestCont =\nfunction _sendCallRequestCont(args, isLast) {\n    var flags = 0;\n    if (!isLast) {\n        flags |= CallFlags.Fragment;\n    }\n\n    this.handler.sendCallRequestContFrame(this, flags, args);\n};\n\nmodule.exports.OutRequest = V2OutRequest;\nmodule.exports.StreamingOutRequest = V2StreamingOutRequest;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/out_request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = TChannelOutRequest;\n\nvar assert = require('assert');\nvar EventEmitter = require('./lib/event_emitter');\nvar stat = require('./stat-tags.js');\nvar inherits = require('util').inherits;\nvar parallel = require('run-parallel');\nvar process = require('process');\n\nvar errors = require('./errors');\nvar States = require('./reqres_states');\n\nfunction TChannelOutRequest(id, options) {\n    /*eslint max-statements: [2, 50], complexity: [2, 25]*/\n\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.responseEvent = this.defineEvent('response');\n    this.finishEvent = this.defineEvent('finish');\n\n    // TODO perhaps these ought not be options\n    assert(options.channel, 'channel required');\n    assert(options.peer, 'peer required');\n    assert(id, 'id is required');\n\n    this.retryCount = options.retryCount || 0;\n    this.channel = options.channel;\n    this.peer = options.peer;\n    this.logical = options.logical || false;\n    this.parent = options.parent || null;\n    this.hasNoParent = options.hasNoParent || false;\n\n    this.remoteAddr = options.remoteAddr || '';\n    this.timeout = options.timeout || 0;\n    this.tracing = options.tracing || null;\n    this.serviceName = options.serviceName || '';\n    this.callerName = options.headers && options.headers.cn || '';\n    this.headers = options.headers || {};\n    this.checksumType = options.checksumType || 0;\n    this.checksum = options.checksum || null;\n    this.forwardTrace = options.forwardTrace || false;\n\n    // All self requests have id 0\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.id = id;\n    this.state = States.Initial;\n    this.start = 0;\n    this.end = 0;\n    this.streamed = false;\n    this.arg1 = null;\n    this.endpoint = '';\n    this.span = null;\n    this.err = null;\n    this.res = null;\n\n    // set for requests created on draining connections\n    this.drained = false;\n    this.drainReason = '';\n\n    if (options.channel.tracer && !this.forwardTrace) {\n        // new span with new ids\n        this.setupTracing(options);\n    }\n}\n\ninherits(TChannelOutRequest, EventEmitter);\n\nTChannelOutRequest.prototype.type = 'tchannel.outgoing-request';\n\nTChannelOutRequest.prototype.setupTracing = function setupTracing(options) {\n    var self = this;\n\n    self.span = options.channel.tracer.setupNewSpan({\n        outgoing: true,\n        parentSpan: options.parent && options.parent.span,\n        hasNoParent: options.hasNoParent,\n        spanid: null,\n        traceid: null,\n        parentid: null,\n        flags: options.trace ? 1 : 0,\n        remoteName: self.remoteAddr,\n        serviceName: self.serviceName,\n        name: '' // fill this in later\n    });\n\n    self.tracing = self.span.getTracing();\n};\n\nTChannelOutRequest.prototype._sendCallRequest = function _sendCallRequest(args, isLast) {\n    var self = this;\n    throw errors.UnimplementedMethod({\n        className: self.constructor.name,\n        methodName: '_sendCallRequest'\n    });\n};\n\nTChannelOutRequest.prototype._sendCallRequestCont = function _sendCallRequestCont(args, isLast) {\n    var self = this;\n    throw errors.UnimplementedMethod({\n        className: self.constructor.name,\n        methodName: '_sendCallRequestCont'\n    });\n};\n\nTChannelOutRequest.prototype.emitPerAttemptErrorStat =\nfunction emitPerAttemptErrorStat(err) {\n    var self = this;\n\n    if (err.isErrorFrame) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.per-attempt.system-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsSystemErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                err.codeName,\n                self.retryCount\n            )\n        );\n    } else {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.per-attempt.operational-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsPerAttemptOperationalErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                err.type || 'unknown',\n                self.retryCounts\n            )\n        );\n    }\n};\n\nTChannelOutRequest.prototype.emitPerAttemptResponseStat =\nfunction emitPerAttemptResponseStat(res) {\n    var self = this;\n\n    if (!res.ok) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.per-attempt.app-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsPerAttemptAppErrorsTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint,\n                'unknown',\n                self.retryCount\n            )\n        );\n    // Only emit success if peer-to-peer request or relay\n    } else if (self.logical === false) {\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.success',\n            'counter',\n            1,\n            new stat.OutboundCallsSuccessTags(\n                self.serviceName,\n                self.callerName,\n                self.endpoint\n            )\n        );\n    }\n};\n\nTChannelOutRequest.prototype.emitPerAttemptLatency =\nfunction emitPerAttemptLatency() {\n    var self = this;\n\n    var latency = self.end - self.start;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.per-attempt-latency',\n        'timing',\n        latency,\n        new stat.OutboundCallsPerAttemptLatencyTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint,\n            self.remoteAddr,\n            self.retryCount\n        )\n    );\n};\n\nTChannelOutRequest.prototype.emitError = function emitError(err) {\n    var self = this;\n\n    if (self.end) {\n        self.channel.logger.warn('Unexpected error after end for OutRequest', self.extendLogInfo({\n            hasOldResponse: !!self.res,\n            oldError: self.err,\n            error: err\n        }));\n    } else {\n        self.end = self.channel.timers.now();\n    }\n\n    self.err = err;\n    self.emitPerAttemptLatency();\n    self.emitPerAttemptErrorStat(err);\n\n    self.peer.invalidateScore('outreq.emitError');\n\n    self.errorEvent.emit(self, err);\n};\n\nTChannelOutRequest.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    info.outRequestId = self.id;\n    // TODO: .start / .end\n    info.outRequestType = self.type;\n    info.outRequestState = States.describe(self.state);\n    info.outRequestRemoteAddr = self.remoteAddr;\n    info.serviceName = self.serviceName;\n    info.callerName = self.callerName;\n    info.outRequestErr = self.err;\n\n    if (self.endpoint !== null) {\n        info.outRequestArg1 = self.endpoint;\n    } else {\n        info.outRequestArg1 = String(self.arg1);\n    }\n\n    // TODO: delegate to self.res.extendLogInfo ?\n    // TODO: add hasOldResponse: !!self.res ?\n\n    return info;\n};\n\nTChannelOutRequest.prototype.emitResponse = function emitResponse(res) {\n    var self = this;\n\n    self.res = res;\n    self.res.span = self.span;\n\n    if (!self.res.streamed) {\n        self.markEnd();\n    } else {\n        self.res.finishEvent.on(onFinished);\n    }\n\n    self.responseEvent.emit(self, self.res);\n\n    function onFinished() {\n        self.markEnd();\n    }\n};\n\nTChannelOutRequest.prototype.markEnd = function markEnd() {\n    var self = this;\n\n    self.peer.invalidateScore('outreq.emitResponse');\n\n    if (self.end) {\n        self.channel.logger.warn('Unexpected response after end for OutRequest', self.extendLogInfo({\n            hasOldResponse: !!self.res\n        }));\n    } else {\n        self.end = self.channel.timers.now();\n    }\n\n    self.emitPerAttemptLatency();\n    self.emitPerAttemptResponseStat(self.res);\n};\n\nTChannelOutRequest.prototype.sendParts = function sendParts(parts, isLast) {\n    var self = this;\n\n    if (self.drained) {\n        self.emitError(errors.RequestDrained({\n            reason: self.drainReason\n        }));\n        return;\n    }\n\n    switch (self.state) {\n        case States.Initial:\n            self.sendCallRequestFrame(parts, isLast);\n            break;\n        case States.Streaming:\n            self.sendCallRequestContFrame(parts, isLast);\n            break;\n        case States.Done:\n            // TODO: could probably happen normally, like say if a\n            // streaming request is cancelled\n            self.emitError(errors.RequestFrameState({\n                attempted: 'arg parts',\n                state: 'Done'\n            }));\n            break;\n        case States.Error:\n            // TODO: log warn\n            break;\n        default:\n            // TODO: log warn\n            break;\n    }\n};\n\nTChannelOutRequest.prototype.sendCallRequestFrame = function sendCallRequestFrame(args, isLast) {\n    var self = this;\n    switch (self.state) {\n        case States.Initial:\n            self.start = self.channel.timers.now();\n            if (self.span) {\n                self.span.annotate('cs');\n            }\n            self._sendCallRequest(args, isLast);\n            if (isLast) {\n                self.state = States.Done;\n            } else {\n                self.state = States.Streaming;\n            }\n            break;\n        case States.Streaming:\n            self.emitError(errors.RequestFrameState({\n                attempted: 'call request',\n                state: 'Streaming'\n            }));\n            break;\n        case States.Done:\n            self.emitError(errors.RequestAlreadyDone({\n                attempted: 'call request'\n            }));\n            break;\n        default:\n            // TODO: log warn\n            break;\n    }\n};\n\nTChannelOutRequest.prototype.sendCallRequestContFrame = function sendCallRequestContFrame(args, isLast) {\n    var self = this;\n    switch (self.state) {\n        case States.Initial:\n            self.emitError(errors.RequestFrameState({\n                attempted: 'call request continuation',\n                state: 'Initial'\n            }));\n            break;\n        case States.Streaming:\n            self._sendCallRequestCont(args, isLast);\n            if (isLast) {\n                self.state = States.Done;\n            }\n            break;\n        case States.Done:\n            self.emitError(errors.RequestAlreadyDone({\n                attempted: 'call request continuation'\n            }));\n            break;\n        default:\n            // TODO: log warn\n            break;\n    }\n};\n\nTChannelOutRequest.prototype.sendArg1 = function sendArg1(arg1) {\n    var self = this;\n\n    if (self.drained) {\n        self.emitError(errors.RequestDrained({\n            reason: self.drainReason\n        }));\n        return self;\n    }\n\n    self.arg1 = arg1;\n    self.endpoint = String(arg1);\n    if (self.span) {\n        self.span.name = self.endpoint;\n    }\n\n    return self;\n};\n\nTChannelOutRequest.prototype.send = function send(arg1, arg2, arg3, callback) {\n    var self = this;\n\n    if (callback) {\n        self.hookupCallback(callback);\n    }\n\n    if (self.drained) {\n        self.emitError(errors.RequestDrained({\n            reason: self.drainReason\n        }));\n        return self;\n    }\n\n    self.sendArg1(arg1);\n\n    if (self.span) {\n        self.span.annotateBinary('as', self.headers.as);\n        self.span.annotateBinary('cn', self.callerName);\n    }\n\n    if (self.logical === false && self.retryCount === 0) {\n        self.emitOutboundCallsSent();\n    }\n\n    self.sendCallRequestFrame([arg1, arg2, arg3], true);\n    self.finishEvent.emit(self);\n    return self;\n};\n\nTChannelOutRequest.prototype.emitOutboundCallsSent =\nfunction emitOutboundCallsSent() {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.sent',\n        'counter',\n        1,\n        new stat.OutboundCallsSentTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n};\n\nTChannelOutRequest.prototype.hookupStreamCallback =\nfunction hookupStreamCallback(callback) {\n    var self = this;\n    var called = false;\n\n    self.errorEvent.on(onError);\n    self.responseEvent.on(onResponse);\n\n    function onError(err) {\n        if (called) {\n            return;\n        }\n        called = true;\n        callback(err, null, null);\n    }\n\n    function onResponse(res) {\n        if (called) {\n            return;\n        }\n        called = true;\n        callback(null, self, res);\n    }\n\n    return self;\n};\n\nTChannelOutRequest.prototype.hookupCallback =\nfunction hookupCallback(callback) {\n    var self = this;\n\n    if (callback.canStream) {\n        return self.hookupStreamCallback(callback);\n    }\n    var called = false;\n\n    self.errorEvent.on(onError);\n    self.responseEvent.on(onResponse);\n\n    function onError(err) {\n        if (called) {\n            return;\n        }\n        called = true;\n        callback(err, null, null);\n    }\n\n    function onResponse(res) {\n        if (called) {\n            return;\n        }\n        called = true;\n        if (!res.streamed) {\n            callback(null, res, res.arg2, res.arg3);\n            return;\n        }\n        parallel({\n            arg2: res.arg2.onValueReady,\n            arg3: res.arg3.onValueReady\n        }, compatCall);\n        function compatCall(err, args) {\n            callback(err, res, args.arg2, args.arg3);\n        }\n    }\n\n    return self;\n};\n\nTChannelOutRequest.prototype.onTimeout = function onTimeout(now) {\n    var self = this;\n    var timeoutError;\n\n    if (self.err) {\n        self.channel.logger.warn('unexpected onTimeout for errored out request', self.extendLogInfo({\n            hasOldResponse: !!self.res,\n            timeoutTime: now\n        }));\n    }\n\n    if (!self.res || self.res.state === States.Initial ||\n        self.res.state === States.Streaming\n    ) {\n        timeoutError = errors.RequestTimeoutError({\n            id: self.id,\n            start: self.start,\n            elapsed: now - self.start,\n            logical: self.logical,\n            timeout: self.timeout,\n            remoteAddr: self.remoteAddr\n        });\n        if (self.operations) {\n            self.operations.checkLastTimeoutTime(now);\n            self.operations.popOutReq(self.id);\n        }\n\n        process.nextTick(deferOutReqTimeoutErrorEmit);\n    } else if (self.operations) {\n        self.operations.checkLastTimeoutTime(now);\n        self.operations.popOutReq(self.id);\n    }\n\n    function deferOutReqTimeoutErrorEmit() {\n        self.emitError(timeoutError);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/reqres_states.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports.Initial = 0;\nmodule.exports.Streaming = 1;\nmodule.exports.Done = 2;\nmodule.exports.Error = 3;\n\nmodule.exports.classify = function classify(state) {\n    switch (state) {\n        case module.exports.Initial:\n            return 'Initial';\n        case module.exports.Streaming:\n            return 'Streaming';\n        case module.exports.Done:\n            return 'Done';\n        case module.exports.Error:\n            return 'Error';\n        default:\n            return null;\n    }\n};\n\nmodule.exports.describe = function describe(state) {\n    return module.exports.classify(state) || 'Unknown(' + state + ')';\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/streaming_out_request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\n\nvar OutArgStream = require('./argstream').OutArgStream;\nvar pipelineStreams = require('./lib/pipeline_streams');\nvar TChannelOutRequest = require('./out_request');\nvar States = require('./reqres_states');\n\nfunction StreamingOutRequest(id, options) {\n    TChannelOutRequest.call(this, id, options);\n    this.streamed = true;\n    this._argstream = new OutArgStream();\n    this.arg2 = this._argstream.arg2;\n    this.arg3 = this._argstream.arg3;\n\n    var self = this;\n    this._argstream.errorEvent.on(passError);\n    this._argstream.frameEvent.on(onFrame);\n    this._argstream.finishEvent.on(onFinish);\n\n    function passError(err) {\n        self.errorEvent.emit(self, err);\n    }\n\n    function onFrame(tup) {\n        var parts = tup[0];\n        var isLast = tup[1];\n        if (self.state === States.Initial) {\n            parts.unshift(self.arg1);\n        }\n        self.sendParts(parts, isLast);\n    }\n\n    function onFinish() {\n        self.finishEvent.emit(self);\n    }\n}\n\ninherits(StreamingOutRequest, TChannelOutRequest);\n\nStreamingOutRequest.prototype.type = 'tchannel.outgoing-request.streaming';\n\nStreamingOutRequest.prototype.sendArg1 = function sendArg1(arg1) {\n    var self = this;\n\n    TChannelOutRequest.prototype.sendArg1.call(self, arg1);\n    self._argstream.deferFlushParts();\n};\n\nStreamingOutRequest.prototype.send = function send(arg1, arg2, arg3, callback) {\n    var self = this;\n\n    if (callback) {\n        self.hookupCallback(callback);\n    }\n\n    self.sendArg1(arg1);\n    self.arg2.end(arg2);\n    self.arg3.end(arg3);\n\n    return self;\n};\n\nStreamingOutRequest.prototype.sendStreams = function sendStreams(arg1, arg2, arg3, callback) {\n    var self = this;\n\n    if (callback) {\n        self.hookupStreamCallback(callback);\n    }\n\n    self.sendArg1(arg1);\n    pipelineStreams([arg2, arg3], [self.arg2, self.arg3]);\n\n    return self;\n};\n\nmodule.exports = StreamingOutRequest;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/argstream.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/*\n * Provides federated streams for handling call arguments\n *\n * InArgStream is for handling incoming arg parts from call frames.  It handles\n * dispatching the arg chunks into .arg{1,2,3} streams.\n *\n * OutArgStream is for creating outgoing arg parts by writing to .arg{1,2,3}\n * streams.  It handles buffering as many parts as are written within one event\n * loop tick into an Array of arg chunks.  Such array is then flushed using\n * setImmediate.\n *\n * Due to the semantic complexity involved here, this code is tested by an\n * accompanying exhaistive search test in test/argstream.js.  This test has\n * both unit tests (disabled by default for speed) and an integration test.\n */\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('./lib/event_emitter');\nvar PassThrough = require('stream').PassThrough;\nvar Ready = require('ready-signal');\nvar Buffer = require('buffer').Buffer;\nvar setImmediate = require('timers').setImmediate;\nvar clearImmediate = require('timers').clearImmediate;\n\nvar errors = require('./errors');\n\nfunction ArgStream() {\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.frameEvent = this.defineEvent('frame');\n    this.finishEvent = this.defineEvent('finish');\n    this.arg2 = new StreamArg();\n    this.arg3 = new StreamArg();\n\n    var self = this;\n    this.arg2.on('error', passError);\n    this.arg3.on('error', passError);\n    this.arg3.on('start', onArg3Start);\n\n    function passError(err) {\n        self.errorEvent.emit(self, err);\n    }\n\n    function onArg3Start() {\n        if (!self.arg2._writableState.ended) {\n            self.arg2.end();\n        }\n    }\n}\n\ninherits(ArgStream, EventEmitter);\n\nfunction InArgStream() {\n    ArgStream.call(this);\n    this.streams = [this.arg2, this.arg3];\n    this._iStream = 0;\n    this.finished = false;\n    this._numFinished = 0;\n\n    var self = this;\n    this.arg2.on('finish', argFinished);\n    this.arg3.on('finish', argFinished);\n\n    function argFinished() {\n        if (++self._numFinished >= 2 && !self.finished) {\n            self.finished = true;\n            self.finishEvent.emit(self);\n        }\n    }\n}\n\ninherits(InArgStream, ArgStream);\n\nInArgStream.prototype.handleFrame = function handleFrame(parts, isLast) {\n    var self = this;\n    var stream = self.streams[self._iStream];\n\n    if (self.finished) {\n        // return new Error('unknown frame handling state');\n        return errors.ArgStreamFinishedError();\n    }\n\n    for (var i = 0; i < parts.length; i++) {\n        if (i > 0) {\n            stream = advance();\n        }\n        if (!stream) {\n            break;\n        }\n        if (parts[i].length) {\n            stream.write(parts[i]);\n        }\n    }\n    if (i < parts.length) {\n        return errors.ArgStreamExceededFramePartsError();\n    }\n\n    if (isLast) {\n        while (stream) {\n            stream = advance();\n        }\n    }\n\n    return null;\n\n    function advance() {\n        if (self._iStream < self.streams.length) {\n            self.streams[self._iStream].end();\n            self._iStream++;\n        }\n        return self.streams[self._iStream];\n    }\n};\n\nfunction OutArgStream() {\n    ArgStream.call(this);\n    this._flushImmed = null;\n    this.finished = false;\n    this.frame = [Buffer(0)];\n    this.currentArgN = 2;\n\n    var self = this;\n    this.arg2.on('data', onArg2Data);\n    this.arg3.on('data', onArg3Data);\n    this.arg2.on('finish', onArg2Finish);\n    this.arg3.on('finish', onArg3Finish);\n\n    function onArg2Data(chunk) {\n        self._handleFrameChunk(2, chunk);\n    }\n\n    function onArg3Data(chunk) {\n        self._handleFrameChunk(3, chunk);\n    }\n\n    function onArg2Finish() {\n        self._handleFrameChunk(2, null);\n    }\n\n    function onArg3Finish() {\n        if (!self.finished) {\n            self._handleFrameChunk(3, null);\n            self._flushParts(true);\n            self.finished = true;\n            self.finishEvent.emit(self);\n        }\n    }\n}\n\ninherits(OutArgStream, ArgStream);\n\nOutArgStream.prototype._handleFrameChunk = function _handleFrameChunk(n, chunk) {\n    var self = this;\n    if (n < self.currentArgN) {\n        self.errorEvent.emit(self, errors.ArgChunkOutOfOrderError({\n            current: self.currentArgN,\n            got: n\n        }));\n    } else if (n > self.currentArgN) {\n        if (n - self.currentArgN > 1) {\n            self.errorEvent.emit(self, errors.ArgChunkGapError({\n                current: self.currentArgN,\n                got: n\n            }));\n        }\n        self.currentArgN++;\n        self.frame.push(chunk);\n    } else if (chunk === null) {\n        if (++self.currentArgN <= 3) {\n            self.frame.push(Buffer(0));\n        }\n    } else {\n        self._appendFrameChunk(chunk);\n    }\n    self.deferFlushParts();\n};\n\nOutArgStream.prototype._appendFrameChunk = function _appendFrameChunk(chunk) {\n    var self = this;\n    var i = self.frame.length - 1;\n    var buf = self.frame[i];\n    if (buf.length) {\n        self.frame[i] = Buffer.concat([buf, chunk]);\n    } else {\n        self.frame[i] = chunk;\n    }\n};\n\nOutArgStream.prototype.deferFlushParts = function deferFlushParts() {\n    var self = this;\n    if (!self._flushImmed) {\n        self._flushImmed = setImmediate(function flushParts() {\n            self._flushParts();\n        });\n    }\n};\n\nOutArgStream.prototype._flushParts = function _flushParts(isLast) {\n    var self = this;\n    if (self._flushImmed) {\n        clearImmediate(self._flushImmed);\n        self._flushImmed = null;\n    }\n    if (self.finished) {\n        return;\n    }\n    isLast = Boolean(isLast);\n    var frame = self.frame;\n    self.frame = [Buffer(0)];\n    if (frame.length) {\n        self.frameEvent.emit(self, [frame, isLast]);\n    }\n};\n\nfunction StreamArg(options) {\n    PassThrough.call(this, options);\n    this.started = false;\n    this.buf = null;\n    this.onValueReady = boundOnValueReady;\n\n    var self = this;\n\n    function boundOnValueReady(callback) {\n        self._onValueReady(callback);\n    }\n}\ninherits(StreamArg, PassThrough);\n\nStreamArg.prototype._write = function _write(chunk, encoding, callback) {\n    var self = this;\n    if (!self.started) {\n        self.started = true;\n        self.emit('start');\n    }\n    PassThrough.prototype._write.call(self, chunk, encoding, callback);\n};\n\nStreamArg.prototype._onValueReady = function onValueReady(callback) {\n    var self = this;\n    self.onValueReady = Ready();\n    bufferStreamData(self, self.onValueReady.signal);\n    self.onValueReady(callback);\n};\n\nfunction bufferStreamData(stream, callback) {\n    var parts = [];\n    stream.on('data', onData);\n    stream.on('error', finish);\n    stream.on('end', finish);\n    function onData(chunk) {\n        parts.push(chunk);\n    }\n    function finish(err) {\n        stream.removeListener('data', onData);\n        stream.removeListener('error', finish);\n        stream.removeListener('end', finish);\n        var buf = Buffer.concat(parts);\n        stream.buf = buf;\n        if (err === undefined) {\n            err = null;\n        }\n        callback(err, buf);\n    }\n}\n\nmodule.exports.InArgStream = InArgStream;\nmodule.exports.OutArgStream = OutArgStream;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/pipeline_streams.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar hex;\nvar util = require('util');\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\n\n/*eslint complexity: [2, 15], max-statements: [2, 40] */\nmodule.exports = pipelineStreams;\n\nfunction pipelineStreams(sources, dests, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    } else if (!options) {\n        options = {};\n    }\n    next(0);\n    function next(i) {\n        if (i >= dests.length) {\n            if (callback) {\n                callback(null);\n            }\n            return;\n        }\n        var src = sources[i];\n        var dst = dests[i];\n        if (src === null || src === undefined) {\n            dst.end();\n            if (options.debug) {\n                process.stdout.write(util.format('%s END ARG%s: EMPTY\\n', options.debug, i + 1));\n            }\n            next(i + 1);\n        } else if (typeof src === 'string' || Buffer.isBuffer(src)) {\n            if (options.debug) {\n                if (!hex) {\n                    hex = require('hexer');\n                }\n\n                process.stdout.write(\n                    util.format('%s END ARG%s:\\n', options.debug, i + 1) +\n                    hex(src) + '\\n');\n            }\n            dst.end(src);\n            next(i + 1);\n        } else {\n            if (options.debug) {\n                if (!hex) {\n                    hex = require('hexer');\n                }\n\n                var n = i + 1;\n                process.stdout.write(util.format('%s PIPE ARG%s:\\n', options.debug, n));\n                src = src.pipe(hex.Spy(process.stdout));\n                src.on('end', function onEnd() {\n                    process.stdout.write(util.format('%s PIPE ARG%s END\\n', options.debug, n));\n                });\n            }\n            src.pipe(dst);\n            dst.once('finish', onStreamFinished);\n        }\n        function onStreamFinished() {\n            next(i + 1);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v2/out_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable curly */\n\nvar inherits = require('util').inherits;\n\nvar OutResponse = require('../out_response');\nvar StreamingOutResponse = require('../streaming_out_response');\n\nvar CallFlags = require('./call_flags');\nvar v2 = require('./index');\nvar errors = require('../errors');\n\nfunction V2OutResponse(handler, id, options) {\n    OutResponse.call(this, id, options);\n    this.handler = handler;\n}\n\ninherits(V2OutResponse, OutResponse);\n\nfunction V2StreamingOutResponse(handler, id, options) {\n    StreamingOutResponse.call(this, id, options);\n    this.handler = handler;\n}\n\ninherits(V2StreamingOutResponse, StreamingOutResponse);\n\nV2OutResponse.prototype._sendCallResponse =\nV2StreamingOutResponse.prototype._sendCallResponse =\nfunction _sendCallResponse(args, isLast) {\n    var flags = 0;\n    if (args && args[0] && args[0].length > v2.MaxArg1Size) {\n        this.errorEvent.emit(this, errors.Arg1OverLengthLimit({\n            length: args[0].length,\n            limit: v2.MaxArg1Size\n        }));\n        return;\n    }\n    if (!isLast) flags |= CallFlags.Fragment;\n    this.handler.sendCallResponseFrame(this, flags, args);\n};\n\nV2OutResponse.prototype._sendCallResponseCont =\nV2StreamingOutResponse.prototype._sendCallResponseCont =\nfunction _sendCallResponseCont(args, isLast) {\n    var flags = 0;\n    if (!isLast) flags |= CallFlags.Fragment;\n    this.handler.sendCallResponseContFrame(this, flags, args);\n};\n\nV2OutResponse.prototype._sendError =\nV2StreamingOutResponse.prototype._sendError =\nfunction _sendError(codeString, message) {\n    this.handler.sendErrorFrame(this.id, this.tracing, codeString, message);\n};\n\nmodule.exports.OutResponse = V2OutResponse;\nmodule.exports.StreamingOutResponse = V2StreamingOutResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/out_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar EventEmitter = require('./lib/event_emitter');\nvar stat = require('./stat-tags.js');\nvar inherits = require('util').inherits;\n\nvar errors = require('./errors');\nvar States = require('./reqres_states');\n\n/*eslint max-statements: [2, 40]*/\nfunction TChannelOutResponse(id, options) {\n    options = options || {};\n    var self = this;\n    EventEmitter.call(self);\n    self.errorEvent = self.defineEvent('error');\n    self.spanEvent = self.defineEvent('span');\n    self.finishEvent = self.defineEvent('finish');\n\n    self.channel = options.channel;\n    self.inreq = options.inreq;\n    self.logger = options.logger;\n    self.random = options.random;\n    self.timers = options.timers;\n\n    self.start = 0;\n    self.end = 0;\n    self.state = States.Initial;\n    self.id = id || 0;\n    self.code = options.code || 0;\n    self.tracing = options.tracing || null;\n    self.headers = options.headers || {};\n    self.checksumType = options.checksumType || 0;\n    self.checksum = options.checksum || null;\n    self.ok = self.code === 0;\n    self.span = options.span || null;\n    self.streamed = false;\n    self._argstream = null;\n    self.arg1 = null;\n    self.arg2 = null;\n    self.arg3 = null;\n\n    self.codeString = null;\n    self.message = null;\n\n    self.error = null;\n}\n\ninherits(TChannelOutResponse, EventEmitter);\n\nTChannelOutResponse.prototype.type = 'tchannel.outgoing-response';\n\nTChannelOutResponse.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    info.responseId = self.id;\n    info.responseType = self.type;\n    info.responseState = States.describe(self.state);\n    info.responseOk = self.ok;\n    info.responseCode = self.code;\n    info.responseCodeString = self.codeString;\n    info.responseErrorMessage = self.message;\n    info.responseStart = self.start;\n    info.responseEnd = self.end;\n    info.responseHasArg3 = self.arg3 !== null && self.arg3 !== undefined;\n\n    if (self.inreq) {\n        info = self.inreq.extendLogInfo(info);\n    }\n\n    return info;\n};\n\nTChannelOutResponse.prototype._sendCallResponse = function _sendCallResponse(args, isLast) {\n    var self = this;\n    throw errors.UnimplementedMethod({\n        className: self.constructor.name,\n        methodName: '_sendCallResponse'\n    });\n};\n\nTChannelOutResponse.prototype._sendCallResponseCont = function _sendCallResponseCont(args, isLast) {\n    var self = this;\n    throw errors.UnimplementedMethod({\n        className: self.constructor.name,\n        methodName: '_sendCallResponseCont'\n    });\n};\n\nTChannelOutResponse.prototype._sendError = function _sendError(codeString, message) {\n    var self = this;\n    throw errors.UnimplementedMethod({\n        className: self.constructor.name,\n        methodName: '_sendError'\n    });\n};\n\nTChannelOutResponse.prototype.sendParts = function sendParts(parts, isLast) {\n    var self = this;\n    switch (self.state) {\n        case States.Initial:\n            self.sendCallResponseFrame(parts, isLast);\n            break;\n        case States.Streaming:\n            self.sendCallResponseContFrame(parts, isLast);\n            break;\n        case States.Done:\n            self.emitError(errors.ResponseFrameState({\n                attempted: 'arg parts',\n                state: 'Done'\n            }));\n            break;\n        case States.Error:\n            // TODO: log warn\n            break;\n        default:\n            self.channel.logger.error('TChannelOutResponse is in a wrong state', self.extendLogInfo({}));\n            break;\n    }\n};\n\nTChannelOutResponse.prototype.sendCallResponseFrame = function sendCallResponseFrame(args, isLast) {\n    var self = this;\n    switch (self.state) {\n        case States.Initial:\n            self.start = self.timers.now();\n            self._sendCallResponse(args, isLast);\n            if (self.span) {\n                self.span.annotate('ss');\n            }\n            if (isLast) {\n                self.state = States.Done;\n            } else {\n                self.state = States.Streaming;\n            }\n            break;\n        case States.Streaming:\n            self.emitError(errors.ResponseFrameState({\n                attempted: 'call response',\n                state: 'Streaming'\n            }));\n            break;\n        case States.Done:\n        case States.Error:\n            var arg2 = args[1] || '';\n            var arg3 = args[2] || '';\n\n            self.emitError(errors.ResponseAlreadyDone({\n                attempted: 'call response',\n                state: self.state,\n                method: 'sendCallResponseFrame',\n                bufArg2: arg2.slice(0, 50),\n                arg2: String(arg2).slice(0, 50),\n                bufArg3: arg3.slice(0, 50),\n                arg3: String(arg3).slice(0, 50)\n            }));\n            break;\n        default:\n            // TODO: log warn\n            break;\n    }\n};\n\nTChannelOutResponse.prototype.sendCallResponseContFrame = function sendCallResponseContFrame(args, isLast) {\n    var self = this;\n    switch (self.state) {\n        case States.Initial:\n            self.emitError(errors.ResponseFrameState({\n                attempted: 'call response continuation',\n                state: 'Initial'\n            }));\n            break;\n        case States.Streaming:\n            self._sendCallResponseCont(args, isLast);\n            if (isLast) {\n                self.state = States.Done;\n            }\n            break;\n        case States.Done:\n        case States.Error:\n            self.emitError(errors.ResponseAlreadyDone({\n                attempted: 'call response continuation',\n                state: self.state,\n                method: 'sendCallResponseContFrame'\n            }));\n            break;\n        default:\n            // TODO: log warn\n            break;\n    }\n};\n\nTChannelOutResponse.prototype.responseAlreadyDone = function responseAlreadyDone() {\n    var self = this;\n\n    if (self.state === States.Done || self.state === States.Error) {\n        var errorEvent = self.errorEvent || {};\n        var listener = !!errorEvent.listener;\n        var listeners = 0;\n        if (errorEvent.listeners && errorEvent.listeners.length) {\n            listeners = errorEvent.listeners.length;\n        }\n\n        self.logger.error('responseAlreadyDone detected!!', self.extendLogInfo({\n            haveErrorListener: listener,\n            numberOfErrorListenerrs: listeners\n        }));\n        return true;\n    } else {\n        return false;\n    }\n};\n\nTChannelOutResponse.prototype.sendError = function sendError(codeString, message) {\n    var self = this;\n\n    if (self.inreq.connection && // because selfpeer/connection\n        self.inreq.connection.closing) {\n        self.logger.info('ignoring outresponse.sendError on a closed connection', self.extendLogInfo({\n            codeString: codeString,\n            errorMessage: message\n        }));\n        return;\n    }\n\n    if (self.state === States.Done || self.state === States.Error) {\n        self.emitError(errors.ResponseAlreadyDone({\n            attempted: 'error frame',\n            currentState: self.state,\n            method: 'sendError',\n            codeString: codeString,\n            errMessage: message\n        }));\n    } else {\n        if (self.span) {\n            self.span.annotate('ss');\n        }\n        self.state = States.Error;\n\n        self.codeString = codeString;\n        self.message = message;\n        self.channel.emitFastStat(\n            'tchannel.inbound.calls.system-errors',\n            'counter',\n            1,\n            new stat.InboundCallsSystemErrorsTags(\n                self.inreq.callerName,\n                self.inreq.serviceName,\n                String(self.inreq.arg1),\n                self.codeString\n            )\n        );\n        self._sendError(codeString, message);\n        self.emitFinish();\n    }\n};\n\nTChannelOutResponse.prototype.emitError = function emitError(err) {\n    var self = this;\n\n    if (self.inreq && self.inreq.circuit) {\n        self.inreq.circuit.state.onRequestError(err);\n    }\n\n    self.error = err;\n    self.errorEvent.emit(self, err);\n};\n\nTChannelOutResponse.prototype.emitFinish = function emitFinish() {\n    var self = this;\n    var now = self.timers.now();\n\n    if (self.end) {\n        self.logger.warn('out response double emitFinish', self.extendLogInfo({\n            now: now\n        }));\n        return;\n    }\n\n    self.end = now;\n\n    var latency = self.end - self.inreq.start;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.latency',\n        'timing',\n        latency,\n        new stat.InboundCallsLatencyTags(\n            self.inreq.callerName,\n            self.inreq.serviceName,\n            self.inreq.endpoint\n        )\n    );\n\n    if (self.span) {\n        self.spanEvent.emit(self, self.span);\n    }\n\n    if (self.inreq && self.inreq.circuit) {\n        // TODO distingiush res.ok?\n        // note that incoming requests do not have responseEvent and clear out\n        // their response upon finish.\n        if (errors.isUnhealthy(self.codeString)) {\n            self.inreq.circuit.state.onRequestUnhealthy();\n        } else {\n            self.inreq.circuit.state.onRequestHealthy();\n        }\n    }\n\n    self.finishEvent.emit(self);\n};\n\nTChannelOutResponse.prototype.setOk = function setOk(ok) {\n    var self = this;\n    if (self.state !== States.Initial) {\n        self.emitError(errors.ResponseAlreadyStarted({\n            state: self.state,\n            method: 'setOk',\n            ok: ok\n        }));\n        return false;\n    }\n    self.ok = ok;\n    self.code = ok ? 0 : 1; // TODO: too coupled to v2 specifics?\n    return true;\n};\n\nTChannelOutResponse.prototype.sendOk = function sendOk(res1, res2) {\n    var self = this;\n    self.setOk(true);\n    self.send(res1, res2);\n};\n\nTChannelOutResponse.prototype.sendNotOk = function sendNotOk(res1, res2) {\n    var self = this;\n    if (self.state === States.Error) {\n        self.logger.error('cannot send application error, already sent error frame', self.extendLogInfo({\n            res1: res1,\n            res2: res2\n        }));\n    } else {\n        self.setOk(false);\n        self.send(res1, res2);\n    }\n};\n\nTChannelOutResponse.prototype.send = function send(res1, res2) {\n    var self = this;\n\n    /* send calls after finish() should be swallowed */\n    if (self.end) {\n        var inreqErrClass = self.inreq &&\n                            self.inreq.err &&\n                            errors.classify(self.inreq.err);\n\n        switch (inreqErrClass) {\n            case 'Timeout':\n                self.logger.info('OutResponse.send() after inreq timed out', self.extendLogInfo({}));\n                break;\n            default:\n                self.logger.warn('OutResponse called send() after end', self.extendLogInfo({}));\n        }\n        return self;\n    }\n\n    self.arg2 = res1;\n    self.arg3 = res2;\n\n    if (self.ok) {\n        self.channel.emitFastStat(\n            'tchannel.inbound.calls.success',\n            'counter',\n            1,\n            new stat.InboundCallsSuccessTags(\n                self.inreq.callerName,\n                self.inreq.serviceName,\n                self.inreq.endpoint\n            )\n        );\n    } else {\n        // TODO: add outResponse.setErrorType()\n        self.channel.emitFastStat(\n            'tchannel.inbound.calls.app-errors',\n            'counter',\n            1,\n            new stat.InboundCallsAppErrorsTags(\n                self.inreq.callerName,\n                self.inreq.serviceName,\n                self.inreq.endpoint,\n                'unknown'\n            )\n        );\n    }\n\n    // TODO: may be spam, consider dropping\n    if (self.inreq.connection && // because selfpeer/connection\n        self.inreq.connection.closing) {\n        self.logger.info('ignoring outresponse.send on a closed connection', self.extendLogInfo({}));\n    } else {\n        self.sendCallResponseFrame([self.arg1, res1, res2], true);\n    }\n\n    self.emitFinish();\n\n    return self;\n};\n\nmodule.exports = TChannelOutResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/streaming_out_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\n\nvar OutArgStream = require('./argstream').OutArgStream;\nvar pipelineStreams = require('./lib/pipeline_streams');\nvar OutResponse = require('./out_response');\nvar errors = require('./errors');\nvar States = require('./reqres_states');\n\nfunction StreamingOutResponse(id, options) {\n    OutResponse.call(this, id, options);\n    this.streamed = true;\n    this._argstream = new OutArgStream();\n    this.arg2 = this._argstream.arg2;\n    this.arg3 = this._argstream.arg3;\n\n    var self = this;\n    this._argstream.errorEvent.on(passError);\n    this._argstream.frameEvent.on(onFrame);\n    this._argstream.finishEvent.on(onFinish);\n\n    function passError(err) {\n        self.errorEvent.emit(self, err);\n    }\n\n    function onFrame(tup) {\n        var parts = tup[0];\n        var isLast = tup[1];\n        if (self.state === States.Initial) {\n            parts.unshift(self.arg1);\n        }\n        self.sendParts(parts, isLast);\n    }\n\n    function onFinish() {\n        self.emitFinish();\n    }\n}\n\ninherits(StreamingOutResponse, OutResponse);\n\nStreamingOutResponse.prototype.type = 'tchannel.outgoing-response.streaming';\n\nStreamingOutResponse.prototype.sendError = function sendError(codeString, message) {\n    var self = this;\n    if (self.state === States.Done || self.state === States.Error) {\n        self.errorEvent.emit(self, errors.ResponseAlreadyDone({\n            attempted: 'send error frame: ' + codeString + ': ' + message\n        }));\n    } else {\n        if (self.span) {\n            self.span.annotate('ss');\n        }\n        self.state = States.Error;\n        self._argstream.finished = true;\n        self.arg2.end();\n        self.arg3.end();\n        self._sendError(codeString, message);\n        self.emitFinish();\n    }\n};\n\nStreamingOutResponse.prototype.setOk = function setOk(ok) {\n    var self = this;\n    if (self.state !== States.Initial) {\n        self.errorEvent.emit(self, errors.ResponseAlreadyStarted({\n            state: self.state\n        }));\n        return false;\n    }\n    self.ok = ok;\n    self.code = ok ? 0 : 1; // TODO: too coupled to v2 specifics?\n    self._argstream.deferFlushParts();\n    return true;\n};\n\nStreamingOutResponse.prototype.send = function send(res1, res2) {\n    var self = this;\n    self.arg2.end(res1);\n    self.arg3.end(res2);\n    return self;\n};\n\nStreamingOutResponse.prototype.sendStreams = function sendStreams(res1, res2, callback) {\n    var self = this;\n    var called = false;\n    self.errorEvent.on(onError);\n    pipelineStreams(\n        [res1, res2],\n        [self.arg2, self.arg3],\n        finish);\n    return self;\n\n    function onError(err) {\n        if (!called) {\n            called = true;\n            if (callback) {\n                callback(err);\n            }\n        }\n    }\n\n    function finish() {\n        if (!called) {\n            called = true;\n            if (callback) {\n                callback(null);\n            }\n        }\n    }\n};\n\nmodule.exports = StreamingOutResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/in_request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar EventEmitter = require('./lib/event_emitter');\nvar inherits = require('util').inherits;\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\n\nvar errors = require('./errors');\nvar States = require('./reqres_states');\n\nvar emptyBuffer = Buffer(0);\n\nfunction TChannelInRequest(id, options) {\n    /*eslint max-statements: [2, 40]*/\n\n    EventEmitter.call(this);\n    this.errorEvent = this.defineEvent('error');\n    this.timeoutEvent = this.defineEvent('timeout');\n    this.finishEvent = this.defineEvent('finish');\n    this.channel = options.channel;\n\n    this.timeout = options.timeout || 0;\n    this.tracing = options.tracing || null;\n    this.serviceName = options.serviceName || '';\n    this.callerName = options.headers && options.headers.cn || '';\n    this.headers = options.headers || {};\n    this.checksum = options.checksum || null;\n    this.retryFlags = options.retryFlags || null;\n    this.connection = options.connection || null;\n\n    this.state = States.Initial;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.id = id || 0;\n    this.remoteAddr = null;\n    this.streamed = false;\n    this.arg1 = emptyBuffer;\n    this.endpoint = null;\n    this.arg2 = emptyBuffer;\n    this.arg3 = emptyBuffer;\n    this.forwardTrace = false;\n    this.span = null;\n    this.start = this.channel.timers.now();\n    this.res = null;\n    this.err = null;\n    this.circuit = null;\n    this.flags = options.flags;\n\n    if (options.tracer) {\n        this.setupTracing(options);\n    }\n}\n\ninherits(TChannelInRequest, EventEmitter);\n\nTChannelInRequest.prototype.type = 'tchannel.incoming-request';\n\nTChannelInRequest.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    // TODO: add:\n    // - request id?\n    // - tracing id?\n    // - other?\n\n    info.inRequestId = self.id;\n    info.inRequestType = self.type;\n    info.inRequestState = States.describe(self.state);\n    info.inRequestRemoteAddr = self.remoteAddr;\n    info.serviceName = self.serviceName;\n    info.callerName = self.callerName;\n    info.inRequestErr = self.err;\n\n    if (self.endpoint !== null) {\n        info.inRequestArg1 = self.endpoint;\n    } else {\n        info.inRequestArg1 = String(self.arg1);\n    }\n\n    if (self.connection) {\n        info = self.connection.extendLogInfo(info);\n    }\n\n    return info;\n};\n\nTChannelInRequest.prototype.setupTracing = function setupTracing(options) {\n    var self = this;\n\n    self.span = options.tracer.setupNewSpan({\n        spanid: self.tracing.spanid,\n        traceid: self.tracing.traceid,\n        parentid: self.tracing.parentid,\n        flags: self.tracing.flags,\n        remoteName: options.hostPort,\n        serviceName: self.serviceName,\n        name: '' // fill this in later\n    });\n\n    self.span.annotateBinary('cn', self.callerName);\n    self.span.annotateBinary('as', self.headers.as);\n    if (self.connection) {\n        self.span.annotateBinary('src', self.connection.remoteName);\n    }\n\n    self.span.annotate('sr');\n};\n\nTChannelInRequest.prototype.handleFrame = function handleFrame(parts, isLast) {\n    var self = this;\n\n    if (parts.length !== 3 || self.state !== States.Initial || !isLast) {\n        return errors.ArgStreamUnimplementedError();\n    }\n\n    self.arg1 = parts[0] || emptyBuffer;\n    self.endpoint = String(self.arg1);\n    self.arg2 = parts[1] || emptyBuffer;\n    self.arg3 = parts[2] || emptyBuffer;\n\n    if (self.span) {\n        self.span.name = self.endpoint;\n    }\n\n    self.emitFinish();\n\n    return null;\n};\n\nTChannelInRequest.prototype.emitError = function emitError(err) {\n    var self = this;\n\n    if (self.circuit) {\n        self.circuit.state.onRequestError(err);\n    }\n\n    self.err = err;\n    self.errorEvent.emit(self, err);\n};\n\nTChannelInRequest.prototype.emitFinish = function emitFinish() {\n    var self = this;\n\n    self.state = States.Done;\n    self.finishEvent.emit(self);\n};\n\nTChannelInRequest.prototype.onTimeout = function onTimeout(now) {\n    var self = this;\n    var timeoutError;\n\n    if (!self.res ||\n        self.res.state === States.Initial ||\n        self.res.state === States.Streaming\n    ) {\n        // TODO: send an error frame response?\n        // TODO: emit error on self.res instead / in addition to?\n        // TODO: should cancel any pending handler\n        timeoutError = errors.RequestTimeoutError({\n            id: self.id,\n            start: self.start,\n            elapsed: now - self.start,\n            timeout: self.timeout,\n            remoteAddr: self.remoteAddr\n        });\n        process.nextTick(deferInReqTimeoutErrorEmit);\n    }\n\n    function deferInReqTimeoutErrorEmit() {\n        if (!self.res || self.res.state === States.Initial) {\n            self.timeoutEvent.emit(self, timeoutError);\n            self.emitError(timeoutError);\n        }\n\n        if (self.operations) {\n            self.operations.popInReq(self.id);\n        }\n    }\n};\n\n// TODO: deprecated, remove\nTChannelInRequest.prototype.withArg1 = function withArg1(callback) {\n    var self = this;\n    callback(null, self.arg1);\n};\n\nTChannelInRequest.prototype.withArg2 = function withArg23(callback) {\n    var self = this;\n    callback(null, self.arg2);\n};\n\nTChannelInRequest.prototype.withArg23 = function withArg23(callback) {\n    var self = this;\n    callback(null, self.arg2, self.arg3);\n};\n\nmodule.exports = TChannelInRequest;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/in_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar EventEmitter = require('./lib/event_emitter');\nvar inherits = require('util').inherits;\nvar Buffer = require('buffer').Buffer;\n\nvar errors = require('./errors');\nvar States = require('./reqres_states');\n\nvar emptyBuffer = Buffer(0);\n\nfunction TChannelInResponse(id, options) {\n    options = options || {};\n    var self = this;\n    EventEmitter.call(self);\n    self.errorEvent = self.defineEvent('error');\n    self.finishEvent = self.defineEvent('finish');\n\n    self.logger = options.logger;\n    self.random = options.random;\n    self.timers = options.timers;\n    self.flags = options.flags;\n\n    self.state = States.Initial;\n    self.remoteAddr = null;\n    self.id = id || 0;\n    self.code = options.code || 0;\n    self.checksum = options.checksum || null;\n    self.headers = options.headers || {};\n    self.ok = self.code === 0; // TODO: probably okay, but a bit jank\n    self.span = options.span || null;\n\n    self.streamed = false;\n    self._argstream = null;\n    self.arg1 = emptyBuffer;\n    self.arg2 = emptyBuffer;\n    self.arg3 = emptyBuffer;\n\n    self.start = self.timers.now();\n\n    self.finishEvent.on(self.onFinish);\n}\n\ninherits(TChannelInResponse, EventEmitter);\n\nTChannelInResponse.prototype.type = 'tchannel.incoming-response';\n\nTChannelInResponse.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    info.responseId = self.id;\n    info.responseType = self.type;\n    info.responseState = States.describe(self.state);\n    info.responseOk = self.ok;\n    info.responseCode = self.code;\n\n    return info;\n};\n\nTChannelInResponse.prototype.onFinish = function onFinish(_arg, resp) {\n    resp.state = States.Done;\n};\n\nTChannelInResponse.prototype.handleFrame = function handleFrame(parts, isLast) {\n    var self = this;\n\n    if (parts.length !== 3 || self.state !== States.Initial || !isLast) {\n        return errors.ArgStreamUnimplementedError();\n    }\n\n    self.arg1 = parts[0] || emptyBuffer;\n    self.arg2 = parts[1] || emptyBuffer;\n    self.arg3 = parts[2] || emptyBuffer;\n\n    self.finishEvent.emit(self);\n\n    return null;\n};\n\nTChannelInResponse.prototype.withArg23 = function withArg23(callback) {\n    var self = this;\n    callback(null, self.arg2, self.arg3);\n};\n\nmodule.exports = TChannelInResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/streaming_in_request.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar parallel = require('run-parallel');\nvar InRequest = require('./in_request');\nvar inherits = require('util').inherits;\nvar errors = require('./errors');\nvar Buffer = require('buffer').Buffer;\n\nvar States = require('./reqres_states');\nvar InArgStream = require('./argstream').InArgStream;\n\nvar emptyBuffer = Buffer(0);\n\nfunction StreamingInRequest(id, options) {\n    InRequest.call(this, id, options);\n\n    this.streamed = true;\n    this._argstream = new InArgStream();\n    this.arg2 = this._argstream.arg2;\n    this.arg3 = this._argstream.arg3;\n\n    var self = this;\n    this._argstream.errorEvent.on(passError);\n    this._argstream.finishEvent.on(onFinish);\n\n    function passError(err) {\n        self.errorEvent.emit(self, err);\n    }\n\n    function onFinish() {\n        self.emitFinish();\n    }\n}\n\ninherits(StreamingInRequest, InRequest);\n\nStreamingInRequest.prototype.type = 'tchannel.incoming-request.streaming';\n\nStreamingInRequest.prototype.handleFrame = function handleFrame(parts, isLast) {\n    var self = this;\n\n    if (self.state === States.Initial) {\n        if (parts.length < 2) {\n            return errors.Arg1Fragmented();\n        }\n\n        self.arg1 = parts.shift() || emptyBuffer;\n        self.endpoint = String(self.arg1);\n        if (self.span) {\n            self.span.name = self.endpoint;\n        }\n        self.state = States.Streaming;\n    } else if (self.state !== States.Streaming) {\n        return errors.ArgStreamUnknownFrameHandlingStateError();\n    }\n\n    var err = self._argstream.handleFrame(parts, isLast);\n    if (err) {\n        return err;\n    }\n\n    if (!isLast && self.state !== States.Streaming) {\n        return errors.ArgStreamUnknownFrameHandlingStateError();\n    }\n\n    return null;\n};\n\n// TODO: deprecated, remove\nStreamingInRequest.prototype.withArg1 = function withArg1(callback) {\n    var self = this;\n    callback(null, self.arg1);\n};\n\nStreamingInRequest.prototype.withArg2 = function withArg2(callback) {\n    var self = this;\n    self.arg2.onValueReady(callback);\n};\n\nStreamingInRequest.prototype.withArg23 = function withArg23(callback) {\n    var self = this;\n    parallel({\n        arg2: self.arg2.onValueReady,\n        arg3: self.arg3.onValueReady\n    }, compatCall);\n    function compatCall(err, args) {\n        callback(err, args.arg2, args.arg3);\n    }\n};\n\nmodule.exports = StreamingInRequest;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/streaming_in_response.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar parallel = require('run-parallel');\nvar InResponse = require('./in_response');\nvar inherits = require('util').inherits;\nvar Buffer = require('buffer').Buffer;\n\nvar errors = require('./errors');\nvar States = require('./reqres_states');\nvar InArgStream = require('./argstream').InArgStream;\n\nvar emptyBuffer = Buffer(0);\n\nfunction StreamingInResponse(id, options) {\n    options = options || {};\n    InResponse.call(this, id, options);\n\n    this.streamed = true;\n    this._argstream = new InArgStream();\n    this.arg2 = this._argstream.arg2;\n    this.arg3 = this._argstream.arg3;\n\n    var self = this;\n    this._argstream.errorEvent.on(passError);\n    this._argstream.finishEvent.on(onFinish);\n\n    function passError(err) {\n        self.errorEvent.emit(self, err);\n    }\n\n    function onFinish() {\n        self.finishEvent.emit(self);\n    }\n}\n\ninherits(StreamingInResponse, InResponse);\n\nStreamingInResponse.prototype.type = 'tchannel.incoming-response.streaming';\n\nStreamingInResponse.prototype.handleFrame = function handleFrame(parts, isLast) {\n    var self = this;\n\n    if (self.state === States.Initial) {\n        if (parts.length < 2) {\n            return errors.Arg1Fragmented();\n        }\n\n        self.arg1 = parts.shift() || emptyBuffer;\n        self.state = States.Streaming;\n    } else if (self.state !== States.Streaming) {\n        return errors.ArgStreamUnknownFrameHandlingStateError();\n    }\n\n    var err = self._argstream.handleFrame(parts, isLast);\n    if (err) {\n        return err;\n    }\n\n    if (!isLast && self.state !== States.Streaming) {\n        return errors.ArgStreamUnknownFrameHandlingStateError();\n    }\n\n    return null;\n};\n\nStreamingInResponse.prototype.withArg23 = function withArg23(callback) {\n    var self = this;\n    parallel({\n        arg2: self.arg2.onValueReady,\n        arg3: self.arg3.onValueReady\n    }, compatCall);\n    function compatCall(err, args) {\n        callback(err, args.arg2, args.arg3);\n    }\n};\n\nmodule.exports = StreamingInResponse;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/operations.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar errors = require('./errors.js');\nvar inherits = require('util').inherits;\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\nvar setImmediate = require('timers').setImmediate;\nvar EventEmitter = require('./lib/event_emitter');\n\nvar TOMBSTONE_TTL_OFFSET = 500;\n\nmodule.exports = Operations;\n\nfunction Operations(opts) {\n    EventEmitter.call(this);\n    this.draining = false;\n    this.drainEvent = this.defineEvent('drain');\n    this.pendingChangeEvent = this.defineEvent('pendingChange');\n    this.pendingChangeDelta = null;\n\n    this.timers = opts.timers;\n    this.logger = opts.logger;\n    this.random = opts.random;\n    this.connectionStalePeriod = opts.connectionStalePeriod;\n    this.maxTombstoneTTL = opts.maxTombstoneTTL;\n    this.connection = opts.connection;\n    // TODO need this?\n    this.destroyed = false;\n\n    this.requests = {\n        in: Object.create(null),\n        out: Object.create(null)\n    };\n    this.pending = {\n        in: 0,\n        out: 0,\n        errors: 0\n    };\n    this.lastTimeoutTime = 0;\n}\ninherits(Operations, EventEmitter);\n\nOperations.prototype.emitPendingChange =\nfunction emitPendingChange(numIn, numOut, numErrors) {\n    var self = this;\n\n    if (self.pendingChangeDelta !== null) {\n        self.pendingChangeDelta.in += numIn;\n        self.pendingChangeDelta.out += numOut;\n        self.pendingChangeDelta.errors += numErrors;\n    } else {\n        self.pendingChangeEvent.emit(self, {\n            in: numIn,\n            out: numOut,\n            errors: numErrors\n        });\n    }\n};\n\nOperations.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    if (self.connection) {\n        info = self.connection.extendLogInfo(info);\n    }\n\n    return info;\n};\n\nOperations.prototype.setMaxTombstoneTTL =\nfunction setMaxTombstoneTTL(ttl) {\n    var self = this;\n\n    self.maxTombstoneTTL = ttl;\n};\n\nfunction OperationTombstone(operations, id, time, req, context) {\n    var self = this;\n\n    var timeout = Math.min(\n        TOMBSTONE_TTL_OFFSET + req.timeout,\n        operations.maxTombstoneTTL\n    );\n\n    self.type = 'tchannel.operation.tombstone';\n    self.isTombstone = true;\n    self.logger = operations.logger;\n    self.operations = operations;\n    self.id = id;\n    self.time = time;\n    self.timeout = timeout;\n    self.timeHeapHandle = null;\n    self.destroyed = false;\n    self.serviceName = req.serviceName;\n    self.callerName = req.callerName;\n    self.endpoint = req.endpoint;\n\n    self.isPendingError = false;\n    if (context && context.isErrorFrame) {\n        self.isPendingError = errors.isPendingError(context.codeName);\n    }\n}\n\nOperationTombstone.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    info.id = self.id;\n    info.serviceName = self.serviceName;\n    info.callerName = self.callerName;\n    info.endpoint = self.endpoint;\n    info.tombstoneTime = self.time;\n    info.tombstoneTTL = self.timeout;\n    info.heapCanceled = self.timeHeapHandle && !self.timeHeapHandle.item;\n    info.heapExpireTime = self.timeHeapHandle && self.timeHeapHandle.expireTime;\n    info.heapAmItem = self.timeHeapHandle && self.timeHeapHandle.item === self;\n\n    if (self.operations) {\n        info = self.operations.extendLogInfo(info);\n        var other = self.operations.requests.out[self.id];\n        if (self !== other) {\n            info.otherType = typeof other;\n            info.otherConstructorName = other && other.constructor && other.constructor.name;\n        }\n    }\n\n    return info;\n};\n\nOperationTombstone.prototype.destroy = function destroy(now) {\n    var self = this;\n\n    self.destroyed = true;\n\n    self.onTimeout(now);\n};\n\nOperationTombstone.prototype.onTimeout = function onTimeout(now) {\n    var self = this;\n\n    if (!self.destroyed && now < self.timeout + self.time) {\n        self.logger.error('tombstone timed out too early', self.extendLogInfo({\n            now: now,\n            expireTime: self.timeout + self.time,\n            delta: (self.timeout + self.time) - now\n        }));\n    }\n\n    if (self.operations &&\n        self.operations.requests.out[self.id] === self) {\n        delete self.operations.requests.out[self.id];\n        if (self.isPendingError) {\n            self.operations.pending.errors--;\n            self.operations.emitPendingChange(0, 0, -1);\n        }\n        self.operations = null;\n    } else {\n        self.logger.warn('mismatched expired operation tombstone', self.extendLogInfo({}));\n        self.operations = null;\n    }\n\n    self.timeHeapHandle = null;\n};\n\nOperations.prototype.resetLastTimeoutTime = function resetLastTimeoutTime() {\n    var self = this;\n\n    self.lastTimeoutTime = 0;\n};\n\nOperations.prototype.checkLastTimeoutTime = function checkLastTimeoutTime(now) {\n    var self = this;\n\n    if (self.lastTimeoutTime &&\n        now > self.lastTimeoutTime + self.connectionStalePeriod\n    ) {\n        self._deferResetDueToTimeouts(now);\n    } else if (!self.lastTimeoutTime) {\n        self.lastTimeoutTime = now;\n    }\n};\n\nOperations.prototype._deferResetDueToTimeouts = function _deferResetDueToTimeouts(now) {\n    var self = this;\n\n    var elapsed = now - self.lastTimeoutTime;\n    var err = errors.ConnectionStaleTimeoutError({\n        period: self.connectionStalePeriod,\n        elapsed: elapsed,\n        lastTimeoutTime: self.lastTimeoutTime\n    });\n    process.nextTick(opCheckLastTimedout);\n\n    function opCheckLastTimedout() {\n        self.logger.warn('destroying socket from timeouts', self.connection.extendLogInfo({\n            error: err\n        }));\n        self.connection.resetAll(err);\n    }\n};\n\nOperations.prototype.getRequests = function getRequests() {\n    var self = this;\n\n    return self.requests;\n};\n\nOperations.prototype.getPending = function getPending() {\n    var self = this;\n\n    return self.pending;\n};\n\n// TODO: Merge getOutTombstone() with getOutReq()\nOperations.prototype.getOutTombstone = function getOutTombstone(id) {\n    var self = this;\n\n    var op = self.requests.out[id] || null;\n    if (op && !op.isTombstone) {\n        return null;\n    }\n\n    return op;\n};\n\nOperations.prototype.getOutReq = function getOutReq(id) {\n    var self = this;\n\n    var req = self.requests.out[id] || null;\n    if (req && req.isTombstone) {\n        return null;\n    }\n\n    return req;\n};\n\nOperations.prototype.getInReq = function getInReq(id) {\n    var self = this;\n\n    return self.requests.in[id];\n};\n\nOperations.prototype.addOutReq = function addOutReq(req) {\n    var self = this;\n\n    req.operations = self;\n    self.requests.out[req.id] = req;\n    self.pending.out++;\n\n    req.timeHeapHandle = self.connection.channel.timeHeap.update(req);\n\n    self.emitPendingChange(0, 1, 0);\n\n    return req;\n};\n\nOperations.prototype.addInReq = function addInReq(req) {\n    var self = this;\n\n    req.operations = self;\n    self.requests.in[req.id] = req;\n    self.pending.in++;\n\n    req.timeHeapHandle = self.connection.channel.timeHeap.update(req);\n\n    self.emitPendingChange(1, 0, 0);\n\n    return req;\n};\n\nOperations.prototype.hasDrained = function hasDrained() {\n    var self = this;\n\n    if (self.pending.in === 0 &&\n        self.pending.out === 0) {\n        return true;\n    } else if (self._isCollDrained(self.requests.in) &&\n               self._isCollDrained(self.requests.out)) {\n        return true;\n    }\n\n    return false;\n};\n\nOperations.prototype.checkDrained = function checkDrained() {\n    var self = this;\n\n    if (self.hasDrained()) {\n        self.drainEvent.emit(self);\n        self.drainEvent.removeAllListeners();\n    }\n};\n\nOperations.prototype._isCollDrained = function _isCollDrained(coll) {\n    var self = this;\n\n    /*eslint-disable guard-for-in*/\n    for (var id in coll) {\n        var op = coll[id];\n        if (!(op instanceof OperationTombstone) &&\n            !op.drained && !(\n                self.connection.channel.drainExempt &&\n                self.connection.channel.drainExempt(op))\n        ) {\n            return false;\n        }\n    }\n    /*eslint-enable guard-for-in*/\n\n    return true;\n};\n\nOperations.prototype.popOutReq = function popOutReq(id, context) {\n    var self = this;\n\n    var req = self.requests.out[id];\n    if (!req) {\n        self.logMissingOutRequest(id, context);\n        return null;\n    } else if (req.isTombstone) {\n        return null;\n    }\n\n    if (req.timeHeapHandle) {\n        req.timeHeapHandle.cancel();\n        req.timeHeapHandle = null;\n    } else {\n        self.logger.warn('Found OutRequest without timeHeapHandle', {\n            serviceName: req.serviceName,\n            endpoint: req.endpoint,\n            socketRemoteAddr: req.remoteAddr,\n            callerName: req.callerName\n        });\n    }\n\n    var tombstone = new OperationTombstone(\n        self, id, self.timers.now(), req, context\n    );\n    self.requests.out[id] = tombstone;\n    tombstone.timeHeapHandle = self.connection.channel.timeHeap.update(tombstone, tombstone.time);\n\n    var pendingErrors = 0;\n\n    if (tombstone.isPendingError) {\n        self.pending.errors++;\n        pendingErrors++;\n    }\n\n    req.operations = null;\n    self.pending.out--;\n    if (self.draining) {\n        self.checkDrained();\n    }\n\n    self.emitPendingChange(0, -1, pendingErrors);\n\n    return req;\n};\n\nOperations.prototype.logMissingOutRequest =\nfunction logMissingOutRequest(id, context) {\n    var self = this;\n\n    // context is err or res\n    if (context && context.originalId) {\n        context = {\n            error: context,\n            id: context.originalId,\n            info: 'got error frame for unknown id'\n        };\n    } else if (context && context.id) {\n        context = {\n            responseId: context.id,\n            code: context.code,\n            arg1: Buffer.isBuffer(context.arg1) ?\n                String(context.arg1) : 'streamed-arg1',\n            info: 'got call response for unknown id'\n        };\n    }\n\n    // This could be because of a confused / corrupted server.\n    self.logger.info('popOutReq received for unknown or lost id',\n        self.connection.extendLogInfo({\n            context: context,\n            socketRemoteAddr: self.connection.socketRemoteAddr,\n            direction: self.connection.direction\n        })\n    );\n};\n\nOperations.prototype.popInReq = function popInReq(id) {\n    var self = this;\n\n    var req = self.requests.in[id];\n    if (!req) {\n        // TODO warn ?\n        return null;\n    }\n\n    if (req.timeHeapHandle) {\n        req.timeHeapHandle.cancel();\n        req.timeHeapHandle = null;\n    }\n\n    delete self.requests.in[id];\n    self.pending.in--;\n\n    self.emitPendingChange(-1, 0, 0);\n\n    if (self.draining) {\n        self.checkDrained();\n    }\n\n    return req;\n};\n\nOperations.prototype.clear = function clear() {\n    var self = this;\n\n    var now = self.timers.now();\n    var inReqKeys = Object.keys(self.requests.in);\n    var outReqKeys = Object.keys(self.requests.out);\n\n    for (var i = 0; i < inReqKeys.length; i++) {\n        self.popInReq(inReqKeys[i]);\n    }\n    for (var j = 0; j < outReqKeys.length; j++) {\n        self.popOutReq(outReqKeys[j]);\n\n        var tombstone = self.requests.out[outReqKeys[j]];\n        if (tombstone.timeHeapHandle) {\n            tombstone.timeHeapHandle.cancel();\n        }\n        tombstone.destroy(now);\n    }\n};\n\nOperations.prototype.destroy = function destroy() {\n    var self = this;\n\n    self.destroyed = true;\n};\n\nOperations.prototype.sanitySweep = function sanitySweep(callback) {\n    var self = this;\n\n    self._sweepOps(self.requests.in, 'in', doneSweep);\n    self._sweepOps(self.requests.out, 'out', doneSweep);\n\n    var i = 0;\n    function doneSweep() {\n        i++;\n        if (i === 2) {\n            callback();\n        }\n    }\n};\n\nOperations.prototype._sweepOps = function _sweepOps(ops, direction, callback) {\n    /*eslint max-statements: [2, 40]*/\n    var self = this;\n\n    // keep track of all pending change made during the sweep so we can\n    // (maybe) emit one event at the end of the sweep\n\n    self.pendingChangeDelta = {\n        in: 0,\n        out: 0,\n        errors: 0\n    };\n    var pendingDirty = false;\n\n    var now = self.timers.now();\n\n    nextOp(Object.keys(ops), 0, callback);\n\n    /*eslint complexity: 0*/\n    function nextOp(opKeys, i, done) {\n        if (i >= opKeys.length) {\n            done(null);\n            return;\n        }\n\n        var id = opKeys[i];\n        var op = ops[id];\n\n        if (!Object.prototype.hasOwnProperty.call(ops, id)) {\n            setImmediate(deferNextOp);\n            return;\n        }\n\n        if (op === undefined && (id in ops)) {\n            self.logger.warn('unexpected undefined operation', {\n                direction: direction,\n                id: id\n            });\n        } else if (op.timedOut) {\n            self.logger.warn('lingering timed-out operation', {\n                direction: direction,\n                id: id\n            });\n\n            if (direction === 'in') {\n                self.popInReq(id);\n                pendingDirty = true;\n            } else if (direction === 'out') {\n                self.popOutReq(id);\n                pendingDirty = true;\n            }\n        } else if (op.isTombstone) {\n            var heap = self.connection.channel.timeHeap;\n            var expireTime = op.time + op.timeout;\n\n            if (!op.operations) {\n                self.logger.warn('zombie tombstone', op.extendLogInfo({\n                    direction: direction,\n                    opKey: id\n                }));\n                delete ops[id];\n                if (op.isPendingError) {\n                    self.pending.errors--;\n                    self.pendingChangeDelta.errors--;\n                    pendingDirty = true;\n                }\n                op.operations = null;\n                op.timeHeapHandle.cancel();\n                op.timeHeapHandle = null;\n            } else if (expireTime < now && heap.lastRun > expireTime) {\n                self.logger.warn('stale tombstone', op.extendLogInfo({\n                    direction: direction,\n                    opKey: id,\n                    now: now,\n                    staleDelta: op.time + op.timeout - now,\n                    expireTime: expireTime,\n                    heapLastRun: heap.lastRun\n                }));\n                delete ops[id];\n                if (op.isPendingError) {\n                    self.pending.errors--;\n                    self.pendingChangeDelta.errors--;\n                    pendingDirty = true;\n                }\n                op.operations = null;\n                op.timeHeapHandle.cancel();\n                op.timeHeapHandle = null;\n            }\n        }\n\n        setImmediate(deferNextOp);\n\n        function deferNextOp() {\n            nextOp(opKeys, i + 1, done);\n        }\n    }\n\n    if (pendingDirty) {\n        self.pendingChangeEvent.emit(self, self.pendingChangeDelta);\n    }\n    self.pendingChangeDelta = null;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/root_peers.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\nvar extend = require('xtend');\n\nvar TChannelPeersBase = require('./peers_base.js');\nvar TChannelPeer = require('./peer');\n\nfunction TChannelRootPeers(channel, options) {\n    TChannelPeersBase.call(this, channel, options);\n    this.allocPeerEvent = this.defineEvent('allocPeer');\n    this.peerOptions = this.options.peerOptions || {};\n}\n\ninherits(TChannelRootPeers, TChannelPeersBase);\n\nTChannelRootPeers.prototype.close = function close(callback) {\n    var self = this;\n\n    var peers = self.values();\n    TChannelPeersBase.prototype.close.call(self, peers, callback);\n};\n\nTChannelRootPeers.prototype.add = function add(hostPort, options) {\n    /*eslint max-statements: [2, 25]*/\n    var self = this;\n\n    var peer = self._map[hostPort];\n    if (peer) {\n        return peer;\n    }\n\n    options = options || extend({}, self.peerOptions);\n    options.preferConnectionDirection = self.preferConnectionDirection;\n    peer = new TChannelPeer(self.channel, hostPort, options);\n    self.allocPeerEvent.emit(self, peer);\n\n    self._map[hostPort] = peer;\n    self._keys.push(hostPort);\n\n    return peer;\n};\n\nTChannelRootPeers.prototype.clear = function clear() {\n    var self = this;\n\n    var names = Object.keys(self.channel.subChannels);\n    for (var i = 0; i < names.length; i++) {\n        var subChannel = self.channel.subChannels[names[i]];\n        subChannel.peers.clear();\n    }\n\n    self._map = Object.create(null);\n    self._keys = [];\n};\n\nTChannelRootPeers.prototype._delete = function _del(peer) {\n    var self = this;\n\n    var names = Object.keys(self.channel.subChannels);\n    for (var i = 0; i < names.length; i++) {\n        var subChannel = self.channel.subChannels[names[i]];\n        subChannel.peers._delete(peer);\n    }\n\n    delete self._map[peer.hostPort];\n    var index = self._keys.indexOf(peer.hostPort);\n    popout(self._keys, index);\n};\n\nTChannelRootPeers.prototype.choosePeer = function choosePeer(req) {\n    return null;\n};\n\nfunction popout(array, i) {\n    if (!array.length) {\n        return;\n    }\n\n    var j = array.length - 1;\n    if (i !== j) {\n        var tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    array.pop();\n}\n\nmodule.exports = TChannelRootPeers;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/peers_base.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\nvar setImmediate = require('timers').setImmediate;\nvar EventEmitter = require('./lib/event_emitter');\n\nfunction TChannelPeersBase(channel, options) {\n    EventEmitter.call(this);\n    this.channel = channel;\n    this.logger = this.channel.logger;\n    this.options = options || {};\n    this._map = Object.create(null);\n    this._keys = [];\n    this.preferConnectionDirection = this.options.preferConnectionDirection || 'any';\n}\n\ninherits(TChannelPeersBase, EventEmitter);\n\nTChannelPeersBase.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    info = self.channel.extendLogInfo(info);\n\n    return info;\n};\n\nTChannelPeersBase.prototype.close = function close(peers, callback) {\n    var self = this;\n\n    var counter = peers.length + 1;\n    peers.forEach(function eachPeer(peer) {\n        peer.close(onClose);\n    });\n    self.clear();\n    onClose();\n\n    function onClose() {\n        if (--counter <= 0) {\n            if (counter < 0) {\n                self.logger.error('closed more peers than expected', {\n                    counter: counter\n                });\n            }\n            callback();\n        }\n    }\n};\n\nTChannelPeersBase.prototype.sanitySweep =\nfunction sanitySweep(callback) {\n    var self = this;\n\n    nextPeer(self.values(), 0, callback);\n\n    function nextPeer(peers, i, done) {\n        if (i >= peers.length) {\n            done(null);\n            return;\n        }\n\n        var peer = peers[i];\n\n        nextConn(peer.connections, 0, function connSweepDone(err) {\n            if (err) {\n                done(err);\n                return;\n            }\n            setImmediate(deferNextPeer);\n        });\n\n        function deferNextPeer() {\n            nextPeer(peers, i + 1, done);\n        }\n    }\n\n    function nextConn(conns, i, done) {\n        if (i >= conns.length) {\n            done(null);\n            return;\n        }\n\n        var conn = conns[i];\n        conn.ops.sanitySweep(function opsSweepDone() {\n            setImmediate(deferNextConn);\n        });\n\n        function deferNextConn() {\n            nextConn(conns, i + 1, done);\n        }\n    }\n};\n\nTChannelPeersBase.prototype.get = function get(hostPort) {\n    var self = this;\n\n    return self._map[hostPort] || null;\n};\n\nTChannelPeersBase.prototype.keys = function keys() {\n    var self = this;\n\n    return self._keys.slice();\n};\n\nTChannelPeersBase.prototype.values = function values() {\n    var self = this;\n\n    var keys = self._keys;\n    var ret = new Array(keys.length);\n    for (var i = 0; i < keys.length; i++) {\n        ret[i] = self._map[keys[i]];\n    }\n\n    return ret;\n};\n\nTChannelPeersBase.prototype.entries = function entries() {\n    var self = this;\n\n    var keys = self._keys;\n    var ret = new Array(keys.length);\n    for (var i = 0; i < keys.length; i++) {\n        ret[i] = [keys[i], self._map[keys[i]]];\n    }\n    return ret;\n};\n\nTChannelPeersBase.prototype.delete = function del(hostPort) {\n    var self = this;\n    var peer = self._map[hostPort];\n\n    if (!peer) {\n        return null;\n    }\n\n    self._delete(peer);\n\n    return peer;\n};\n\nmodule.exports = TChannelPeersBase;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/peer.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\nvar EventEmitter = require('./lib/event_emitter');\nvar stat = require('./stat-tags.js');\nvar net = require('net');\n\nvar TChannelConnection = require('./connection');\nvar HostPort = require('./host-port.js');\nvar errors = require('./errors');\nvar Request = require('./request');\nvar PreferOutgoing = require('./peer_score_strategies.js').PreferOutgoing;\nvar NoPreference = require('./peer_score_strategies.js').NoPreference;\nvar PreferIncoming = require('./peer_score_strategies.js').PreferIncoming;\nvar Range = require('./range');\nvar PeerDrain = require('./drain.js').PeerDrain;\nvar ObjectPool = require('./lib/object_pool');\n\nvar DEFAULT_REPORT_INTERVAL = 1000;\nvar INITIAL_CONN_ATTEMPT_DELAY = 5000;\nvar CONN_ATTEMPT_DELAY_MULTIPLER = 2;\nvar MAX_CONN_ATTEMPT_DELAY = 30 * 1000;\n\n/*eslint max-statements: [2, 40]*/\nfunction TChannelPeer(channel, hostPort, options) {\n    assert(hostPort !== '0.0.0.0:0', 'Cannot create ephemeral peer');\n\n    options = options || {};\n    EventEmitter.call(this);\n\n    this.stateChangedEvent = this.defineEvent('stateChanged');\n    this.allocConnectionEvent = this.defineEvent('allocConnection');\n    this.removeConnectionEvent = this.defineEvent('removeConnection');\n    this.deltaOutConnectionEvent = this.defineEvent('deltaOutConnection');\n\n    this.channel = channel;\n    this.socketInitTimeout = channel.initTimeout;\n    this.logger = this.channel.logger;\n    this.timers = this.channel.timers;\n    this.random = this.channel.random;\n    this.hostPort = hostPort;\n    this.connections = [];\n    this.pendingIdentified = 0;\n    this.heapElements = [];\n    this.scoreStrategy = null;\n    this.draining = null;\n    this.boundOnIdentified = onIdentified;\n    this.boundOnConnectionError = onConnectionError;\n    this.boundOnConnectionClose = onConnectionClose;\n    this.boundOnPendingChange = onPendingChange;\n    this.scoreRange = null;\n\n    // Timestamp when next conn attempt is allowed\n    this.nextConnAttemptTime = 0;\n    // How long to delay conn attempt by on failure (ms)\n    this.nextConnAttemptDelay = 0;\n    // Whether we are doing a connection attempt\n    this.hasConnectionAttempt = false;\n\n    this.waitForIdentifiedListeners = [];\n\n    this.reportInterval = options.reportInterval || DEFAULT_REPORT_INTERVAL;\n    if (this.reportInterval > 0 && this.channel.emitConnectionMetrics) {\n        this.reportTimer = this.timers.setTimeout(\n            onReport, this.reportInterval\n        );\n    }\n\n    this.connectionAttemptDelay = this.channel.connectionAttemptDelay ||\n        INITIAL_CONN_ATTEMPT_DELAY;\n    this.maxConnectionAttemptDelay = this.channel.maxConnectionAttemptDelay ||\n        MAX_CONN_ATTEMPT_DELAY;\n\n    this.setPreferConnectionDirection(options.preferConnectionDirection || 'any');\n\n    var self = this;\n\n    function onIdentified(_, conn) {\n        self.onIdentified(conn);\n    }\n\n    function onConnectionError(err, conn) {\n        self.onConnectionError(err, conn);\n    }\n\n    function onConnectionClose(_, conn) {\n        self.onConnectionClose(conn);\n    }\n\n    function onPendingChange(pending, conn) {\n        self.onPendingChange(conn, pending);\n    }\n\n    function onReport() {\n        if (!self.hostPort) {\n            return;\n        }\n\n        var count = self.countConnections('out');\n        if (self.channel.emitConnectionMetrics) {\n            self.channel.emitFastStat(\n                'tchannel.connections.active',\n                'gauge',\n                count,\n                new stat.ConnectionsActiveTags(\n                    self.channel.hostPort,\n                    self.hostPort\n                )\n            );\n        }\n\n        self.reportTimer = self.timers.setTimeout(\n            onReport, self.reportInterval\n        );\n    }\n}\n\ninherits(TChannelPeer, EventEmitter);\n\nTChannelPeer.prototype.DRAIN_GOAL_NOOP = PeerDrain.GOAL_NOOP;\nTChannelPeer.prototype.DRAIN_GOAL_CLOSE_DRAINED = PeerDrain.GOAL_CLOSE_DRAINED;\nTChannelPeer.prototype.DRAIN_GOAL_CLOSE_PEER = PeerDrain.GOAL_CLOSE_PEER;\n\nTChannelPeer.prototype.toString =\nfunction toString() {\n    var self = this;\n    return 'TChannelPeer(' + self.hostPort + ')';\n};\n\nTChannelPeer.prototype.inspect =\nfunction inspectPeer() {\n    var self = this;\n    return 'TChannelPeer(' + inspect(self.extendLogInfo({})) + ')';\n};\n\nTChannelPeer.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    info.hostPort = self.hostPort;\n    info.peerDraining = !!self.draining;\n    info.scoreRange = self.scoreRange;\n\n    if (self.draining) {\n        self.draining.extendLogInfo(info);\n    }\n\n    return info;\n};\n\nTChannelPeer.prototype.drain =\nfunction drain(options, callback) {\n    var self = this;\n    assert(!self.draining, 'cannot double drain a peer');\n    self.draining = new PeerDrain(self, options, callback);\n    self.draining.start();\n};\n\nTChannelPeer.prototype.clearDrain =\nfunction clearDrain(reason) {\n    var self = this;\n\n    if (self.draining) {\n        self.draining.stop(reason);\n        self.draining = null;\n    }\n};\n\nTChannelPeer.prototype.setMaxTombstoneTTL =\nfunction setMaxTombstoneTTL(ttl) {\n    var self = this;\n\n    for (var i = 0; i < self.connections.length; i++) {\n        var conn = self.connections[i];\n        conn.ops.setMaxTombstoneTTL(ttl);\n    }\n};\n\nTChannelPeer.prototype.setPreferConnectionDirection = function setPreferConnectionDirection(direction) {\n    var self = this;\n    if (self.preferConnectionDirection === direction) {\n        return;\n    }\n\n    self.preferConnectionDirection = direction;\n    if (self.preferConnectionDirection === 'out') {\n        self.setScoreStrategy(PreferOutgoing);\n    } else if (self.preferConnectionDirection === 'in') {\n        self.setScoreStrategy(PreferIncoming);\n    } else {\n        self.setScoreStrategy(NoPreference);\n    }\n\n    self.invalidateScore('setPreferConnectionDirection');\n};\n\nTChannelPeer.prototype.setScoreStrategy = function setScoreStrategy(ScoreStrategy) {\n    var self = this;\n\n    self.scoreStrategy = new ScoreStrategy(self);\n};\n\nTChannelPeer.prototype.invalidateScore = function invalidateScore(reason) {\n    var self = this;\n\n    self.scoreRange = self.computeScoreRange();\n\n    if (!self.heapElements.length) {\n        return;\n    }\n\n    var info = self.channel.peerScoredEvent ? {\n        peer: self,\n        reason: reason || 'unknown',\n        score: 0,\n        oldScores: [],\n        scores: []\n    } : null;\n\n    var range = self.scoreRange;\n    for (var i = 0; i < self.heapElements.length; i++) {\n        var el = self.heapElements[i];\n        if (info) {\n            info.oldScores.push(el.range);\n            info.scores.push(range);\n        }\n        el.rescore();\n    }\n\n    if (info) {\n        self.channel.peerScoredEvent.emit(self, info);\n    }\n};\n\nTChannelPeer.prototype.isConnected = function isConnected(direction, identified) {\n    var self = this;\n\n    if (identified === undefined) {\n        identified = true;\n    }\n    for (var i = 0; i < self.connections.length; i++) {\n        var conn = self.connections[i];\n        if (direction && conn.direction !== direction) {\n            continue;\n        } else if (conn.closing) {\n            continue;\n        } else if (conn.remoteName !== null || !identified) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nTChannelPeer.prototype.closeDrainedConnections =\nfunction closeDrainedConnections(callback) {\n    var self = this;\n\n    var counter = 1;\n    var conns = self.connections.slice(0);\n\n    for (var i = 0; i < conns.length; i++) {\n        var conn = conns[i];\n        if (conn.draining) {\n            counter++;\n            conn.close(onClose);\n        }\n    }\n    onClose();\n\n    function onClose() {\n        if (--counter <= 0) {\n            if (counter < 0) {\n                self.logger.error('closed more peer sockets than expected', {\n                    counter: counter\n                });\n            }\n            callback(null);\n        }\n    }\n};\n\nTChannelPeer.prototype.close =\nfunction close(callback) {\n    var self = this;\n\n    if (self.reportTimer) {\n        self.timers.clearTimeout(self.reportTimer);\n        self.reportTimer = null;\n    }\n\n    var conns = self.connections.slice(0);\n    var counter = conns.length;\n    if (counter) {\n        for (var i = 0; i < conns.length; i++) {\n            conns[i].close(onClose);\n        }\n    } else {\n        callback(null);\n    }\n    function onClose() {\n        if (--counter <= 0) {\n            if (counter < 0) {\n                self.logger.error('closed more peer sockets than expected', {\n                    counter: counter\n                });\n            }\n            callback(null);\n        }\n    }\n};\n\nTChannelPeer.prototype.getInConnection = function getInConnection(preferIdentified) {\n    var self = this;\n    var candidate = null;\n    for (var i = 0; i < self.connections.length; i++) {\n        var conn = self.connections[i];\n        if (conn.closing) {\n            continue;\n        }\n        if (!preferIdentified) {\n            return conn; // user doesn't care, take first incoming\n        }\n        if (conn.remoteName) {\n            return conn; // user wanted an identified channel, and we found one\n        }\n        if (!candidate) {\n            candidate = conn; // we'll fallback to returning this if we can't find an identified one\n        }\n    }\n    return candidate;\n};\n\nTChannelPeer.prototype.getIdentifiedInConnection = function getIdentifiedInConnection() {\n    var self = this;\n    return self.getInConnection(true);\n};\n\nTChannelPeer.prototype.getOutConnection = function getOutConnection(preferIdentified) {\n    var self = this;\n    var candidate = null;\n    for (var i = self.connections.length - 1; i >= 0; i--) {\n        var conn = self.connections[i];\n        if (conn.closing) {\n            continue;\n        }\n        if (!preferIdentified) {\n            return conn; // user doesn't care, take last outgoing\n        }\n        if (conn.remoteName) {\n            return conn; // user wanted an identified channel, and we found one\n        }\n        if (!candidate) {\n            candidate = conn; // we'll fallback to returning this if we can't find an identified one\n        }\n    }\n    return candidate;\n};\n\nTChannelPeer.prototype.getIdentifiedOutConnection = function getIdentifiedOutConnection() {\n    var self = this;\n    return self.getOutConnection(true);\n};\n\nTChannelPeer.prototype.countConnections = function countConnections(direction) {\n    var self = this;\n    if (!direction) {\n        return self.connections.length;\n    }\n\n    var count = 0;\n    for (var i = 0; i < self.connections.length; i++) {\n        var conn = self.connections[i];\n        if (conn.direction === direction) {\n            count++;\n        }\n    }\n\n    return count;\n};\n\n// ensures that a connection exists\nTChannelPeer.prototype.connect =\nfunction connect(outOnly) {\n    var self = this;\n    var conn = null;\n    if (self.preferConnectionDirection === 'in' && !outOnly) {\n        conn = self.getIdentifiedInConnection();\n    } else {\n        conn = self.getIdentifiedOutConnection();\n    }\n\n    if (!conn || (outOnly && conn.direction !== 'out')) {\n        var socket = self.makeOutSocket();\n        conn = self.makeOutConnection(socket);\n        self.addConnection(conn);\n    }\n    return conn;\n};\n\n// ensures that an outbound connection exists\nTChannelPeer.prototype.connectTo = function connectTo() {\n    var self = this;\n    return self.connect(true);\n};\n\nTChannelPeer.prototype.tryConnect = function tryConnect() {\n    var self = this;\n\n    var connectTime = Date.now();\n    if (connectTime < self.nextConnAttemptTime ||\n        self.hasConnectionAttempt\n    ) {\n        return;\n    }\n    self.hasConnectionAttempt = true;\n\n    var conn = this.getOutConnection();\n    if (!conn || conn.direction !== 'out') {\n        conn = this.connectTo();\n    }\n\n    this.waitForIdentified(conn, onIdentified);\n\n    function onIdentified(err) {\n        self.hasConnectionAttempt = false;\n\n        if (!err) {\n            self.nextConnAttemptDelay = 0;\n            self.nextConnAttemptTime = 0;\n            return;\n        }\n\n        if (self.nextConnAttemptDelay === 0) {\n            self.nextConnAttemptDelay = self.connectionAttemptDelay;\n        } else {\n            self.nextConnAttemptDelay *= CONN_ATTEMPT_DELAY_MULTIPLER;\n            // Add some amount of fuzz, +-100ms\n            self.nextConnAttemptDelay += Math.floor(100 * (Math.random() - 0.5));\n\n            self.nextConnAttemptDelay = Math.min(\n                self.nextConnAttemptDelay, self.maxConnectionAttemptDelay\n            );\n        }\n\n        var afterConnect = Date.now();\n        if (self.nextConnAttemptTime < afterConnect) {\n            // When in the past set next attempt to now + delay\n            self.nextConnAttemptTime = afterConnect + self.nextConnAttemptDelay;\n        } else {\n            // When in the future; leave it alone.\n        }\n    }\n};\n\nTChannelPeer.prototype.waitForIdentified =\nfunction waitForIdentified(conn, callback) {\n    var self = this;\n\n    if (typeof conn === 'function' && !callback) {\n        callback = conn;\n        conn = self.connect();\n    }\n\n    if (conn.closing) {\n        callback(conn.closeError);\n    } else if (conn.remoteName) {\n        callback(null);\n    } else {\n        return self._waitForIdentified(conn, callback);\n    }\n\n    return -1;\n};\n\nTChannelPeer.prototype._waitForIdentified =\nfunction _waitForIdentified(conn, callback) {\n    var self = this;\n    var called = false;\n\n    // Setup an ident descriptor so we can stop waiting for identified later\n    var slot = self.getIdentDescriptorSlot();\n    var descriptor = WaitForIdentifiedDescriptor.alloc();\n    descriptor.reset(\n        onConnectionClose,\n        onConnectionError,\n        onIdentified,\n        conn\n    );\n    self.waitForIdentifiedListeners[slot] = descriptor;\n\n    self.pendingIdentified++;\n    conn.errorEvent.on(onConnectionError);\n    conn.closeEvent.on(onConnectionClose);\n    conn.identifiedEvent.on(onIdentified);\n    self.invalidateScore('waitForIdentified');\n\n    return slot;\n\n    function onConnectionError(err) {\n        finish(err);\n    }\n\n    function onConnectionClose(err) {\n        finish(err);\n    }\n\n    function onIdentified() {\n        finish(null);\n    }\n\n    function finish(err) {\n        // Multiple events can trigger which causes double callback hilarity.\n        if (called) {\n            return;\n        }\n        called = true;\n\n        self.stopWaitingForIdentified(slot);\n        callback(err);\n    }\n};\n\nTChannelPeer.prototype.stopWaitingForIdentified =\nfunction stopWaitingForIdentified(slot) {\n    assert(typeof slot === 'number', 'stopWaitingForIdentified arg1 should be number');\n\n    if (slot === -1) {\n        // when connection was already identified, `waitForIdentified` will\n        // return -1\n        return;\n    }\n\n    var descriptor = this.waitForIdentifiedListeners[slot];\n    this.waitForIdentifiedListeners[slot] = null;\n\n    if (!descriptor || !descriptor.conn) {\n        return;\n    }\n\n    var conn = descriptor.conn;\n\n    conn.errorEvent.removeListener(descriptor.error);\n    conn.closeEvent.removeListener(descriptor.close);\n    conn.identifiedEvent.removeListener(descriptor.ident);\n    this.pendingIdentified = 0;\n    this.invalidateScore('waitForIdentified > finish');\n\n    descriptor.free();\n};\n\nTChannelPeer.prototype.getIdentDescriptorSlot =\nfunction getIdentDescriptorSlot() {\n    var i;\n    for (i = 0; i < this.waitForIdentifiedListeners.length; i++) {\n        if (this.waitForIdentifiedListeners[i] === null) {\n            return i;\n        }\n    }\n    return this.waitForIdentifiedListeners.length;\n};\n\nTChannelPeer.prototype.request = function peerRequest(options) {\n    var self = this;\n    options.timeout = options.timeout || Request.defaultTimeout;\n    return self.connect().request(options);\n};\n\nTChannelPeer.prototype.addConnection = function addConnection(conn) {\n    var self = this;\n    // TODO: first approx alert for self.connections.length > 2\n    // TODO: second approx support pruning\n    if (conn.direction === 'out') {\n        self.connections.push(conn);\n        self.deltaOutConnectionEvent.emit(self, 1);\n    } else {\n        self.connections.unshift(conn);\n    }\n\n    conn.errorEvent.on(self.boundOnConnectionError);\n    conn.closeEvent.on(self.boundOnConnectionClose);\n    conn.ops.pendingChangeEvent.on(self.boundOnPendingChange);\n\n    self._maybeInvalidateScore('addConnection');\n    if (!conn.remoteName) {\n        // TODO: could optimize if handler had a way of saying \"would a new\n        // identified connection change your Tier?\"\n        conn.identifiedEvent.on(self.boundOnIdentified);\n    }\n\n    if (!conn.draining) {\n        if (conn.channel.draining) {\n            conn.drain(conn.channel.drainReason, null);\n        } else if (self.draining) {\n            self.draining.drainConnection(conn);\n        }\n    }\n\n    return conn;\n};\n\nTChannelPeer.prototype.onIdentified =\nfunction onIdentified(conn) {\n    var self = this;\n\n    conn.identifiedEvent.removeListener(self.boundOnIdentified);\n    self._maybeInvalidateScore('addConnection > onIdentified');\n};\n\nTChannelPeer.prototype.onConnectionError =\nfunction onConnectionError(err, conn) {\n    var self = this;\n    self.removeConnectionFrom(err, conn);\n};\n\nTChannelPeer.prototype.onConnectionClose =\nfunction onConnectionClose(conn) {\n    var self = this;\n    self.removeConnectionFrom(null, conn);\n};\n\nTChannelPeer.prototype.onPendingChange =\nfunction onPendingChange() {\n    var self = this;\n\n    // TODO: it would be possible to a faster partial-recomputation based only\n    // on the change of pending for the this one connection. Note arguments are\n    // (conn, pending)\n    self._maybeInvalidateScore('pendingChange');\n};\n\nTChannelPeer.prototype.removeConnectionFrom =\nfunction removeConnectionFrom(err, conn) {\n    var self = this;\n\n    conn.closeEvent.removeListener(self.boundOnConnectionClose);\n    conn.errorEvent.removeListener(self.boundOnConnectionError);\n    conn.identifiedEvent.removeListener(self.boundOnIdentified);\n    conn.ops.pendingChangeEvent.removeListener(self.boundOnPendingChange);\n\n    if (err) {\n        var loggerInfo = conn.extendLogInfo({\n            error: err\n        });\n        var codeName = errors.classify(err);\n        if (codeName === 'Timeout' ||\n            codeName === 'NetworkError') {\n            self.logger.warn('Got a connection error', loggerInfo);\n        } else {\n            self.logger.error('Got an unexpected connection error', loggerInfo);\n        }\n    }\n\n    self.removeConnection(conn);\n};\n\nTChannelPeer.prototype.removeConnection = function removeConnection(conn) {\n    var self = this;\n\n    var ret = null;\n    var isRemoved = false;\n\n    var index = self.connections ? self.connections.indexOf(conn) : -1;\n    if (index !== -1) {\n        ret = self.connections.splice(index, 1)[0];\n        isRemoved = conn.direction === 'out';\n    }\n\n    self._maybeInvalidateScore('removeConnection');\n\n    self.removeConnectionEvent.emit(self, conn);\n    if (isRemoved) {\n        self.deltaOutConnectionEvent.emit(self, -1);\n    }\n    return ret;\n};\n\nTChannelPeer.prototype.makeOutSocket = function makeOutSocket() {\n    var self = this;\n\n    var reason = HostPort.validateHostPort(self.hostPort, false);\n    if (reason) {\n        assert(false, reason);\n    }\n\n    var parts = self.hostPort.split(':');\n    var host = parts[0];\n    var port = parseInt(parts[1], 10);\n\n    var socket = net.createConnection({\n        host: host,\n        port: port\n    });\n    return socket;\n};\n\nTChannelPeer.prototype.makeOutConnection = function makeOutConnection(socket) {\n    var self = this;\n    var chan = self.channel.topChannel || self.channel;\n    var conn = new TChannelConnection(\n        chan, socket, 'out', self.hostPort, this.socketInitTimeout\n    );\n    self.allocConnectionEvent.emit(self, conn);\n    return conn;\n};\n\n// Returns a range from 0 to 1, where it is preferable to use\n// a peer with a higher score over one with a lower score.\n// This range is divided among an infinite set of subranges corresponding\n// to peers with the same number of pending requests.\n// So, the range (1/2, 1] is reserved for peers with 0 pending connections.\n// The range (1/4, 1/2] is reserved for peers with 1 pending connections.\n// The range (1/8, 1/4] is reserved for peers with 2 pending connections.\n// Ad nauseam.\n// Within each equivalence class, each peer receives a uniform random\n// value.\n//\n// The previous score was a weighted random variable:\n//   random() ** (1 + pending)\n// This had the attribute that a less loaded peer was merely more likely to\n// be chosen over a more loaded peer.\n// We observed with the introduction of a heap, that a less favored peer\n// would have its score less frequently re-evaluated.\n// An emergent behavior was that scores would, over time, be squeezed\n// toward zero and the least favored peer would remain the least favored\n// for ever increasing durations.\n//\n// This remains true with this algorithm, within each equivalence class.\nTChannelPeer.prototype.pendingWeightedRange = function pendingWeightedRange() {\n    var self = this;\n\n    var pending = self.countPending();\n    var max = Math.pow(0.5, pending);\n    var min = max / 2;\n\n    return new Range(min, max);\n};\n\nTChannelPeer.prototype.countPending = function countPending() {\n    var self = this;\n\n    var pending = self.pendingIdentified;\n\n    for (var index = 0; index < self.connections.length; index++) {\n        var connPending = self.connections[index].ops.getPending();\n\n        pending += connPending.out;\n        pending += connPending.errors;\n    }\n\n    return pending;\n};\n\n// TODO: on connection #getScore impacting event\n// - on identified\n\n// Called on connection change event\nTChannelPeer.prototype._maybeInvalidateScore =\nfunction _maybeInvalidateScore(reason) {\n    var self = this;\n\n    if (self.scoreStrategy.getTier() !== self.scoreStrategy.lastTier) {\n        self.invalidateScore(reason);\n    }\n};\n\nTChannelPeer.prototype.getScoreRange = function getScoreRange() {\n    var self = this;\n\n    return self.scoreRange;\n};\n\nTChannelPeer.prototype.computeScoreRange = function computeScoreRange() {\n    var self = this;\n\n    var range = self.scoreStrategy.getScoreRange();\n    range.multiply(self.pendingWeightedRange());\n\n    return range;\n};\n\nTChannelPeer.prototype.getScore = function getScore() {\n    // This is INLINED into peer_heap.js#115\n    var self = this;\n    var diff = self.scoreRange.hi - self.scoreRange.lo;\n    var rand = self.random();\n    if (rand === 0) {\n        rand = 1;\n    }\n    return self.scoreRange.lo + diff * rand;\n};\n\nmodule.exports = TChannelPeer;\n\nfunction WaitForIdentifiedDescriptor(close, error, ident, conn) {\n    this.close = null;\n    this.error = null;\n    this.ident = null;\n    this.conn = null;\n}\n\nWaitForIdentifiedDescriptor.prototype.reset =\nfunction reset(close, error, ident, conn) {\n    this.close = close;\n    this.error = error;\n    this.ident = ident;\n    this.conn = conn;\n};\n\nWaitForIdentifiedDescriptor.prototype.clear =\nfunction clear() {\n    this.close = null;\n    this.error = null;\n    this.ident = null;\n    this.conn = null;\n};\n\nObjectPool.setup({Type: WaitForIdentifiedDescriptor, maxSize: 100});\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/peer_score_strategies.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar Range = require('./range');\n\nmodule.exports.PreferOutgoing = PreferOutgoing;\nmodule.exports.NoPreference = NoPreference;\nmodule.exports.PreferIncoming = PreferIncoming;\n\nfunction PreferOutgoing(peer) {\n    this.peer = peer;\n    this.lastTier = this.getTier();\n}\n\nPreferOutgoing.UNCONNECTED = 0;\nPreferOutgoing.ONLY_INCOMING = 1;\nPreferOutgoing.FRESH_OUTGOING = 2;\nPreferOutgoing.READY_OUTGOING = 3;\n\nPreferOutgoing.prototype.getTier = function getTier() {\n    var inconn = this.peer.getInConnection();\n    var outconn = this.peer.getIdentifiedOutConnection();\n\n    if (!inconn && !outconn) {\n        return PreferOutgoing.UNCONNECTED;\n    } else if (!outconn || outconn.direction !== 'out') {\n        return PreferOutgoing.ONLY_INCOMING;\n    } else if (outconn.remoteName === null) {\n        return PreferOutgoing.FRESH_OUTGOING;\n    } else {\n        return PreferOutgoing.READY_OUTGOING;\n    }\n};\n\nPreferOutgoing.prototype.getScoreRange = function getScoreRange() {\n    // space:\n    //   [0.1, 0.2)  peers with zero connections\n    //   [0.2, 0.4)  peers with no identified outgoing connection\n    //   [0.4, 1.0)  identified outgoing connections\n    var tier = this.getTier();\n    this.lastTier = tier;\n    switch (tier) {\n        default:\n            /* falls through */\n        case PreferOutgoing.UNCONNECTED:\n            return new Range(0.1, 0.2);\n        case PreferOutgoing.ONLY_INCOMING:\n            /* falls through */\n        case PreferOutgoing.FRESH_OUTGOING:\n            return new Range(0.2, 0.4);\n        case PreferOutgoing.READY_OUTGOING:\n            return new Range(0.4, 1.0);\n    }\n};\n\nfunction NoPreference(peer) {\n    this.peer = peer;\n    this.lastTier = this.getTier();\n}\n\nNoPreference.UNCONNECTED = 0;\nNoPreference.CONNECTED = 1;\nNoPreference.IDENTIFIED = 2;\n\nNoPreference.prototype.getTier = function getTier() {\n    var conn = this.peer.getIdentifiedOutConnection();\n\n    if (!conn) {\n        return NoPreference.UNCONNECTED;\n    } else if (conn.remoteName === null) {\n        return NoPreference.CONNECTED;\n    } else {\n        return NoPreference.IDENTIFIED;\n    }\n};\n\nNoPreference.prototype.getScoreRange = function getScoreRange() {\n    // space:\n    //   [0.1, 0.2)  peers with zero connections\n    //   (0.2, 0.4]  peers with no identified connection\n    //   (0.4, 1.0]  identified connections\n    var tier = this.getTier();\n    this.lastTier = tier;\n    switch (tier) {\n        default:\n            /* falls through */\n        case NoPreference.UNCONNECTED:\n            return new Range(0.1, 0.2);\n        case NoPreference.CONNECTED:\n            return new Range(0.2, 0.4);\n        case NoPreference.IDENTIFIED:\n            return new Range(0.4, 1.0);\n    }\n};\n\nfunction PreferIncoming(peer) {\n    this.peer = peer;\n    this.lastTier = this.getTier();\n}\n\nPreferIncoming.UNCONNECTED = 0;\nPreferIncoming.ONLY_OUTGOING = 1;\nPreferIncoming.FRESH_INCOMING = 2;\nPreferIncoming.READY_INCOMING = 3;\n\nPreferIncoming.prototype.getTier = function getTier() {\n    var outconn = this.peer.getOutConnection();\n    var inconn = this.peer.getIdentifiedInConnection();\n\n    if (!inconn && !outconn) {\n        return PreferIncoming.UNCONNECTED;\n    } else if (!inconn || inconn.direction !== 'in') {\n        return PreferIncoming.ONLY_OUTGOING;\n    } else if (inconn.remoteName === null) {\n        return PreferIncoming.FRESH_INCOMING;\n    } else {\n        return PreferIncoming.READY_INCOMING;\n    }\n};\n\nPreferIncoming.prototype.getScoreRange = function getScoreRange() {\n    // space:\n    //   [0.1, 0.2)  peers with zero connections\n    //   [0.2, 0.4)  peers with no identified incoming connection\n    //   [0.4, 1.0)  identified incoming connections\n    var tier = this.getTier();\n    this.lastTier = tier;\n    switch (tier) {\n        default:\n            /* falls through */\n        case PreferIncoming.UNCONNECTED:\n            return new Range(0.1, 0.2);\n        case PreferIncoming.ONLY_OUTGOING:\n            /* falls through */\n        case PreferIncoming.FRESH_INCOMING:\n            return new Range(0.2, 0.4);\n        case PreferIncoming.READY_INCOMING:\n            return new Range(0.4, 1.0);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/range.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Range;\n\nfunction Range(lo, hi) {\n    this.lo = lo;\n    this.hi = hi;\n}\n\n// Scale this range by another range\nRange.prototype.multiply = function multiply(range) {\n    var diff = this.hi - this.lo;\n    this.hi = this.lo + (range.hi * diff);\n    this.lo += (range.lo * diff);\n};\n\nRange.prototype.inspect =\nRange.prototype.toString = function toString() {\n    return 'Range(' + this.lo + ', ' + this.hi + ')';\n};\n\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/drain.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar process = require('process');\nvar CountedReadySignal = require('ready-signal/counted');\nvar errors = require('./errors');\n\nvar GOAL_NOOP = 'noop';\nvar GOAL_CLOSE_DRAINED = 'close drained connections';\nvar GOAL_CLOSE_PEER = 'close peer';\n\nPeerDrain.GOAL_NOOP = GOAL_NOOP;\nPeerDrain.GOAL_CLOSE_DRAINED = GOAL_CLOSE_DRAINED;\nPeerDrain.GOAL_CLOSE_PEER = GOAL_CLOSE_PEER;\n\n// TODO: subsume and unify with channel draining\n\nfunction PeerDrain(peer, options, callback) {\n    var chan = peer.channel.topChannel || peer.channel;\n\n    assert(options, 'options is required');\n    assert(options.reason, 'a reason is required');\n    assert(!chan.draining, 'cannot drain a peer while channel is draining');\n    assert(!options.goal ||\n           options.goal === GOAL_NOOP ||\n           options.goal === GOAL_CLOSE_DRAINED ||\n           options.goal === GOAL_CLOSE_PEER,\n           'expected a valid goal (if any)');\n\n    this.goal = options.goal || PeerDrain.GOAL_NOOP;\n    this.channel = chan;\n    this.peer = peer;\n    this.timeout = options.timeout || 0;\n    this.reason = options.reason;\n    this.direction = options.direction || 'both';\n    this.callback = callback || null;\n    this.timer = null;\n    this.drained = null;\n    this.startedAt = 0;\n    this.stoppedAt = 0;\n    this.finishedAt = 0;\n    this.thenFinish = thenFinish;\n\n    var self = this;\n\n    function thenFinish(err) {\n        var now = self.channel.timers.now();\n        self.finish(err, now);\n    }\n}\n\nPeerDrain.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    info.drainGoal = self.goal;\n    info.drainReason = self.reason;\n    info.drainTimeout = self.timeout;\n    info.drainDirection = self.direction;\n    info.drainStartedAt = self.startedAt;\n    info.drainStoppedAt = self.stoppedAt;\n    info.drainFinishedAt = self.finishedAt;\n    info.drainCounter = self.drained && self.drained.counter;\n\n    return info;\n};\n\nPeerDrain.prototype.start =\nfunction start() {\n    var self = this;\n\n    self.startedAt = self.channel.timers.now();\n    self.drained = CountedReadySignal(1);\n\n    var timer = null;\n    if (self.timeout) {\n        if (self.timer) {\n            self.channel.timers.clearTimeout(self.timer);\n        }\n        timer = self.channel.timers.setTimeout(drainTimedOut, self.timeout);\n        self.timer = timer;\n    }\n\n    process.nextTick(self.drained.signal);\n    self.drained(drainDone);\n\n    for (var i = 0; i < self.peer.connections.length; i++) {\n        self.drainConnection(self.peer.connections[i]);\n    }\n\n    self.peer.logger.info('draining peer', self.peer.extendLogInfo(\n        self.extendLogInfo({})\n    ));\n\n    function drainDone() {\n        var now = self.channel.timers.now();\n        finish(null, now);\n    }\n\n    function drainTimedOut() {\n        if (self.finishedAt) {\n            return;\n        }\n        var now = self.channel.timers.now();\n        finish(errors.PeerDrainTimedOutError({\n            direction: self.direction,\n            elapsed: now - self.startedAt,\n            timeout: self.timeout\n        }), now);\n    }\n\n    function finish(err, now) {\n        if (timer) {\n            self.channel.timers.clearTimeout(timer);\n            if (self.timer === timer) {\n                self.timer = null;\n            }\n        }\n\n        switch (self.goal) {\n            case GOAL_NOOP:\n                self.finish(err, now);\n                break;\n\n            case GOAL_CLOSE_DRAINED:\n                self.thenCloseDrained(err);\n                break;\n\n            case GOAL_CLOSE_PEER:\n                self.thenClosePeer(err);\n                break;\n\n            default:\n                self.finish(err || new Error('invalid drain goal'), now);\n        }\n    }\n};\n\nPeerDrain.prototype.stop =\nfunction stop(reason) {\n    var self = this;\n\n    self.peer.logger.info('stopping peer drain', self.peer.extendLogInfo(\n        self.extendLogInfo({\n            stopReason: reason\n        })\n    ));\n\n    self.stoppedAt = self.channel.timers.now();\n\n    if (self.timer) {\n        self.channel.timers.clearTimeout(self.timer);\n        self.timer = null;\n    }\n\n    self.callback = null;\n};\n\nPeerDrain.prototype.thenCloseDrained =\nfunction thenCloseDrained(err) {\n    var self = this;\n\n    if (err) {\n        var info = self.peer.extendLogInfo(self.extendLogInfo({\n            error: err\n        }));\n\n        if (err.type === 'tchannel.drain.peer.timed-out') {\n            self.peer.logger.warn(\n                'drain timed out, force closing connections',\n                info);\n        } else {\n            self.peer.logger.warn(\n                'unexpected error draining connections, closing anyhow',\n                info);\n        }\n    }\n\n    self.peer.closeDrainedConnections(self.thenFinish);\n};\n\nPeerDrain.prototype.thenClosePeer =\nfunction thenClosePeer(err) {\n    var self = this;\n\n    if (err) {\n        var info = self.peer.extendLogInfo(self.extendLogInfo({\n            error: err\n        }));\n\n        if (err.type === 'tchannel.drain.peer.timed-out') {\n            self.peer.logger.warn(\n                'drain timed out, force closing peer',\n                info);\n        } else {\n            self.peer.logger.warn(\n                'unexpected error draining connections, closing peer anyhow',\n                info);\n        }\n    }\n\n    self.peer.close(self.thenFinish);\n};\n\nPeerDrain.prototype.finish =\nfunction finish(err, now) {\n    var self = this;\n\n    if (!self.finishedAt) {\n        self.finishedAt = now;\n\n        if (self.callback) {\n            self.callback(err);\n            self.callback = null;\n        }\n    }\n};\n\nPeerDrain.prototype.drainConnection =\nfunction drainConnection(conn) {\n    var self = this;\n\n    if (self.direction === 'both' ||\n        self.direction === conn.direction) {\n        self.drained.counter++;\n        conn.drain(self.reason, self.drained.signal);\n    }\n};\n\nmodule.exports.PeerDrain = PeerDrain;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/sub_peers.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar inherits = require('util').inherits;\nvar setTimeout = require('timers').setTimeout;\nvar clearTimeout = require('timers').clearTimeout;\n\nvar TChannelPeersBase = require('./peers_base.js');\nvar PeerHeap = require('./peer_heap.js');\n\nvar REFRESH_TIMER = 60 * 1000;\n\nfunction TChannelSubPeers(channel, options) {\n    TChannelPeersBase.call(this, channel, options);\n\n    var self = this;\n    this.peerScoreThreshold = this.options.peerScoreThreshold || 0;\n    this.choosePeerWithHeap = channel.choosePeerWithHeap;\n    this.socketInitTimeout = channel.initTimeout;\n\n    this.hasMinConnections = typeof options.minConnections === 'number';\n    this.minConnections = options.minConnections;\n\n    this.currentConnectedPeers = 0;\n    this._heap = new PeerHeap(this, channel.random);\n\n    this.boundOnOutConnectionDelta = boundOnOutConnectionDelta;\n    this.boundOnRefreshConnectedPeers = boundOnRefreshConnectedPeers;\n\n    this.refreshTimer = null;\n    this.refreshConnectedPeersDelay = this.channel.refreshConnectedPeersDelay ||\n        REFRESH_TIMER;\n\n    if (this.hasMinConnections) {\n        this.refreshTimer = setTimeout(\n            this.boundOnRefreshConnectedPeers, this.refreshConnectedPeersDelay\n        );\n    }\n\n    function boundOnOutConnectionDelta(delta, peer) {\n        self.onOutConnectionDelta(peer, delta);\n    }\n\n    function boundOnRefreshConnectedPeers() {\n        self.refreshConnectedPeers();\n    }\n}\n\ninherits(TChannelSubPeers, TChannelPeersBase);\n\nTChannelSubPeers.prototype.refreshConnectedPeers =\nfunction refreshConnectedPeers() {\n    var peers = this.values();\n\n    var currentConnectedPeers = 0;\n    for (var i = 0; i < peers.length; i++) {\n        if (peers[i].countConnections('out') > 0) {\n            currentConnectedPeers++;\n        }\n    }\n\n    this.currentConnectedPeers = currentConnectedPeers;\n    this.refreshTimer = setTimeout(\n        this.boundOnRefreshConnectedPeers, this.refreshConnectedPeersDelay\n    );\n};\n\nTChannelSubPeers.prototype.onOutConnectionDelta =\nfunction onOutConnectionDelta(peer, delta) {\n    var connCount = peer.countConnections('out');\n\n    if (delta === 1 && connCount === 1) {\n        this.currentConnectedPeers++;\n    } else if (delta === -1 && connCount === 0) {\n        this.currentConnectedPeers--;\n    }\n};\n\nTChannelSubPeers.prototype.close = function close(callback) {\n    var self = this;\n\n    if (self.refreshTimer) {\n        clearTimeout(self.refreshTimer);\n    }\n\n    var peers = self.values();\n    TChannelPeersBase.prototype.close.call(self, peers, callback);\n};\n\nTChannelSubPeers.prototype.add = function add(hostPort, options) {\n    /* eslint max-statements: [2, 25]*/\n    var self = this;\n\n    var peer = self._map[hostPort];\n    if (peer) {\n        return peer;\n    }\n\n    var topChannel = self.channel.topChannel;\n\n    peer = topChannel.peers.add(hostPort, options);\n    peer.setPreferConnectionDirection(self.preferConnectionDirection);\n    peer.socketInitTimeout = this.socketInitTimeout;\n\n    if (peer.countConnections('out') > 0) {\n        this.currentConnectedPeers++;\n    }\n\n    peer.deltaOutConnectionEvent.on(self.boundOnOutConnectionDelta);\n\n    self._map[hostPort] = peer;\n    self._keys.push(hostPort);\n\n    var el = self._heap.add(peer);\n    peer.heapElements.push(el);\n\n    return peer;\n};\n\nTChannelSubPeers.prototype.clear = function clear() {\n    var self = this;\n\n    self._map = Object.create(null);\n    self._keys = [];\n    self._heap.clear();\n};\n\nTChannelSubPeers.prototype._delete = function _del(peer) {\n    var self = this;\n\n    var index = self._keys.indexOf(peer.hostPort);\n    if (index === -1) {\n        return;\n    }\n\n    if (peer.countConnections('out') > 0) {\n        this.currentConnectedPeers--;\n    }\n\n    peer.deltaOutConnectionEvent\n        .removeListener(self.boundOnOutConnectionDelta);\n\n    delete self._map[peer.hostPort];\n    popout(self._keys, index);\n\n    for (var i = 0; i < peer.heapElements.length; i++) {\n        var el = peer.heapElements[i];\n        if (el.heap === self._heap) {\n            el.heap.remove(el.index);\n            popout(peer.heapElements, i);\n            break;\n        }\n    }\n};\n\nTChannelSubPeers.prototype.setChoosePeerWithHeap = function setChoosePeerWithHeap(enabled) {\n    var self = this;\n\n    self.choosePeerWithHeap = enabled;\n};\n\nTChannelSubPeers.prototype.choosePeer = function choosePeer(req) {\n    var self = this;\n\n    if (self.choosePeerWithHeap) {\n        return self.chooseHeapPeer(req);\n    }\n\n    return self.chooseLinearPeer(req);\n};\n\n/*eslint max-statements: [2, 40]*/\nTChannelSubPeers.prototype.chooseLinearPeer = function chooseLinearPeer(req) {\n    /* eslint complexity: [2, 15]*/\n    var self = this;\n\n    var hosts = self._keys;\n    if (!hosts || !hosts.length) {\n        return null;\n    }\n\n    var threshold = self.peerScoreThreshold;\n\n    var selectedPeer = null;\n    var secondaryPeer = null;\n    var selectedScore = 0;\n    var secondaryScore = 0;\n\n    var notEnoughPeers = false;\n    if (this.hasMinConnections) {\n        notEnoughPeers = this.currentConnectedPeers < this.minConnections;\n    }\n\n    for (var i = 0; i < hosts.length; i++) {\n        var hostPort = hosts[i];\n        var peer = self._map[hostPort];\n\n        var shouldSkip = req && req.triedRemoteAddrs && req.triedRemoteAddrs[hostPort];\n        if (!shouldSkip) {\n            var isSecondary = notEnoughPeers && peer.isConnected('out');\n            var score = peer.getScore(req);\n\n            if (self.channel.topChannel.peerScoredEvent) {\n                self.channel.topChannel.peerScoredEvent.emit(peer, {\n                    peer: peer,\n                    reason: 'chooseLinearPeer',\n                    score: score\n                });\n            }\n\n            var want;\n            if (isSecondary) {\n                want = score > threshold && (\n                    secondaryPeer === null || score > secondaryScore\n                );\n            } else {\n                want = score > threshold &&\n                    (selectedPeer === null || score > selectedScore);\n            }\n\n            if (want) {\n                if (isSecondary) {\n                    secondaryPeer = peer;\n                    secondaryScore = score;\n                } else {\n                    selectedPeer = peer;\n                    selectedScore = score;\n                }\n            }\n        }\n    }\n\n    if (self.channel.topChannel.peerChosenEvent) {\n        self.channel.topChannel.peerChosenEvent.emit(self, {\n            mode: 'linear',\n            peer: selectedPeer\n        });\n    }\n\n    if (secondaryScore > selectedScore && selectedPeer) {\n        selectedPeer.tryConnect(noop);\n        return secondaryPeer;\n    }\n\n    return selectedPeer || secondaryPeer;\n};\n\nfunction noop() {}\n\nTChannelSubPeers.prototype.chooseHeapPeer = function chooseHeapPeer(req) {\n    var self = this;\n\n    var peer;\n    if ((req && req.triedRemoteAddrs)) {\n        peer = self._choosePeerSkipTried(req);\n    } else {\n        peer = self._heap.choose(self.peerScoreThreshold);\n    }\n\n    if (self.channel.topChannel.peerChosenEvent) {\n        self.channel.topChannel.peerChosenEvent.emit(self, {\n            mode: 'heap',\n            peer: peer\n        });\n    }\n\n    return peer;\n};\n\nTChannelSubPeers.prototype._choosePeerSkipTried =\nfunction _choosePeerSkipTried(req) {\n    var self = this;\n\n    return self._heap.choose(self.peerScoreThreshold, filterTriedPeers);\n\n    function filterTriedPeers(peer) {\n        var shouldSkip = req.triedRemoteAddrs[peer.hostPort];\n        return !shouldSkip;\n    }\n};\n\nfunction popout(array, i) {\n    if (!array.length) {\n        return;\n    }\n\n    var j = array.length - 1;\n    if (i !== j) {\n        var tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    array.pop();\n}\n\nmodule.exports = TChannelSubPeers;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/peer_heap.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\n\nmodule.exports = PeerHeap;\n\n// A max-score (pre-computed) for peer selection\n\n// This is used for every DFS. It will end up being the size of the largest\n// peer list.\nvar dfsStack = [0, 1, 2];\n\nfunction PeerHeap(peers, random) {\n    this.array = [];\n    this.peers = peers || null;\n    this.hasMinConnections = peers ? peers.hasMinConnections : false;\n\n    this.random = random || Math.random;\n    assert(typeof this.random === 'function', 'PeerHeap expected random fn');\n\n    // We cache the range los and his so they can be stored as a contiguous\n    // array of boxed doubles. This has a noticable speed increase.\n    this.rangehis = [];\n    this.rangelos = [];\n\n    this.maxRangeStart = 0;\n}\n\n/*eslint-disable complexity */\n/*eslint-disable max-statements */\nPeerHeap.prototype.choose = function choose(threshold, filter) {\n    var self = this;\n\n    if (!self.array.length) {\n        return null;\n    }\n\n    var isSecondary = false;\n    var chosenPeer = null;\n    var secondaryPeer = null;\n    var highestProbability = 0;\n    var secondaryProbability = 0;\n    var firstScore = self.array[0].peer.getScore();\n\n    var notEnoughPeers = false;\n    if (self.hasMinConnections) {\n        notEnoughPeers = self.peers.currentConnectedPeers < self.peers.minConnections;\n    }\n\n    // Pointers into dfsStack\n    var stackBegin = 0;\n    var stackEnd = 0;\n\n    if (firstScore > threshold && (!filter || filter(self.array[0].peer))) {\n        // Don't check first peer if it looks good, check its children though\n\n        var firstPeer = self.array[0].peer;\n        isSecondary = notEnoughPeers && firstPeer.isConnected('out');\n\n        if (isSecondary) {\n            secondaryPeer = firstPeer;\n            secondaryProbability = firstScore;\n        } else {\n            chosenPeer = firstPeer;\n            highestProbability = firstScore;\n        }\n\n        // The array is seeded with 0, 1, 2 so we just have to advance the\n        // stack pointers\n        stackBegin = 1;\n        stackEnd = 2;\n    }\n\n    while (stackBegin <= stackEnd) {\n        var i = dfsStack[stackBegin];\n        stackBegin++;\n\n        var el = self.array[i];\n\n        if (!el || (\n            self.rangehis[i] <= self.maxRangeStart &&\n            (!filter && !notEnoughPeers)\n        )) {\n            // This range ends before the range with the largest start begins,\n            // so it can't possibly be chosen over any of the ranges we've\n            // seen. All ranges below this one have a smaller end, so this\n            // range and any below it can't be chosen.\n            continue;\n        }\n\n        if (!filter || filter(el.peer)) {\n            isSecondary = notEnoughPeers && el.peer.isConnected('out');\n\n            // INLINE of TChannelPeer#getScore\n            var lo = self.rangelos[i];\n            var hi = self.rangehis[i];\n            var rand = self.random();\n            if (rand === 0) {\n                rand = 1;\n            }\n            var probability = lo + ((hi - lo) * rand);\n\n            var isBestChoice = !isSecondary ?\n                (probability > highestProbability) :\n                (probability > secondaryProbability);\n\n            if ((probability > threshold) && isBestChoice) {\n                if (isSecondary) {\n                    secondaryProbability = probability;\n                    secondaryPeer = el.peer;\n                } else {\n                    highestProbability = probability;\n                    chosenPeer = el.peer;\n                }\n            }\n        }\n\n        // Continue DFS by 'pushing' left and right indexes onto end of\n        // dfsStack, if the source array is long enough for that\n        var left = 2 * i + 1;\n        var right = left + 1;\n        if (left < self.array.length) {\n            dfsStack[++stackEnd] = left;\n            if (right < self.array.length) {\n                dfsStack[++stackEnd] = right;\n            }\n        }\n    }\n\n    if (secondaryProbability > highestProbability && chosenPeer) {\n        chosenPeer.tryConnect(noop);\n        return secondaryPeer;\n    }\n\n    return chosenPeer || secondaryPeer;\n};\n/*eslint-enable complexity */\n/*eslint-enable max-statements */\n\nfunction noop() {}\n\nPeerHeap.prototype.clear = function clear() {\n    var self = this;\n\n    for (var i = 0; i < self.array.length; i++) {\n        var el = self.array[i];\n        el.heap = null;\n        el.peer = null;\n        el.index = 0;\n        el.range = null;\n    }\n    self.array.length = 0;\n    self.rangehis.length = 0;\n    self.rangelos.length = 0;\n};\n\nPeerHeap.prototype.add = function add(peer) {\n    var self = this;\n\n    var range = peer.scoreRange;\n    var i = self.push(peer, range);\n    var el = self.array[i];\n    return el;\n};\n\nPeerHeap.prototype.rescore = function rescore() {\n    var self = this;\n\n    for (var i = 0; i < self.array.length; i++) {\n        var el = self.array[i];\n        el.range = el.peer.getScoreRange();\n    }\n    self.heapify();\n};\n\nPeerHeap.prototype.heapify = function heapify() {\n    var self = this;\n\n    if (self.array.length <= 1) {\n        return;\n    }\n\n    for (var i = Math.floor(self.array.length / 2 - 1); i >= 0; i--) {\n        self.siftdown(i);\n    }\n};\n\nPeerHeap.prototype.remove = function remove(i) {\n    var self = this;\n\n    if (i >= self.array.length) {\n        return;\n    }\n\n    if (self.array.length === 1) {\n        self.array.pop();\n        return;\n    }\n\n    var j = self.array.length - 1;\n    if (i === j) {\n        self.array.pop();\n        return;\n    }\n\n    self.swap(i, j);\n    self.array.pop();\n    self.siftup(i);\n};\n\nPeerHeap.prototype.push = function push(peer, range) {\n    var self = this;\n\n    var el = new PeerHeapElement(self);\n    el.peer = peer;\n    el.range = peer.scoreRange;\n    el.index = self.array.length;\n\n    self.array.push(el);\n    return self.siftup(el.index);\n};\n\nPeerHeap.prototype.pop = function pop() {\n    var self = this;\n    var peer = null;\n\n    if (!self.array.length) {\n        return peer;\n    }\n\n    if (self.array.length === 1) {\n        peer = self.array.pop();\n        return peer;\n    }\n\n    peer = self.array[0].peer;\n    self.array[0] = self.array.pop();\n    self.siftdown(0);\n\n    return peer;\n};\n\nPeerHeap.prototype.siftdown = function siftdown(i) {\n    var self = this;\n\n    for (;;) {\n        var left = (2 * i) + 1;\n        if (left >= self.array.length) {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            self.maxRangeStart = Math.max(self.rangelos[i], self.maxRangeStart);\n            return i;\n        }\n\n        var right = left + 1;\n        var child = left;\n        if (right < self.array.length &&\n            self.array[right].range.hi > self.array[left].range.hi) {\n            child = right;\n        }\n\n        if (self.array[child].range.hi > self.array[i].range.hi) {\n            self.swap(i, child);\n            i = child;\n        } else {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            self.maxRangeStart = Math.max(self.rangelos[i], self.maxRangeStart);\n            return i;\n        }\n    }\n};\n\nPeerHeap.prototype.siftup = function siftup(i) {\n    var self = this;\n\n    while (i > 0) {\n        var par = Math.floor((i - 1) / 2);\n        if (self.array[i].range.hi > self.array[par].range.hi) {\n            self.swap(i, par);\n            i = par;\n        } else {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            self.maxRangeStart = Math.max(self.rangelos[i], self.maxRangeStart);\n            return i;\n        }\n    }\n\n    self.rangehis[0] = self.array[0].range.hi;\n    self.rangelos[0] = self.array[0].range.lo;\n    self.maxRangeStart = Math.max(self.rangelos[i], self.maxRangeStart);\n\n    return 0;\n};\n\nPeerHeap.prototype.swap = function swap(i, j) {\n    var self = this;\n\n    var a = self.array[i];\n    var b = self.array[j];\n\n    self.array[i] = b;\n    self.array[j] = a;\n    b.index = i;\n    a.index = j;\n\n    self.rangehis[j] = a.range.hi;\n    self.rangelos[j] = a.range.lo;\n    self.maxRangeStart = Math.max(self.rangelos[j], self.maxRangeStart);\n\n    self.rangehis[i] = b.range.hi;\n    self.rangelos[i] = b.range.lo;\n    self.maxRangeStart = Math.max(self.rangelos[i], self.maxRangeStart);\n};\n\nfunction PeerHeapElement(heap) {\n    var self = this;\n\n    self.heap = heap;\n    self.peer = null;\n    self.index = 0;\n    self.range = null;\n}\n\nPeerHeapElement.prototype.rescore = function rescore(range) {\n    var self = this;\n\n    if (!self.heap) {\n        return;\n    }\n\n    self.range = self.peer.scoreRange;\n    self.index = self.heap.siftup(self.index);\n    self.index = self.heap.siftdown(self.index);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/services.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar errors = require('./errors');\n\nfunction TChannelServices() {\n    // Maps service name with '$' prefix to service tracking object.\n    // The prefix ensures that we cannot be lost or confused if some joker\n    // names their service 'toString' or '__proto__'.\n    // '_' as a prefix would still be confused by '_proto__', '__' would be\n    // confused by 'proto__'.\n    this.services = {};\n    this.maxPendingForService = Infinity;\n    this.maxPending = Infinity;\n    this.pending = 0;\n}\n\nTChannelServices.prototype.errorIfExceedsMaxPending = function errorIfExceedsMaxPending(req) {\n    if (this.pending >= this.maxPending) {\n        return errors.MaxPendingError({\n            pending: this.pending\n        });\n    }\n    if (!req.serviceName) {\n        return null;\n    }\n    var serviceKey = '$' + req.serviceName;\n    var service = this.services[serviceKey];\n    return service && service.errorIfExceedsMaxPending();\n};\n\nTChannelServices.prototype.onRequest = function onRequest(req) {\n    this.pending++;\n    if (!req.serviceName) {\n        return;\n    }\n    var serviceKey = '$' + req.serviceName;\n    var service = this.services[serviceKey];\n    if (!service) {\n        service = new TChannelService();\n        service.serviceName = req.serviceName;\n        if (this.maxPendingForService !== undefined) {\n            service.maxPending = this.maxPendingForService;\n        }\n        this.services[serviceKey] = service;\n    }\n    service.onRequest();\n};\n\nTChannelServices.prototype.onRequestResponse = function onRequestResponse(req) {\n    this.pending--;\n    if (!req.serviceName) {\n        return;\n    }\n    var serviceKey = '$' + req.serviceName;\n    var service = this.services[serviceKey];\n    service.onRequestResponse();\n};\n\nTChannelServices.prototype.onRequestError = function onRequestError(req) {\n    this.pending--;\n    if (!req.serviceName) {\n        return;\n    }\n    var serviceKey = '$' + req.serviceName;\n    var service = this.services[serviceKey];\n    service.onRequestError();\n};\n\nfunction TChannelService() {\n    this.serviceName = null;\n    this.maxPending = Infinity;\n    this.pending = 0;\n}\n\nTChannelService.prototype.errorIfExceedsMaxPending = function errorIfExceedsMaxPending() {\n    if (this.pending >= this.maxPending) {\n        return errors.MaxPendingForServiceError({\n            serviceName: this.serviceName,\n            pending: this.pending\n        });\n    }\n};\n\nTChannelService.prototype.onRequest = function onRequest() {\n    this.pending += 1;\n};\n\nTChannelService.prototype.onRequestResponse = function onRequestResponse() {\n    this.pending -= 1;\n};\n\nTChannelService.prototype.onRequestError = function onRequestError() {\n    this.pending -= 1;\n};\n\nmodule.exports = TChannelServices;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/time_heap.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar setImmediate = require('timers').setImmediate;\n\nvar DRAIN_LOOP_MAX_DURATION = 100; // ms\n\nmodule.exports = TimeHeap;\n\nvar globalTimers = {\n    setTimeout: require('timers').setTimeout,\n    clearTimeout: require('timers').clearTimeout,\n    now: Date.now\n};\n\n/* A specialized min-time heap\n *\n * new TimeHeap({\n *   timer: {now, setTimeout, clearTimeout},\n *   minTimeout: Number | (now) -> Number\n * })\n *\n * The items on the heap must have two properties:\n * - item.timeout is ms timeout, relative to heap add time\n * - item.onTimeout is a callback which gets called once the item has expired;\n *   the callback is passed the current time in ms.\n *\n * Overview:\n * - timeHeap.array is an array of TimeHeapElement objects\n *\n * - timeHeap.lastTime is the timestamp (ms) that all times in the heap are\n *   relative to\n *\n * - timeHeap.timer is the currently pending timer object or null\n *\n * - timeHeap.expired are any items pending having their .onTimeout called; this\n *   call is defered until next tick after a drain to avoid any heap\n *   interactions/changes while draining (if the callback adds something else\n *   to the heap)\n *\n * The primary public API is:\n *     timeHeap.update(item, ?now)\n *\n * Note the method is is intentionally not named something simple like \"add\" or\n * \"append\" since it does a bit more:\n * - pop any expired times, and defer a call to their .onTimeout\n * - push the new item and its expiration time onto the heap\n * - set a timer if there is none or the newly added item is the next to expire\n *\n * TODO: shrink array if end is << array.length/2 (trigger in pop and/or a\n * sweep on an interval)\n */\n\nfunction TimeHeap(options) {\n    var self = this;\n    options = options || {};\n\n    self.timers = options.timers || globalTimers;\n    self.minTimeout = options.minTimeout || null;\n    self.array = [];\n    self.expired = [];\n    self.lastTime = self.timers.now();\n    self.timer = null;\n    self.end = 0;\n    self.lastRun = 0;\n    self.drainUntil = 0;\n\n    self.scheduledDrain = null;\n\n    self.boundDrainExpired = boundDrainExpired;\n\n    function boundDrainExpired() {\n        var now = self.scheduledDrain;\n        self.scheduledDrain = null;\n\n        self.drainExpired(now);\n    }\n}\n\nTimeHeap.prototype.clear = function clear() {\n    var self = this;\n\n    self.timers.clearTimeout(self.timer);\n    self.array = [];\n    self.expired = [];\n    self.timer = null;\n    self.lastTime = self.timers.now();\n    self.end = 0;\n};\n\nTimeHeap.prototype.getNextTimeout = function getNextTimeout(now) {\n    var self = this;\n\n    var timeout = self.array[0].expireTime - now;\n    if (typeof self.minTimeout === 'function') {\n        timeout = Math.max(self.minTimeout(now), timeout);\n    } else if (typeof self.minTimeout === 'number') {\n        timeout = Math.max(self.minTimeout, timeout);\n    }\n    return timeout;\n};\n\nTimeHeap.prototype.update = function update(item, now) {\n    var self = this;\n\n    if (now === undefined) {\n        now = self.timers.now();\n    }\n\n    self.scheduleDrainExpired(now);\n    var time = now + item.timeout;\n    var i = self.push(item, time);\n    // update timer if none, or the newly added item is the new root\n    if (!self.timer || i === 0) {\n        self.setNextTimer(now);\n    }\n    return self.array[i];\n};\n\nTimeHeap.prototype.scheduleDrainExpired =\nfunction scheduleDrainExpired(now) {\n    var self = this;\n\n    if (self.scheduledDrain) {\n        return;\n    }\n\n    self.scheduledDrain = now;\n    setImmediate(self.boundDrainExpired);\n};\n\nTimeHeap.prototype.setNextTimer = function setNextTimer(now) {\n    var self = this;\n\n    if (self.timer) {\n        self.timers.clearTimeout(self.timer);\n    }\n\n    var timeout = self.getNextTimeout(now);\n    self.timer = self.timers.setTimeout(onTimeout, timeout);\n\n    function onTimeout() {\n        var now2 = self.timers.now();\n        self.onTimeout(now2);\n    }\n};\n\nTimeHeap.prototype.onTimeout = function onTimeout(now) {\n    var self = this;\n\n    self.timer = null;\n    self.lastRun = now;\n    self.drainExpired(now);\n    if (self.end) {\n        self.setNextTimer(now);\n    }\n};\n\nTimeHeap.prototype.drainExpired = function drainExpired(now) {\n    var self = this;\n\n    if (now < self.drainUntil) {\n        return;\n    }\n\n    self.drainUntil = now + DRAIN_LOOP_MAX_DURATION;\n\n    while (self.end && self.array[0].expireTime <= now) {\n        var item = self.pop();\n        if (item) {\n            self.expired.push(item);\n        }\n    }\n    if (self.expired.length) {\n        // callExpiredTimeouts can re-enter drainExpired by calling popOutReq,\n        // which in turn calls update, and then back to drainExpired.\n        // The drainUntil shorts this recursive loop.\n        // The solution uses a timer instead of a flag to ensure that drain\n        // resumes even if an exception halts the loop prematurely without\n        // incurring the cost of try/finally.\n        self.callExpiredTimeouts(now);\n    }\n\n    self.drainUntil = 0;\n};\n\nTimeHeap.prototype.callExpiredTimeouts = function callExpiredTimeouts(now) {\n    var self = this;\n\n    while (self.expired.length) {\n        var item = self.expired.shift();\n        item.onTimeout(now);\n    }\n};\n\nTimeHeap.prototype.push = function push(item, expireTime) {\n    var self = this;\n\n    var i = self.end;\n    if (i >= self.array.length) {\n        i = self.array.length;\n        self.array.push(new TimeHeapElement());\n    }\n    var el = self.array[i];\n    el.expireTime = expireTime;\n    el.item = item;\n    self.end = i + 1;\n    return self.siftup(i);\n};\n\nTimeHeap.prototype.pop = function pop() {\n    var self = this;\n\n    if (!self.end) {\n        return null;\n    }\n\n    var el = self.array[0];\n    self.end--;\n    self.swap(0, self.end);\n    self.siftdown(0);\n\n    var item = el.item;\n    el.expireTime = 0;\n    el.item = null;\n    return item;\n};\n\nTimeHeap.prototype.siftdown = function siftdown(i) {\n    var self = this;\n\n    for (;;) {\n        var left = (2 * i) + 1;\n        var right = left + 1;\n        if (left < self.end &&\n            self.array[left].expireTime < self.array[i].expireTime) {\n            if (right < self.end &&\n                self.array[right].expireTime < self.array[left].expireTime) {\n                self.swap(i, right);\n                i = right;\n            } else {\n                self.swap(i, left);\n                i = left;\n            }\n        } else if (right < self.end &&\n                   self.array[right].expireTime < self.array[i].expireTime) {\n            self.swap(i, right);\n            i = right;\n        } else {\n            return i;\n        }\n    }\n};\n\nTimeHeap.prototype.siftup = function siftup(i) {\n    var self = this;\n\n    while (i > 0) {\n        var par = Math.floor((i - 1) / 2);\n        if (self.array[i].expireTime < self.array[par].expireTime) {\n            self.swap(i, par);\n            i = par;\n        } else {\n            break;\n        }\n    }\n    return i;\n};\n\nTimeHeap.prototype.swap = function swap(i, j) {\n    var self = this;\n\n    var tmp = self.array[i];\n    self.array[i] = self.array[j];\n    self.array[j] = tmp;\n};\n\nfunction TimeHeapElement() {\n    this.expireTime = 0;\n    this.item = null;\n}\n\nTimeHeapElement.prototype.cancel = function cancel() {\n    this.item = null;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/peer-file-watcher.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar safeJSONParse = require('safe-json-parse/tuple');\nvar fs = require('fs');\nvar assert = require('assert');\n\nfunction PeerFileWatcher(channel, opts) {\n    var self = this;\n\n    assert(channel.topChannel, 'must be a subChannel');\n    this.channel = channel;\n    this.peerFile = opts.peerFile;\n    this.refreshInterval = opts.refreshInterval || 5007;\n    this.logger = channel.logger;\n\n    this._boundReload = _boundReload;\n\n    this._validateFilePath();\n    this._establishFileWatcher();\n\n    // Trigger an initial load\n    this.reloadSync();\n\n    function _boundReload() {\n        self.reload();\n    }\n}\n\nPeerFileWatcher.prototype._validateFilePath = function _validateFilePath() {\n    if (!fs.existsSync(this.peerFile)) {\n        assert(false, 'Peer hosts file does not exist: ' + this.peerFile);\n    }\n};\n\nPeerFileWatcher.prototype._readPeerListFromFileSync =\nfunction _readPeerListFromFileSync() {\n    var tuple = safeJSONParse(fs.readFileSync(this.peerFile, 'utf8'));\n    if (tuple[0]) {\n        assert(false, 'Invalid JSON for TChannel peer host file at ' + this.peerFile);\n    }\n    return tuple[1];\n};\n\nPeerFileWatcher.prototype._establishFileWatcher =\nfunction _establishFileWatcher() {\n    // Use watchFile instead of watch here. watch uses inotify events,\n    // but since we're getting renames every 30 seconds and the inode is\n    // changing we'd need to keep creating new watches for every file and\n    // eventually exhaust the kernel's inotify watch limit.\n    //\n    // watchFile instead polls with stat. Not as performant as inotify, but\n    // better than watches eventually failing.\n    fs.watchFile(this.peerFile, {\n        interval: this.refreshInterval,\n        persistent: true\n    }, this._boundReload);\n};\n\nPeerFileWatcher.prototype.destroy = function destroy() {\n    fs.unwatchFile(this.peerFile, this._boundReload);\n};\n\n/**\n * Load hosts from a JSON file and update peers in TChannel.\n */\nPeerFileWatcher.prototype.reloadSync =\nfunction reloadSync() {\n    this.logger.info('PeerFileWatcher: Loading peer list from file sync', {\n        peerFile: this.peerFile\n    });\n\n    var newPeers = this._readPeerListFromFileSync();\n    this.channel.updatePeers(newPeers);\n};\n\nPeerFileWatcher.prototype.reload =\nfunction reload() {\n    var self = this;\n    this.logger.info('PeerFileWatcher: Loading peer list from file async', {\n        peerFile: this.peerFile\n    });\n\n    this._readPeerList(onPeers);\n\n    function onPeers(err, newPeers) {\n        if (err) {\n            self.logger.error('PeerFileWatcher: Could not load peers file', {\n                peerFile: self.peerFile,\n                error: err\n            });\n            return;\n        }\n\n        self.channel.updatePeers(newPeers);\n    }\n};\n\nPeerFileWatcher.prototype._readPeerList =\nfunction _readPeerList(cb) {\n    fs.readFile(this.peerFile, 'utf8', onFile);\n\n    function onFile(err, text) {\n        if (err) {\n            return cb(err);\n        }\n\n        var tuple = safeJSONParse(text);\n        if (tuple[0]) {\n            return cb(tuple[0]);\n        }\n\n        cb(null, tuple[1]);\n    }\n};\n\nmodule.exports = PeerFileWatcher;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/trace/agent.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar Span = require('./span');\nvar errors = require('../errors.js');\n\nmodule.exports = Agent;\n\nfunction Agent(options) {\n    options = options || {};\n\n    this.logger = options.logger;\n\n    // If this is set to true in a call to Agent#configure, all incoming\n    // requests will have their traceflags forced to 1. It's intended to be\n    // set on the 'top level service'.\n    this.forceTrace = options.forceTrace || false;\n\n    // 'our' service name that is used as the service name on spans for\n    // incoming reuqests\n    this.serviceName = options.serviceName || null;\n\n    if (options.reporter) {\n        this.reporter = options.reporter;\n    }\n}\n\nfunction compareTracingIds(id1, id2) {\n    if (!id1 || !id2) {\n        return false;\n    }\n    return id1[0] === id2[0] && id1[1] === id2[1];\n}\n\n// ## setupNewSpan\n// Sets up a new span for an outgoing rpc\nAgent.prototype.setupNewSpan = function setupNewSpan(options) {\n    var hostPortParts = options.remoteName.split(':');\n    var host = hostPortParts[0];\n    var port = parseInt(hostPortParts[1], 10);\n\n    var empty = [0, 0];\n    if (compareTracingIds(empty, options.parentid)) {\n        options.parentid = null;\n    }\n\n    if (compareTracingIds(empty, options.traceid)) {\n        options.traceid = null;\n    }\n\n    if (compareTracingIds(empty, options.spanid)) {\n        options.spanid = null;\n    }\n\n    var span = new Span({\n        endpoint: new Span.Endpoint(\n            host,\n            port,\n            // If a service hasn't been specified on the tracer, use the\n            // service on the incoming request. This is to handle the\n            // case of the service router, which has a different service name\n            // than the one specified in the incoming request.\n            this.serviceName || options.serviceName\n        ),\n        name: options.name,\n        id: options.spanid,\n        parentid: options.parentid,\n        traceid: options.traceid,\n        flags: this.forceTrace ? 1 : options.flags\n    });\n\n    var parentSpan = options.parentSpan;\n    if (options.outgoing && !parentSpan && !options.hasNoParent) {\n        throw errors.ParentRequired({\n            parentSpan: parentSpan,\n            hasNoParent: options.hasNoParent,\n            serviceName: options.serviceName\n        });\n    }\n\n    if (parentSpan && (!options.parentid && !options.traceid)) {\n        // If there's a parentSpan and the parentid and traceid weren't\n        // specified, we need to propagate the ids from the parent span.\n        span.propagateIdsFrom(parentSpan);\n        span.generateSpanid();\n    } else if (!parentSpan && (!options.traceid && !options.spanid)) {\n        // No ids were specified and there's no parent span. Generate a new\n        // id and use it as the spanid and traceid.\n        span.generateIds();\n    }\n\n    return span;\n};\n\nAgent.prototype.report = function report(span) {\n    if (span.flags & 0x01) {\n        this.reporter(span);\n    }\n};\n\nAgent.prototype.reporter = function nullReporter() {};\n\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/trace/span.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar xorshift = require('xorshift');\n\nmodule.exports = Span;\nmodule.exports.Endpoint = Endpoint;\nmodule.exports.Annotation = Annotation;\nmodule.exports.BinaryAnnotation = BinaryAnnotation;\n\nfunction Span(options) {\n    // TODO: options validation\n\n    if (options.id) {\n        this.id = options.id;\n    }\n\n    if (options.traceid) {\n        this.traceid = options.traceid;\n    }\n\n    this.endpoint = options.endpoint;\n\n    this.name = options.name;\n    this.parentid = options.parentid;\n    if (!options.parentid) {\n        this.parentid = [0, 0];\n    }\n    this.annotations = [];\n    this.binaryAnnotations = [];\n    this.serviceName = options.serviceName;\n    this.flags = options.flags;\n}\n\nSpan.prototype.toString = function toString() {\n    var strAnnotations = this.annotations.map(function eachAnn(ann) {\n        return '[' + ann.value + ' ' + ann.timestamp + ']';\n    }).join(' ');\n    return 'SPAN: traceid: ' + this.traceid.toString('hex') + ' spanid: ' +\n        this.id.toString('hex') + ' parentid: ' +\n        this.parentid.toString('hex') + ' name: ' + this.name +\n        ' servicename: ' + this.endpoint.serviceName +\n        ' annotations: ' + strAnnotations;\n};\n\nSpan.prototype.toJSON = function toJSON() {\n    return {\n        name: this.name,\n        endpoint: this.endpoint,\n        traceid: this.traceid,\n        parentid: this.parentid,\n        spanid: this.id,\n        annotations: this.annotations,\n        binaryAnnotations: this.binaryAnnotations\n    };\n};\n\n// Generate a trace/span id for this span\nSpan.prototype.generateIds = function generateIds() {\n    this.id = this.traceid = xorshift.randomint();\n};\n\n// Generate just a span id\nSpan.prototype.generateSpanid = function generateSpanid() {\n    this.id = xorshift.randomint();\n};\n\n// ##\nSpan.prototype.propagateIdsFrom = function propagateIdsFrom(span) {\n    this.parentid = span.id;\n    this.traceid = span.traceid;\n    this.flags = span.flags;\n};\n\nSpan.prototype.getTracing = function getTracing() {\n    return {\n        spanid: this.id,\n        traceid: this.traceid,\n        parentid: this.parentid,\n        flags: this.flags\n    };\n};\n\nSpan.prototype.annotate = function annotate(value, timestamp) {\n    timestamp = timestamp || Date.now();\n    this.annotations.push(new Annotation(value, this.endpoint, timestamp));\n};\n\nSpan.prototype.annotateBinary =\nfunction annotateBinary(key, value, type) {\n    this.binaryAnnotations.push(new BinaryAnnotation(key, value, type, this.endpoint));\n};\n\nfunction Endpoint(ipv4, port, serviceName) {\n    this.ipv4 = ipv4;\n    this.port = port;\n    this.serviceName = serviceName;\n}\n\nfunction Annotation(value, host, timestamp) {\n    // TODO: validation\n    this.value = value;\n    this.timestamp = timestamp || Date.now();\n    this.host = host;\n}\n\nfunction BinaryAnnotation(key, value, type, host) {\n    // TODO: validation\n    this.key = key;\n    this.value = value;\n    this.type = type ? type : typeof value;\n    this.host = host;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/hyperbahn-client.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar assert = require('assert');\nvar fs = require('fs');\nvar TypedError = require('error/typed');\nvar WrappedError = require('error/wrapped');\nvar timers = require('timers');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar safeJsonParse = require('safe-json-parse/tuple');\nvar path = require('path');\n\nvar Reporter = require('./tcollector/reporter.js');\nvar TChannelJSON = require('./as/json.js');\nvar TChannelThrift = require('./as/thrift.js');\n\nvar AdvertisementTimeoutError = WrappedError({\n    type: 'hyperbahn-client.advertisement-timeout',\n    message: 'Hyperbahn advertisement timed out after {time} ms!.\\n' +\n        '{origMessage}.\\n'\n});\n\nvar AlreadyDestroyed = TypedError({\n    type: 'hyperbahn-client.already-destroyed',\n    message: 'HyperbahnClient was already destroyed.\\n' +\n        'Cannot invoke {method}.',\n    method: null\n});\n\nvar States = {\n    UNADVERTISED: 'UNADVERTISED',\n    ADVERTISED: 'ADVERTISED'\n};\nvar DEFAULT_TTL = 60 * 1000;\nvar DEFAULT_ERROR_RETRY_TIMES = [\n    200, // One fast retry\n\n    1000, // Fibonacci backoff\n    1000,\n    2000,\n    3000,\n    5000,\n    8000,\n\n    10000 // Max out at 10 seconds\n];\nvar DEFAULT_TIMEOUT = 500;\n\nvar thriftSource = fs.readFileSync(\n    path.join(__dirname, 'hyperbahn.thrift'),\n    'utf8');\n\nmodule.exports = HyperbahnClient;\n\n// # HyperbahnClient\n// options.\n//   * (required) tchannel: tchannel instance\n//   * (required) serviceName: string service name\n//   * (required) hostPortList: array of initial hyperbahn nodes\n//   * callerName: the caller name\n//   * logger: logtron instance\n//   * reportTracing: Whether to report tracing\n//   * hardFail: boolean; default false; whether or not to fail hard when we\n//     can't advertise or on unexpected hyperbahn errors\n//   * registrationTimeout: deprecated\n//   * advertisementTimeout: integer. In hardFail mode we default to 5000. If\n//     not in hardFail mode we don't time out advertisements.\nfunction HyperbahnClient(options) {\n    /*eslint max-statements: [2, 50] complexity: [2, 20] */\n    if (!(this instanceof HyperbahnClient)) {\n        return new HyperbahnClient(options);\n    }\n\n    var self = this;\n\n    EventEmitter.call(this);\n\n    assert(options && options.tchannel, 'Must pass in a tchannel');\n    assert(options && options.tchannel && !options.tchannel.topChannel,\n        'Must pass in top level tchannel');\n    assert(options.tchannel.tracer, 'Top channel must have trace enabled');\n    assert(options.serviceName, 'must pass in serviceName');\n    if (Array.isArray(options.hostPortList)) {\n        self.hostPortList = options.hostPortList;\n    } else if (typeof options.hostPortFile === 'string') {\n        var tuple = safeSyncRead(options.hostPortFile);\n        assert(!tuple[0], 'Read host port list failed with ' + tuple[0]);\n        tuple = safeJsonParse(tuple[1]);\n        assert(!tuple[0], 'Parse host port list failed with ' + tuple[0]);\n        assert(Array.isArray(tuple[1]), 'Host port list in the file is not array');\n        self.hostPortList = tuple[1];\n    } else {\n        assert(false, 'Must pass in hostPortList as array or hostPortFile as string');\n    }\n\n    self.serviceName = options.serviceName;\n    self.callerName = options.callerName || options.serviceName;\n    self.tchannel = options.tchannel;\n    self.reportTracing = 'reportTracing' in options ?\n        options.reportTracing : true;\n    self.hardFail = !!options.hardFail;\n    self.advertiseInterval = options.advertiseInterval || DEFAULT_TTL;\n    self.timeoutFuzz = self.advertiseInterval;\n    self.errorRetryTimes = options.errorRetryTimes || DEFAULT_ERROR_RETRY_TIMES;\n\n    self.logger = options.logger || self.tchannel.logger;\n    self.statsd = options.statsd;\n\n    self.reporter = Reporter({\n        channel: self.getClientChannel({\n            serviceName: 'tcollector',\n            trace: false\n        }),\n        logger: self.logger,\n        callerName: self.callerName,\n        logWarnings: options.logTraceWarnings\n    });\n    self.tchannel.tracer.reporter = function report(span) {\n        if (self.reportTracing) {\n            self.reporter.report(span);\n        }\n    };\n\n    if (!self.reportTracing) {\n        self.logger.warn('HyperbahnClient tcollector tracing is OFF', {\n            service: self.serviceName\n        });\n    }\n\n    self.hyperbahnChannel = self.tchannel.subChannels.hyperbahn ||\n        self.tchannel.makeSubChannel({\n            serviceName: 'hyperbahn',\n            peers: self.hostPortList,\n            preferConnectionDirection: 'in'\n        });\n    self.tchannelJSON = TChannelJSON();\n    self.tchannelThrift = TChannelThrift({\n        source: thriftSource\n    });\n\n    self.lastError = null;\n    self.latestAdvertisementResult = null;\n    self.attemptCounter = 0;\n    self.state = States.UNADVERTISED;\n    self._destroyed = false;\n    self.defaultTimeout = options.defaultTimeout || DEFAULT_TIMEOUT;\n\n    var advertisementTimeout = options.advertisementTimeout ||\n        options.registrationTimeout;\n    if (self.hardFail) {\n        self.advertisementTimeoutTime = advertisementTimeout || 5000;\n    } else {\n        self.advertisementTimeoutTime = 0;\n        self.logger.info('HyperbahnClient advertisement timeout disabled', {\n            service: self.serviceName\n        });\n    }\n}\n\nutil.inherits(HyperbahnClient, EventEmitter);\n\nHyperbahnClient.prototype.setReportTracing = function setReportTracing(bool) {\n    var self = this;\n\n    self.reportTracing = bool;\n};\n\nHyperbahnClient.prototype.getThriftSync =\nfunction getThriftSync(options) {\n    var self = this;\n\n    assert(options && options.serviceName, 'must pass serviceName');\n    assert(options && options.thriftFile, 'must pass thriftFile');\n\n    var channel = self.getClientChannel(options);\n\n    return channel.TChannelAsThrift({\n        entryPoint: options.thriftFile,\n        strict: options.strict,\n        logger: options.logger,\n        bossMode: options.bossMode,\n        channel: channel,\n        isHealthy: options.isHealthy\n    });\n};\n\n// Gets the subchannel for hitting a particular service.\nHyperbahnClient.prototype.getClientChannel =\nfunction getClientChannel(options) {\n    var self = this;\n\n    assert(options && options.serviceName, 'must pass serviceName');\n\n    if (self._destroyed) {\n        self.emit('error', AlreadyDestroyed({\n            method: 'getClientChannel'\n        }));\n        return null;\n    }\n\n    if (self.tchannel.subChannels[options.serviceName]) {\n        return self.tchannel.subChannels[options.serviceName];\n    }\n\n    var channelOptions = {\n        peers: self.hostPortList,\n        serviceName: options.serviceName,\n        preferConnectionDirection: 'in',\n        requestDefaults: {\n            serviceName: options.serviceName,\n            headers: {\n                cn: self.callerName\n            }\n        }\n    };\n    if ('trace' in options) {\n        channelOptions.trace = options.trace;\n    }\n    if ('timeout' in options) {\n        channelOptions.requestDefaults.timeout = options.timeout;\n    }\n    if ('retryLimit' in options) {\n        channelOptions.requestDefaults.retryLimit = options.retryLimit;\n    }\n\n    return self.tchannel.makeSubChannel(channelOptions);\n};\n\n// ## advertisementTimeout\n// Called after a certain amount of time to have a fatal error when reg fails.\n// Will not be called if options.advertisementTimeout isn't passed in\nHyperbahnClient.prototype.advertisementTimeout =\nfunction advertisementTimeout() {\n    var self = this;\n\n    if (self.state === States.UNADVERTISED) {\n        var lastError = self.lastError ||\n            new Error('advertisement timeout!');\n        var err = AdvertisementTimeoutError(lastError, {\n            time: self.advertisementTimeoutTime\n        });\n\n        self.logger.fatal('HyperbahnClient: advertisement timed out', {\n            timeout: self.advertisementTimeout,\n            error: err\n        });\n\n        self.advertisementFailure(err);\n    }\n    // TODO else warn\n};\n\nHyperbahnClient.prototype.advertisementFailure =\nfunction advertisementFailure(err) {\n    var self = this;\n\n    self.destroy();\n    self.emit('error', err);\n\n    if (self.statsd) {\n        self.statsd.increment(\n            'hyperbahn-client.' + self.serviceName + '.advertisement.failure'\n        );\n    }\n};\n\nHyperbahnClient.prototype.newRequest =\nfunction newRequest(opts) {\n    var self = this;\n    return self.hyperbahnChannel.request({\n        serviceName: 'hyperbahn',\n        timeout: (opts && opts.timeout) || self.defaultTimeout,\n        hasNoParent: true,\n        trace: false,\n        retryLimit: 1,\n        headers: {\n            cn: self.callerName\n        }\n    });\n};\n\nHyperbahnClient.prototype.sendRequest =\nfunction sendRequest(opts, endpoint, cb) {\n    var self = this;\n\n    var req = self.newRequest();\n    self.tchannelJSON.send(req, endpoint, null, {\n        services: [{\n            cost: 0,\n            serviceName: self.serviceName\n        }]\n    }, cb);\n};\n\n// ## advertise\n// Advertise with Hyperbahn. If called with a callback, the callback will not be\n// called until there has been a successful advertisement. This function\n// attempts a advertise and retries until there are no healthy servers left; it\n// will then repeatedly choose random servers to try until it finds one that\n// works.\n// register is **deprecated**\nHyperbahnClient.prototype.register =\nHyperbahnClient.prototype.advertise =\nfunction advertise(opts) {\n    var self = this;\n    // Attempt a advertisement. If it succeeds, setTimeout to re-advertise with\n    // the same server after the TTL.\n\n    assert(self.tchannel.hostPort,\n        'must call tchannel.listen() before advertise()');\n\n    if (self._destroyed) {\n        self.emit('error', AlreadyDestroyed({\n            method: 'advertise'\n        }));\n        return;\n    }\n\n    if (self.advertisementTimeoutTime) {\n        // Start the timeout timer\n        self.advertisementTimeoutTimer = timers.setTimeout(\n            function advertisementTimeoutTimer() {\n                self.advertisementTimeout();\n            },\n            self.advertisementTimeoutTime\n        );\n    }\n\n    self.attemptCounter++;\n    self.sendRequest(opts, 'ad', advertiseInternalCb);\n    self.emit('advertise-attempt');\n\n    function advertiseInternalCb(err, result) {\n        if (err) {\n            self.logger[self.hardFail ? 'error' : 'warn'](\n                'HyperbahnClient: advertisement failure, ' +\n                'marking server as sick', {\n                error: err,\n                serviceName: self.serviceName,\n                hostPort: self.hostPort\n            });\n            self.lastError = err;\n\n            self.advertiseAgain(self.getErrorRetryTime());\n            return;\n        }\n\n        if (result.ok === false) {\n            err = result.body;\n            var errInfo2 = {\n                error: err,\n                serviceName: self.serviceName,\n                hostPort: self.hostPort\n            };\n\n            self.logger[self.hardFail ? 'fatal' : 'warn'](\n                'HyperbahnClient: unexpected failure (from Hyperbahn)',\n                errInfo2\n            );\n\n            if (self.hardFail) {\n                self.advertisementFailure(err);\n            } else {\n                self.advertiseAgain(self.getErrorRetryTime());\n            }\n\n            return;\n        }\n\n        if (self.statsd) {\n            self.statsd.increment(\n                'hyperbahn-client.' + self.serviceName +\n                    '.advertisement.success'\n            );\n        }\n\n        self.latestAdvertisementResult = result;\n        self.attemptCounter = 0;\n        self.state = States.ADVERTISED;\n        timers.clearTimeout(self.advertisementTimeoutTimer);\n\n        self.advertiseAgain(self.getHealthyRetryTime());\n\n        // registered event is deprecated\n        self.emit('registered');\n        self.emit('advertised');\n    }\n};\n\nHyperbahnClient.prototype.unadvertise =\nfunction unadvertise(opts) {\n    var self = this;\n    self.sendRequest(opts, 'unad', unadvertiseInternalCb);\n    timers.clearTimeout(self._advertisementTimer);\n    timers.clearTimeout(self.advertisementTimeoutTimer);\n    self.latestAdvertisementResult = null;\n    function unadvertiseInternalCb(error, result) {\n        if (error) {\n            self.logger.warn('HyperbahnClient: unadvertisement failure', {\n                error: error,\n                serviceName: self.serviceName,\n                hostPort: self.hostPort\n            });\n            return;\n        }\n        self.state = States.UNADVERTISED;\n        self.emit('unadvertised');\n    }\n};\n\nHyperbahnClient.prototype.getErrorRetryTime = function getErrorRetryTime() {\n    var self = this;\n\n    return self.errorRetryTimes[self.attemptCounter - 1] ||\n        self.errorRetryTimes[self.errorRetryTimes.length - 1];\n};\n\nHyperbahnClient.prototype.getHealthyRetryTime = function getHealthyRetryTime() {\n    var self = this;\n\n    var fuzz = self.timeoutFuzz;\n    var delay = Math.round(Math.floor(Math.random() * fuzz)) - (fuzz / 2);\n\n    return self.advertiseInterval + delay;\n};\n\nHyperbahnClient.prototype.advertiseAgain =\nfunction advertiseAgain(delay) {\n    var self = this;\n\n    if (self._destroyed) {\n        return;\n    }\n\n    self._advertisementTimer = timers.setTimeout(\n        function advertiseTimeout() {\n            if (!self._destroyed) {\n                self.advertise();\n            }\n        },\n        delay\n    );\n};\n\n// ## discover\n// Make a discover query to Hyperbahn to find peers of this instance's service.\nHyperbahnClient.prototype.discover =\nfunction discover(opts, cb) {\n    var self = this;\n\n    opts = opts || {};\n\n    assert(self.tchannel.hostPort,\n        'must call tchannel.listen() before discover()');\n\n    if (self._destroyed) {\n        self.emit('error', AlreadyDestroyed({\n            method: 'discover'\n        }));\n        return;\n    }\n\n    var req = self.newRequest(opts);\n    var serviceName = opts.serviceName || self.serviceName;\n\n    self.tchannelThrift.send(req, 'Hyperbahn::discover', null, {\n        query: {\n            serviceName: serviceName\n        }\n    }, discoverInternalCb);\n\n    function discoverInternalCb(err, res) {\n        if (err) {\n            self.logger.error('call to discovery API failed', {\n                error: err,\n                serviceName: serviceName,\n                response: res\n            });\n            cb(err, null);\n            return;\n        }\n\n        var hosts;\n\n        if (res.ok === false) {\n            err = res.body;\n\n            // If the response from Hyperbahn is that there are no peers\n            // available, we callback with the error but also an empty host\n            // list. Callers can then use the value of \"hosts\" to determine the\n            // result without having to parse the error.\n            if (res.typeName === 'noPeersAvailable') {\n                hosts = [];\n            }\n\n            cb(err, hosts);\n            return;\n        }\n\n        hosts = [];\n        for (var i = 0; i < res.body.peers.length; i++) {\n            hosts.push(convertHost(res.body.peers[i]));\n        }\n\n        cb(null, hosts);\n        return;\n    }\n};\n\n// ## destroy\nHyperbahnClient.prototype.destroy = function destroy() {\n    var self = this;\n    if (self._destroyed) {\n        return;\n    }\n\n    self._destroyed = true;\n    timers.clearTimeout(self._advertisementTimer);\n    timers.clearTimeout(self.advertisementTimeoutTimer);\n};\n\nfunction safeSyncRead(filePath) {\n    var fileContents = null;\n    var error;\n\n    try {\n        fileContents = fs.readFileSync(filePath, 'utf8');\n    } catch (err) {\n        error = err;\n    }\n\n    return [error, fileContents];\n}\n\nfunction convertHost(host) {\n    var res = '';\n    res += ((host.ip.ipv4 >>> 24) & 0xff) + '.';\n    res += ((host.ip.ipv4 >>> 16) & 0xff) + '.';\n    res += ((host.ip.ipv4 >>> 8) & 0xff) + '.';\n    res += (host.ip.ipv4 & 0xff);\n    return res + ':' + host.port;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/tcollector/reporter.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar path = require('path');\nvar assert = require('assert');\nvar Buffer = require('buffer').Buffer;\n\nmodule.exports = TCollectorTraceReporter;\n\nfunction TCollectorTraceReporter(options) {\n    if (!(this instanceof TCollectorTraceReporter)) {\n        return new TCollectorTraceReporter(options);\n    }\n    var self = this;\n\n    assert(typeof options === 'object', 'options required');\n    assert(typeof options.logger === 'object', 'logger required');\n    assert(typeof options.channel === 'object', 'channel required');\n    assert(typeof options.callerName === 'string', 'callerName required');\n\n    self.logger = options.logger;\n    self.channel = options.channel;\n    self.callerName = options.callerName;\n    self.logWarnings = 'logWarnings' in options ?\n        options.logWarnings : true;\n\n    /*istanbul ignore if*/\n    if (!self.channel) {\n        // TODO: typederror or vld\n        throw new Error('TCollectorTraceReporter must be passed a tchannel');\n    }\n\n    self.tchannelThrift = new self.channel.TChannelAsThrift({\n        entryPoint: path.join(__dirname, 'tcollector.thrift'),\n        strict: false\n    });\n}\n\nTCollectorTraceReporter.ipToInt = function ipToInt(ip) {\n    var ipl = 0;\n    var parts = ip.split('.');\n    for (var i = 0; i < parts.length; i++) {\n        ipl <<= 8;\n        ipl += parseInt(parts[i], 10);\n    }\n    return (ipl >>> 0);\n};\n\nTCollectorTraceReporter.intIdToBuffer = function intIdToBuffer(id) {\n    var buf = new Buffer(8);\n    buf.writeUInt32BE(id[0], 0);\n    buf.writeUInt32BE(id[1], 4);\n    return buf;\n};\n\nTCollectorTraceReporter.convertHost = function convertHost(endpoint) {\n    return {\n        // the >> 0 here effectively casts the ip as a signed int since\n        // thrift doesn't have unsigned types\n        ipv4: TCollectorTraceReporter.ipToInt(endpoint.ipv4) >> 0,\n        port: endpoint.port,\n        serviceName: endpoint.serviceName\n    };\n};\n\nTCollectorTraceReporter.jsonSpanToThriftSpan =\nfunction jsonSpanToThriftSpan(span) {\n    var annotations = span.annotations.map(function fixAnnotation(item) {\n        return {\n            timestamp: item.timestamp,\n            value: item.value\n        };\n    });\n\n    var binaryAnnotations =\n        span.binaryAnnotations.map(function fixBinAnnotation(item) {\n            var ret = {\n                key: item.key,\n                annotationType: null,\n                boolValue: null,\n                intValue: null,\n                doubleValue: null,\n                stringValue: null,\n                bytesValue: null\n            };\n\n            if (item.type === 'boolean') {\n                ret.annotationType = 'BOOL';\n                ret.boolValue = item.value;\n            } else if (item.type === 'number') {\n                ret.annotationType = 'DOUBLE';\n                ret.doubleValue = item.value;\n            } else {\n                ret.annotationType = 'STRING';\n                ret.stringValue = String(item.value);\n            }\n\n            return ret;\n        });\n\n    var endpoint = span.endpoint || span.annotations[0].host;\n    var host = TCollectorTraceReporter.convertHost(endpoint);\n\n    var mapped = {\n        name: span.name,\n        traceId: TCollectorTraceReporter.intIdToBuffer(span.traceid),\n        parentId: TCollectorTraceReporter.intIdToBuffer(span.parentid),\n        id: TCollectorTraceReporter.intIdToBuffer(span.id),\n        annotations: annotations,\n        binaryAnnotations: binaryAnnotations,\n        host: host\n    };\n\n    return mapped;\n};\n\nTCollectorTraceReporter.prototype.report =\nfunction report(span, opts, callback) {\n    var self = this;\n\n    if (typeof opts === 'function') {\n        callback = opts;\n        opts = null;\n    }\n\n    var req = self.channel.request({\n        timeout: (opts && opts.timeout) || 100,\n        trace: false,\n        hasNoParent: true,\n        headers: {\n            cn: self.callerName,\n            shardKey: span.traceid.toString('base64')\n        },\n        serviceName: 'tcollector',\n        retryFlags: {never: true}\n    });\n\n    self.tchannelThrift.send(\n        req,\n        'TCollector::submit',\n        null,\n        {span: TCollectorTraceReporter.jsonSpanToThriftSpan(span)},\n        onResponse\n    );\n\n    function onResponse(err, response) {\n        if (err) {\n            if (self.logWarnings) {\n                self.logger.warn('Zipkin span submit failed', {\n                    error: err,\n                    serviceName: 'tcollector'\n                });\n            }\n\n            if (callback) {\n                callback(err);\n            }\n\n        } else if (!response.ok) {\n            if (self.logWarnings) {\n                self.logger.warn('Zipkin span submit failed: not ok', {\n                    error: response.body,\n                    serviceName: 'tcollector'\n                });\n            }\n\n            if (callback) {\n                callback(response.body);\n            }\n\n        } else if (callback) {\n            callback();\n        }\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lazy_relay.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = require('process');\nvar errors = require('./errors');\nvar v2 = require('./v2');\nvar stat = require('./stat-tags.js');\nvar ObjectPool = require('./lib/object_pool');\nvar ReadResult = require('bufrw').ReadResult;\nvar WriteResult = require('bufrw').WriteResult;\n\nvar readRes = new ReadResult();\nvar writeRes = new WriteResult();\n\nmodule.exports = {\n    LazyRelayInReq: LazyRelayInReq,\n    LazyRelayOutReq: LazyRelayOutReq,\n    logError: logError\n};\n\n// TODO: lazy reqs\n// - audit #extendLogInfo vs regular reqs\n\n/*eslint max-statements: [2, 40]*/\nfunction LazyRelayInReq(conn, reqFrame) {\n    this.channel = null;\n    this.conn = null;\n    this.start = null;\n    this.remoteAddr = null;\n    this.logger = null;\n    this.peer = null;\n    this.outreq = null;\n    this.reqFrame = null;\n    this.id = null;\n    this.serviceName = null;\n    this.callerName = null;\n    this.timeout = null;\n    this.alive = null;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.endpoint = null;\n    this.error = null;\n    this.tracing = null;\n    this.reqContFrames = [];\n    this.hasRead = null;\n    this.waitForIdentSlot = null;\n\n    this.boundExtendLogInfo = extendLogInfo;\n    this.boundOnIdentified = onIdentified;\n\n    var self = this;\n\n    function extendLogInfo(info) {\n        return self.extendLogInfo(info);\n    }\n\n    function onIdentified(err) {\n        // The ident descriptor will be cleared out of the peer when the ident\n        // comes back, so this slot id will be invalid once ident happens.\n        self.waitForIdentSlot = -1;\n\n        if (err) {\n            self.onError(err);\n        } else {\n            self.onIdentified();\n        }\n    }\n}\n\nLazyRelayInReq.prototype.reset = function reset(conn, reqFrame) {\n    this.channel = conn.channel;\n    this.conn = conn;\n    this.start = conn.timers.now();\n    this.remoteAddr = conn.remoteName;\n    this.logger = conn.logger;\n    this.peer = null;\n    this.outreq = null;\n    this.reqFrame = reqFrame;\n    this.id = this.reqFrame.id;\n    this.serviceName = '';\n    this.callerName = '';\n    this.timeout = 0;\n    this.alive = true;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.endpoint = '';\n    this.error = null;\n    this.tracing = null;\n    this.reqContFrames.length = 0;\n    this.hasRead = false;\n    this.circuit = reqFrame.circuit;\n    this.waitForIdentSlot = null;\n};\n\nLazyRelayInReq.prototype.clear = function clear() {\n    if (this.outreq && !this.outreq._objectPoolIsFreed) {\n        this.outreq.free();\n    }\n\n    if (this.peer && this.waitForIdentSlot !== null) {\n        this.peer.stopWaitingForIdentified(this.waitForIdentSlot);\n    }\n\n    this.channel = null;\n    this.conn = null;\n    this.start = null;\n    this.remoteAddr = null;\n    this.logger = null;\n    this.peer = null;\n    this.outreq = null;\n    this.reqFrame = null;\n    this.id = null;\n    this.serviceName = null;\n    this.callerName = null;\n    this.timeout = null;\n    this.alive = null;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.endpoint = null;\n    this.error = null;\n    this.tracing = null;\n    this.reqContFrames.length = 0;\n    this.hasRead = null;\n    this.circuit = null;\n    this.waitForIdentSlot = null;\n};\n\nObjectPool.setup({Type: LazyRelayInReq, maxSize: 200});\n\nLazyRelayInReq.prototype.type = 'tchannel.lazy.incoming-request';\n\nLazyRelayInReq.prototype.initRead =\nfunction initRead() {\n    var self = this;\n\n    if (self.hasRead) {\n        return null;\n    }\n    self.hasRead = true;\n\n    // TODO: wrap errors in protocol read errors?\n\n    var timeout = self.reqFrame.bodyRW.lazy.readTTL(self.reqFrame);\n    if (timeout <= 0) {\n        return errors.InvalidTTL({\n            ttl: timeout,\n            isParseError: true\n        });\n    }\n    self.timeout = timeout;\n\n    var serviceName = self.reqFrame.bodyRW.lazy\n        .readServiceStr(self.reqFrame);\n    if (!serviceName) {\n        return errors.BadCallRequestFrameError({\n            reason: 'Could not read service name',\n            lastError: self.reqFrame.cache.lastError\n        });\n    }\n    self.serviceName = serviceName;\n\n    var callerName = self.reqFrame.bodyRW.lazy\n        .readCallerNameStr(self.reqFrame);\n    if (!callerName) {\n        return errors.BadCallRequestFrameError({\n            reason: 'Could not read caller name',\n            lastError: self.reqFrame.cache.lastError\n        });\n    }\n    self.callerName = callerName;\n\n    var endpoint = self.reqFrame.bodyRW.lazy\n        .readArg1Str(self.reqFrame);\n    if (endpoint === null) {\n        return errors.BadCallRequestFrameError({\n            reason: 'Could not read arg1',\n            lastError: self.reqFrame.cache.lastError\n        });\n    }\n    self.endpoint = endpoint;\n\n    var tracing = self.reqFrame.bodyRW.lazy\n        .poolReadTracingValue(readRes, self.reqFrame);\n    self.tracing = tracing || v2.Tracing.emptyTracing;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.recvd',\n        'counter',\n        1,\n        new stat.InboundCallsRecvdTags(\n            self.callerName,\n            self.serviceName,\n            self.endpoint\n        )\n    );\n    self._observeCallReqFrame(self.reqFrame);\n\n    return null;\n};\n\nLazyRelayInReq.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    if (self.conn) {\n        info = self.conn.extendLogInfo(info);\n    }\n\n    if (self.outreq) {\n        info = self.outreq._extendLogInfo(info);\n    }\n\n    info = self._extendLogInfo(info);\n\n    return info;\n};\n\nLazyRelayInReq.prototype._extendLogInfo =\nfunction _extendLogInfo(info) {\n    var self = this;\n\n    if (self.conn) {\n        info = self.conn.extendLogInfo(info);\n    }\n\n    info.inRequestType = self.type;\n    info.inRequestRemoteAddr = self.remoteAddr;\n    info.inRequestId = self.id;\n    info.serviceName = self.serviceName;\n    info.callerName = self.callerName;\n    info.endpoint = self.endpoint;\n    info.inRequestErr = self.error;\n\n    return info;\n};\n\nLazyRelayInReq.prototype.logError =\nfunction relayRequestlogError(err, codeName) {\n    var self = this;\n\n    logError(self.conn.logger, err, codeName, self.boundExtendLogInfo);\n};\n\nLazyRelayInReq.prototype.onTimeout =\nfunction onTimeout(now) {\n    var self = this;\n\n    // ObjectPool weird free() issue; bail early\n    if (!self.channel) {\n        return;\n    }\n\n    self.onError(errors.RequestTimeoutError({\n        id: self.id,\n        start: self.start,\n        elapsed: now - self.start,\n        timeout: self.timeout\n    }));\n};\n\nLazyRelayInReq.prototype.createOutRequest =\nfunction createOutRequest() {\n    var self = this;\n\n    if (self.outreq) {\n        self.conn.logger.warn('relay request already started', self.extendLogInfo({}));\n        return;\n    }\n\n    var conn = self.peer.getInConnection(true);\n    if (conn && conn.remoteName && !conn.closing) {\n        self.forwardTo(conn);\n    } else {\n        self.waitForIdentSlot = self.peer.waitForIdentified(self.boundOnIdentified);\n    }\n};\n\nLazyRelayInReq.prototype.onIdentified =\nfunction onIdentified(err) {\n    var self = this;\n\n    if (err) {\n        self.onError(err);\n        return;\n    }\n\n    var conn = self.peer.getInConnection(true);\n    if (!conn) {\n        self.logger.warn(\n            'onIdentified called on non-existing connection',\n            self.extendLogInfo(self.peer.extendLogInfo({}))\n        );\n        self.onError(errors.NoPeerAvailable());\n        return;\n    }\n\n    if (!conn.remoteName) {\n        // we get the problem\n        self.logger.warn(\n            'onIdentified called on unidentified connection',\n            self.extendLogInfo(self.peer.extendLogInfo({}))\n        );\n    }\n    if (conn.closing) {\n        // most likely\n        self.logger.warn(\n            'onIdentified called on closing connection',\n            self.extendLogInfo(self.peer.extendLogInfo({}))\n        );\n    }\n\n    self.forwardTo(conn);\n};\n\nLazyRelayInReq.prototype.forwardTo =\nfunction forwardTo(conn) {\n    var self = this;\n\n    self.outreq = LazyRelayOutReq.alloc();\n    self.outreq.reset(conn, self);\n\n    var ttl = self.updateTTL(self.outreq.start);\n    if (!ttl || ttl < 0) {\n        // error or timeout, observability handled already by #updateTTL\n        return;\n    }\n\n    self.outreq.timeout = ttl;\n    conn.ops.addOutReq(self.outreq);\n    self.peer.invalidateScore('lazyInReq.forwardTo');\n    self.handleFrameLazily(self.reqFrame);\n    self.reqFrame = null;\n\n    for (var i = 0; i < self.reqContFrames.length; i++) {\n        self.handleFrameLazily(self.reqContFrames[i]);\n    }\n\n    self.reqContFrames.length = 0;\n\n    var now = self.channel.timers.now();\n    self.channel.emitFastStat(\n        'tchannel.relay.latency',\n        'timing',\n        now - self.start,\n        new stat.RelayLatencyTags()\n    );\n};\n\nLazyRelayInReq.prototype.updateTTL =\nfunction updateTTL(now) {\n    var self = this;\n\n    var elapsed = now - self.start;\n    var timeout = self.timeout - elapsed;\n\n    if (timeout <= 0) {\n        self.sendErrorFrame('Timeout', 'relay ttl expired');\n        // TODO: log/stat\n        return timeout;\n    }\n\n    if (self.channel.maximumRelayTTL !== 0 &&\n        timeout > self.channel.maximumRelayTTL\n    ) {\n        self.logger.warn(\n            'Clamping timeout to maximum ttl allowed',\n            self.extendLogInfo({\n                timeout: timeout,\n                maximumTTL: self.channel.maximumRelayTTL\n            })\n        );\n\n        timeout = self.channel.maximumRelayTTL;\n    }\n\n    var res = self.reqFrame.bodyRW.lazy.poolWriteTTL(writeRes, timeout, self.reqFrame);\n    if (res.err) {\n        // TODO: wrap? protocol write error?\n        self.onError(res.err);\n        return NaN;\n    }\n\n    return timeout;\n};\n\nLazyRelayInReq.prototype.onReadError =\nfunction onReadError(err) {\n    var self = this;\n\n    var hasError = !self.alive && self.error;\n    if (hasError) {\n        self.logger.warn(\n            'dropping read error from dead relay request',\n            self.extendLogInfo({\n                error: err\n            })\n        );\n    }\n\n    var conn = self.conn;\n    self.onError(err);\n\n    conn.resetAll(err);\n};\n\nLazyRelayInReq.prototype.onError =\nfunction onError(err) {\n    var self = this;\n\n    if (!self.alive && self.error) {\n        self.logger.warn('dropping error from dead relay request', self.extendLogInfo({\n            error: err\n        }));\n        self.free();\n        return;\n    }\n\n    if (self.circuit) {\n        self.circuit.state.onRequestError(err);\n    }\n\n    self.error = err;\n    self.alive = false;\n    var codeName = errors.classify(err) || 'UnexpectedError';\n    self.sendErrorFrame(codeName, err.message);\n    self.logError(err, codeName);\n    // TODO: stat in some cases, e.g. declined / peer not available\n    self.conn.ops.popInReq(self.id, self.extendLogInfo({\n        info: 'lazy relay request error',\n        relayDirection: 'in'\n    }));\n\n    self.reqContFrames.length = 0;\n\n    self.free();\n};\n\nLazyRelayInReq.prototype.sendErrorFrame =\nfunction sendErrorFrame(codeName, message) {\n    var self = this;\n\n    // ObjectPool weird free() issue; bail early\n    if (!self.channel) {\n        return;\n    }\n\n    var now = self.channel.timers.now();\n    self._observeInboundErrorFrame(now, codeName);\n\n    self.conn.sendLazyErrorFrame(self.id, self.tracing, codeName, message);\n};\n\nLazyRelayInReq.prototype.handleFrameLazily =\nfunction handleFrameLazily(frame) {\n    // frame.type will be one of:\n    // - v2.Types.CallRequest\n    // - v2.Types.CallRequestCont\n    var self = this;\n\n    if (!self.alive) {\n        self.logger.warn('dropping frame from dead relay request', self.extendLogInfo({}));\n        self.free();\n        return;\n    }\n\n    // We have not flushed the CallRequest yet.\n    // Probably waiting for init req/res blocking on out request conn.\n    if (frame.type === v2.Types.CallRequestCont && self.reqFrame !== null) {\n        self.reqContFrames.push(frame);\n        return;\n    }\n\n    frame.setId(self.outreq.id);\n    self.outreq.conn.writeToSocket(frame.buffer);\n    if (frame.bodyRW.lazy.isFrameTerminal(frame)) {\n        self.alive = false;\n        self.conn.ops.popInReq(self.id, self.extendLogInfo({\n            info: 'lazy relay request done',\n            relayDirection: 'in'\n        }));\n    }\n\n    if (frame.type === v2.Types.CallRequest) {\n        self._observeCallReqOutFrame(frame);\n    } else if (frame.type === v2.Types.CallRequestCont) {\n        self._observeCallReqContFrame(frame);\n    // } else { TODO: log\n    }\n};\n\nLazyRelayInReq.prototype._observeCallReqOutFrame =\nfunction _observeCallReqOutFrame(frame) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.request.size',\n        'counter',\n        frame.size,\n        new stat.OutboundRequestSizeTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.sent',\n        'counter',\n        1,\n        new stat.OutboundCallsSentTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n};\n\nLazyRelayInReq.prototype._observeInboundErrorFrame =\nfunction _observeInboundErrorFrame(now, codeName) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.latency',\n        'timing',\n        now - self.start,\n        new stat.InboundCallsLatencyTags(\n            self.callerName,\n            self.serviceName,\n            self.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.system-errors',\n        'counter',\n        1,\n        new stat.InboundCallsSystemErrorsTags(\n            self.callerName,\n            self.serviceName,\n            self.endpoint,\n            codeName\n        )\n    );\n};\n\nLazyRelayInReq.prototype._observeCallReqFrame =\nfunction _observeCallReqFrame(frame) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.request.size',\n        'counter',\n        frame.size,\n        new stat.InboundRequestSizeTags(\n            self.callerName,\n            self.serviceName,\n            self.endpoint\n        )\n    );\n};\n\nLazyRelayInReq.prototype._observeCallReqContFrame =\nfunction _observeCallReqContFrame(frame) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.request.size',\n        'counter',\n        frame.size,\n        new stat.InboundRequestSizeTags(\n            self.callerName,\n            self.serviceName,\n            self.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.request.size',\n        'counter',\n        frame.size,\n        new stat.OutboundRequestSizeTags(\n            self.serviceName,\n            self.callerName,\n            self.endpoint\n        )\n    );\n};\n\nfunction LazyRelayOutReq(conn, inreq) {\n    this.channel = null;\n    this.conn = null;\n    this.start = null;\n    this.remoteAddr = null;\n    this.logger = null;\n    this.inreq = null;\n    this.id = null;\n    this.serviceName = null;\n    this.callerName = null;\n    this.timeout = null;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.alive = null;\n}\n\nLazyRelayOutReq.prototype.reset = function reset(conn, inreq) {\n    this.channel = conn.channel;\n    this.conn = conn;\n    this.start = conn.timers.now();\n    this.remoteAddr = conn.remoteName;\n    this.logger = conn.logger;\n    this.inreq = inreq;\n    this.id = this.conn.nextFrameId();\n    this.serviceName = this.inreq.serviceName;\n    this.callerName = this.inreq.callerName;\n    this.timeout = 0;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.alive = true;\n};\n\nLazyRelayOutReq.prototype.clear = function clear() {\n    this.channel = null;\n    this.conn = null;\n    this.start = null;\n    this.remoteAddr = null;\n    this.logger = null;\n    this.inreq = null;\n    this.id = null;\n    this.serviceName = null;\n    this.callerName = null;\n    this.timeout = null;\n    this.operations = null;\n    this.timeHeapHandle = null;\n    this.alive = null;\n};\n\nObjectPool.setup({Type: LazyRelayOutReq, maxSize: 200});\n\nLazyRelayOutReq.prototype.type = 'tchannel.lazy.outgoing-request';\n\nLazyRelayOutReq.prototype.extendLogInfo =\nfunction extendLogInfo(info) {\n    var self = this;\n\n    if (self.conn) {\n        info = self.conn.extendLogInfo(info);\n    }\n\n    if (self.inreq) {\n        info = self.inreq._extendLogInfo(info);\n    }\n\n    info = self._extendLogInfo(info);\n\n    return info;\n};\n\nLazyRelayOutReq.prototype._extendLogInfo =\nfunction _extendLogInfo(info) {\n    var self = this;\n\n    info.requestType = self.type;\n    info.outRequestAddr = self.remoteAddr;\n    info.outRequestId = self.id;\n\n    return info;\n};\n\nLazyRelayOutReq.prototype.emitError =\nfunction emitError(err) {\n    var self = this;\n\n    // ObjectPool weird free() issue; bail early\n    if (!self.channel) {\n        return;\n    }\n\n    var now = self.channel.timers.now();\n    var elapsed = now - self.start;\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.per-attempt-latency',\n        'timing',\n        elapsed,\n        new stat.OutboundCallsPerAttemptLatencyTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint,\n            self.remoteAddr,\n            0\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.per-attempt.operational-errors',\n        'counter',\n        1,\n        new stat.OutboundCallsPerAttemptOperationalErrorsTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint,\n            err.type || 'unknown',\n            0\n        )\n    );\n\n    if (self.inreq.circuit) {\n        self.inreq.circuit.state.onRequestError(err);\n    }\n\n    // We need to defer the inreq onError work, because we might be\n    // *syncronously* processing an error after an attempt to write to a\n    // socket. Otherwise, we might end up freeing the in/outreq pair before a\n    // handleFrameLazily has completed.\n    process.nextTick(deferInReqOnError);\n    function deferInReqOnError() {\n        if (self.inreq) {\n            self.inreq.onError(err);\n        }\n    }\n};\n\nLazyRelayOutReq.prototype.logError =\nfunction relayRequestlogError(err, codeName) {\n    var self = this;\n\n    self.inreq.logError(err, codeName);\n};\n\nLazyRelayOutReq.prototype.onTimeout =\nfunction onTimeout(now) {\n    var self = this;\n\n    // ObjectPool weird free() issue; bail early\n    if (!self.conn) {\n        return;\n    }\n\n    self.conn.ops.checkLastTimeoutTime(now);\n    self.conn.ops.popOutReq(self.id, self.extendLogInfo({\n        info: 'lazy out request timed out',\n        relayDirection: 'out'\n    }));\n    self.inreq.peer.invalidateScore('lazyOutReq.onTimeout');\n\n    self.emitError(errors.RequestTimeoutError({\n        id: self.id,\n        start: self.start,\n        elapsed: now - self.start,\n        timeout: self.timeout\n    }));\n};\n\nLazyRelayOutReq.prototype.handleFrameLazily =\nfunction handleFrameLazily(frame) {\n    // frame.type will be one of:\n    // - v2.Types.CallResponse\n    // - v2.Types.CallResponseCont\n    // - v2.Types.ErrorResponse\n    var self = this;\n\n    // ObjectPool weird free() issue; bail early\n    if (!self.inreq) {\n        return;\n    }\n\n    frame.setId(self.inreq.id);\n    self.inreq.conn.writeToSocket(frame.buffer);\n    if (frame.bodyRW.lazy.isFrameTerminal(frame)) {\n        self.alive = false;\n        self.conn.ops.popOutReq(self.id, self.extendLogInfo({\n            info: 'lazy relay request done',\n            relayDirection: 'out'\n        }));\n        self.inreq.peer.invalidateScore('lazyOutReq.handleFrameLazily');\n    }\n\n    var now = self.channel.timers.now();\n    if (frame.type === v2.Types.CallResponse) {\n        self._observeCallResFrame(frame, now);\n    } else if (frame.type === v2.Types.CallResponseCont) {\n        self._observeCallResContFrame(frame, now);\n    } else if (frame.type === v2.Types.ErrorResponse) {\n        self._observeErrorFrame(frame, now);\n    // } else { TODO: log\n    }\n\n    if (!self.alive && !self.inreq.alive) {\n        // Implicitly frees this because inreq.clear will free outreq\n        self.inreq.free();\n    }\n};\n\nLazyRelayOutReq.prototype._observeErrorFrame =\nfunction _observeErrorFrame(errFrame, now) {\n    var self = this;\n\n    var res = errFrame.bodyRW.lazy.readCode(errFrame);\n    if (res.err) {\n        self.logger.error('failed to read error frame code', self.extendLogInfo({\n            error: res.err\n        }));\n        return;\n    }\n    var code = res.value;\n    var codeName = v2.ErrorResponse.CodeNames[code] || 'unknown';\n\n    if (self.inreq.circuit) {\n        if (errors.isUnhealthy(codeName)) {\n            self.inreq.circuit.state.onRequestUnhealthy();\n        } else {\n            self.inreq.circuit.state.onRequestHealthy();\n        }\n    }\n\n    self.inreq._observeInboundErrorFrame(now, codeName);\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.system-errors',\n        'counter',\n        1,\n        new stat.OutboundCallsSystemErrorsTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint,\n            codeName,\n            0\n        )\n    );\n\n    res = errFrame.bodyRW.lazy.readMessage(errFrame);\n    if (res.err) {\n        self.logger.error('failed to read error frame message', self.extendLogInfo({\n            error: res.err\n        }));\n        return;\n    }\n    var message = res.value;\n\n    // TODO: thinner logErrorFrame that doesn't need to instantiate an error\n    // just to log an error frame\n    var CodeErrorType = v2.ErrorResponse.CodeErrors[code];\n    var err = new CodeErrorType({\n        originalId: errFrame.id,\n        message: message\n    });\n    self.logError(err, errors.classify(err) || 'UnexpectedError');\n};\n\nLazyRelayOutReq.prototype._observeCallResFrame =\nfunction _observeCallResFrame(frame, now) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.response.size',\n        'counter',\n        frame.size,\n        new stat.InboundResponseSizeTags(\n            self.inreq.callerName,\n            self.inreq.serviceName,\n            self.inreq.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.response.size',\n        'counter',\n        frame.size,\n        new stat.OutboundResponseSizeTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.calls.latency',\n        'timing',\n        now - self.inreq.start,\n        new stat.InboundCallsLatencyTags(\n            self.inreq.callerName,\n            self.inreq.serviceName,\n            self.inreq.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.calls.per-attempt-latency',\n        'timing',\n        now - self.start,\n        new stat.OutboundCallsPerAttemptLatencyTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint,\n            self.remoteAddr,\n            0\n        )\n    );\n\n    if (self.inreq.circuit) {\n        self.inreq.circuit.state.onRequestHealthy();\n    }\n\n    var res = frame.bodyRW.lazy.poolReadCode(readRes, frame);\n    if (res.err) {\n        self.logger.error('failed to read error frame code', self.extendLogInfo({\n            error: res.err\n        }));\n        return;\n    }\n\n    var code = res.value;\n    var ok = code === 0;\n\n    if (ok) {\n        self.channel.emitFastStat(\n            'tchannel.inbound.calls.success',\n            'counter',\n            1,\n            new stat.InboundCallsSuccessTags(\n                self.inreq.callerName,\n                self.inreq.serviceName,\n                self.inreq.endpoint\n            )\n        );\n\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.success',\n            'counter',\n            1,\n            new stat.OutboundCallsSuccessTags(\n                self.inreq.serviceName,\n                self.inreq.callerName,\n                self.inreq.endpoint\n            )\n        );\n    } else {\n        self.channel.emitFastStat(\n            'tchannel.inbound.calls.app-errors',\n            'counter',\n            1,\n            new stat.InboundCallsAppErrorsTags(\n                self.inreq.callerName,\n                self.inreq.serviceName,\n                self.inreq.endpoint,\n                'unknown'\n            )\n        );\n\n        self.channel.emitFastStat(\n            'tchannel.outbound.calls.per-attempt.app-errors',\n            'counter',\n            1,\n            new stat.OutboundCallsPerAttemptAppErrorsTags(\n                self.inreq.serviceName,\n                self.inreq.callerName,\n                self.inreq.endpoint,\n                'unknown',\n                0\n            )\n        );\n    }\n};\n\nLazyRelayOutReq.prototype._observeCallResContFrame =\nfunction _observeCallResContFrame(frame, now) {\n    var self = this;\n\n    self.channel.emitFastStat(\n        'tchannel.inbound.response.size',\n        'counter',\n        frame.size,\n        new stat.InboundResponseSizeTags(\n            self.inreq.callerName,\n            self.inreq.serviceName,\n            self.inreq.endpoint\n        )\n    );\n\n    self.channel.emitFastStat(\n        'tchannel.outbound.response.size',\n        'counter',\n        frame.size,\n        new stat.OutboundResponseSizeTags(\n            self.inreq.serviceName,\n            self.inreq.callerName,\n            self.inreq.endpoint\n        )\n    );\n};\n\nfunction logError(logger, err, codeName, extendLogInfo) {\n    var level = errors.logLevel(err, codeName);\n\n    var info = extendLogInfo({\n        error: err,\n        isErrorFrame: err.isErrorFrame\n    });\n\n    if (err.isErrorFrame) {\n        if (level === 'warn') {\n            logger.warn('forwarding error frame', info);\n        } else if (level === 'info') {\n            logger.info('forwarding expected error frame', info);\n        }\n    } else if (level === 'error') {\n        logger.error('unexpected error while forwarding', info);\n    } else if (level === 'warn') {\n        logger.warn('error while forwarding', info);\n    } else if (level === 'info') {\n        logger.info('expected error while forwarding', info);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/monitor.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar format = require('util').format;\nvar inherits = require('util').inherits;\nvar console = require('console');\n\nmodule.exports.ChanConnMonitor = ChanConnMonitor;\n\nfunction ChanConnMonitor(channel, options) {\n    this.options = options;\n    this.channel = channel;\n    this.interval = options.interval;\n    this.byBucket = options.byBucket;\n    this.byTTL = options.byTTL;\n    this.timers = channel.timers;\n    this.timer = null;\n    this.running = false;\n\n    if (options.eachConn) {\n        this.eachConn = options.eachConn;\n    }\n    if (options.summary) {\n        this.summary = options.summary;\n    }\n    if (options.log) {\n        this.log = options.log;\n    }\n}\n\n/*eslint-disable no-console*/\nChanConnMonitor.prototype.log = console.log;\n/*eslint-enable no-console*/\n\nChanConnMonitor.prototype.summary = function summary() {\n};\n\nChanConnMonitor.prototype.run = function run() {\n    var self = this;\n\n    if (self.channel.destroyed) {\n        return;\n    }\n\n    self.running = true;\n    self.timer = self.timers.setTimeout(tickMe, self.interval);\n\n    function tickMe() {\n        self.tick();\n    }\n};\n\nChanConnMonitor.prototype.tick = function tick() {\n    var self = this;\n\n    self.timers.clearTimeout(self.timer);\n    self.timer = null;\n\n    if (!self.running) {\n        return;\n    }\n\n    if (self.channel.destroyed) {\n        self.running = false;\n        return;\n    }\n\n    if (self.eachConn) {\n        self.channel.peers.values().forEach(eachPeer);\n        if (self.channel.serverConnections) {\n            Object.keys(self.channel.serverConnections).forEach(eashServerConn);\n        }\n    }\n\n    self.summary({\n        channel: self.channel\n    });\n\n    self.timer = self.timers.setTimeout(tockMe, self.interval);\n\n    function eashServerConn(addr) {\n        var conn = self.channel.serverConnections[addr];\n        var connDesc = format('serverConn[%s]', addr);\n        self.eachConn({\n            channel: self.channel,\n            peer: null,\n            peerDesc: '',\n            conn: conn,\n            connDesc: connDesc\n        });\n    }\n\n    function eachPeer(peer, j) {\n        var peerDesc = format('peer[%s]', j);\n        peer.connections.forEach(function eachConn(conn, k) {\n            var connDesc = format('conn[%s]', k);\n            self.eachConn({\n                channel: self.channel,\n                peer: peer,\n                peerDesc: peerDesc,\n                conn: conn,\n                connDesc: connDesc\n            });\n        });\n    }\n\n    function tockMe() {\n        self.tick();\n    }\n};\n\nmodule.exports.OpKindMonitor = OpKindMonitor;\n\nfunction OpKindMonitor(channel, options) {\n    ChanConnMonitor.call(this, channel, options);\n    this.inCounts = [];\n    this.outCounts = [];\n}\n\ninherits(OpKindMonitor, ChanConnMonitor);\n\nOpKindMonitor.prototype.eachConn = function eachConn(stuff) {\n    var self = this;\n\n    var conn = stuff.conn;\n    var desc = conn.connDesc;\n    if (conn.peerDesc) {\n        desc = conn.peerDesc + ' ';\n    }\n    desc = format('relay %s %s', stuff.channel.hostPort, desc);\n\n    var inKeys = Object.keys(conn.ops.requests.in);\n    if (inKeys.length) {\n        var inCount = countConstructors(conn.ops.requests.in);\n        self.inCounts.push(inCount);\n    }\n\n    var outKeys = Object.keys(conn.ops.requests.out);\n    if (outKeys.length) {\n        var outCount = countConstructors(conn.ops.requests.out);\n        self.outCounts.push(outCount);\n    }\n};\n\nOpKindMonitor.prototype.summary = function summary() {\n    var self = this;\n\n    if (self.inCounts.length) {\n        self.log('= %s IN COUNTS: %j',\n                    self.options.desc,\n                    self.inCounts.reduce(sumCounts, {}));\n        self.inCounts.length = 0;\n    }\n\n    if (self.outCounts.length && self.byBucket) {\n        self.log('= %s OUT COUNTS BY BUCKET: %j',\n            self.options.desc,\n            reduceByBucket(self.outCounts, self.byBucket));\n    }\n\n    if (self.outCounts.length && self.byTTL) {\n        self.log('= %s OUT COUNTS BY TTL: %j',\n            self.options.desc,\n            reduceByTTL(self.outCounts));\n    }\n\n    if (self.outCounts.length) {\n        self.log('= %s OUT COUNTS: %j',\n                    self.options.desc,\n                    self.outCounts.reduce(sumCounts, {}));\n        self.outCounts.length = 0;\n    }\n};\n\nfunction reduceByBucket(list) {\n    var info = {};\n\n    for (var i = 0; i < list.length; i++) {\n        var constrs = list[i];\n\n        var keys = Object.keys(constrs);\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j];\n            var opCount = constrs[keys[j]];\n\n            if (!info[name]) {\n                info[name] = {};\n            }\n\n            var bucketKeys = Object.keys(opCount.buckets);\n            for (var k = 0; k < bucketKeys.length; k++) {\n                var bucketKey = bucketKeys[k];\n                if (!info[name][bucketKey]) {\n                    info[name][bucketKey] = 0;\n                }\n\n                info[name][bucketKey] += opCount.buckets[bucketKey].length;\n            }\n        }\n    }\n\n    return info;\n}\n\nfunction reduceByTTL(list) {\n    var info = {};\n\n    for (var i = 0; i < list.length; i++) {\n        var constrs = list[i];\n\n        var keys = Object.keys(constrs);\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j];\n            var opCount = constrs[keys[j]];\n\n            if (!info[name]) {\n                info[name] = {};\n            }\n\n            var timeoutKeys = Object.keys(opCount.timeouts);\n            for (var k = 0; k < timeoutKeys.length; k++) {\n                var timeoutKey = timeoutKeys[k];\n                if (!info[name][timeoutKey]) {\n                    info[name][timeoutKey] = 0;\n                }\n\n                info[name][timeoutKey] += opCount.timeouts[timeoutKey];\n            }\n        }\n    }\n\n    return info;\n}\n\nfunction sumCounts(a, b) {\n    Object.keys(b).forEach(function eachB(key) {\n        if (!a[key]) {\n            a[key] = 0;\n        }\n\n        a[key] += b[key].count;\n    });\n    return a;\n}\n\nfunction countConstructors(obj) {\n    var counts = {};\n    Object.keys(obj).forEach(function each(prop) {\n        var name = obj[prop].constructor.name;\n        if (!counts[name]) {\n            counts[name] = new OpCount();\n        }\n\n        counts[name].push(obj[prop]);\n    });\n    return counts;\n}\n\nfunction OpCount() {\n    this.count = 0;\n    this.values = [];\n    this.buckets = {};\n    this.timeouts = {};\n}\n\nOpCount.prototype.push = function push(value) {\n    this.count++;\n    this.values.push(value);\n\n    if (value.type === 'tchannel.operation.tombstone') {\n        var expireTime = value.time + value.timeout;\n\n        var bucketIndex = Math.floor(expireTime / 5000) * 5000;\n        if (!this.buckets[bucketIndex]) {\n            this.buckets[bucketIndex] = [];\n        }\n        this.buckets[bucketIndex].push(value);\n    }\n\n    if (value.type === 'tchannel.operation.tombstone') {\n        var ttl = value.timeout;\n\n        if (!this.timeouts[ttl]) {\n            this.timeouts[ttl] = 0;\n        }\n\n        this.timeouts[ttl]++;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/relay_handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar errors = require('./errors');\nvar stat = require('./stat-tags.js');\n\nvar LazyRelayInReq = require('./lazy_relay.js').LazyRelayInReq;\nvar logError = require('./lazy_relay.js').logError;\n\nRelayHandler.RelayRequest = RelayRequest;\n\nmodule.exports = RelayHandler;\n\nfunction RelayHandler(channel, circuits) {\n    this.channel = channel;\n    this.circuits = circuits || null;\n    this.logger = this.channel.logger;\n    this.lazyEnabled = this.channel.options.useLazyRelaying;\n}\n\nRelayHandler.prototype.type = 'tchannel.relay-handler';\n\nRelayHandler.prototype.handleLazily = function handleLazily(conn, reqFrame) {\n    var self = this;\n\n    if (!self.lazyEnabled) {\n        return false;\n    }\n\n    var rereq = LazyRelayInReq.alloc();\n    rereq.reset(conn, reqFrame);\n\n    var err = rereq.initRead();\n    if (err) {\n        rereq.onReadError(err);\n        return true;\n    }\n\n    rereq.peer = self.channel.peers.choosePeer(null);\n    if (!rereq.peer) {\n        rereq.sendErrorFrame('Declined', 'no peer available for request');\n        self.logger.info('no relay peer available', rereq.extendLogInfo({}));\n        rereq.free();\n        return true;\n    }\n\n    conn.ops.addInReq(rereq);\n    rereq.createOutRequest();\n\n    return true;\n};\n\nRelayHandler.prototype.handleRequest = function handleRequest(req, buildRes) {\n    var self = this;\n\n    req.forwardTrace = true;\n\n    var peer = self.channel.peers.choosePeer(null);\n    if (!peer) {\n        // TODO: stat\n        // TODO: allow for customization of this message so hyperbahn can\n        // augment it with things like \"at entry node\", \"at exit node\", etc\n        buildRes().sendError('Declined', 'no peer available for request');\n        self.logger.info('no relay peer available', req.extendLogInfo({}));\n        return;\n    }\n\n    var rereq = new RelayRequest(self.channel, peer, req, buildRes);\n    rereq.createOutRequest();\n};\n\nfunction RelayRequest(channel, peer, inreq, buildRes) {\n    this.channel = channel;\n    this.logger = this.channel.logger;\n    this.inreq = inreq;\n    this.inres = null;\n    this.outres = null;\n    this.outreq = null;\n    this.buildRes = buildRes;\n    this.peer = peer;\n    this.error = null;\n\n    this.boundOnError = onError;\n    this.boundExtendLogInfo = extendLogInfo;\n    this.boundOnIdentified = onIdentified;\n\n    var self = this;\n    inreq.timeoutEvent.on(onTimeout);\n\n    function onTimeout(err) {\n        self.onInRequestTimeout(err);\n    }\n\n    function onError(err) {\n        self.onError(err);\n    }\n\n    function extendLogInfo(info) {\n        return self.extendLogInfo(info);\n    }\n\n    function onIdentified(err) {\n        if (err) {\n            self.onError(err);\n        } else {\n            self.onIdentified();\n        }\n    }\n}\n\nRelayRequest.prototype.createOutRequest = function createOutRequest() {\n    var self = this;\n\n    if (self.outreq) {\n        self.logger.warn('relay request already started', self.extendLogInfo({}));\n        return;\n    }\n\n    self.peer.waitForIdentified(self.boundOnIdentified);\n};\n\nRelayRequest.prototype.onIdentified = function onIdentified() {\n    var self = this;\n\n    var conn = self.peer.getInConnection(true);\n    if (!conn.remoteName) {\n        // we get the problem\n        self.logger.error('onIdentified called on no connection identified', {\n            hostPort: self.peer.hostPort\n        });\n    }\n    if (conn.closing) {\n        // most likely\n        self.logger.error('onIdentified called on connection closing', {\n            hostPort: self.peer.hostPort\n        });\n    }\n\n    var elapsed = self.channel.timers.now() - self.inreq.start;\n    var timeout = Math.max(self.inreq.timeout - elapsed, 1);\n\n    if (self.channel.maximumRelayTTL !== 0 &&\n        timeout > self.channel.maximumRelayTTL\n    ) {\n        self.logger.warn(\n            'Clamping timeout to maximum ttl allowed',\n            self.extendLogInfo({\n                timeout: timeout,\n                maximumTTL: self.channel.maximumRelayTTL\n            })\n        );\n\n        timeout = self.channel.maximumRelayTTL;\n    }\n\n    // TODO use a type for this literal\n    self.outreq = self.channel.request({\n        peer: self.peer,\n        streamed: self.inreq.streamed,\n        timeout: timeout,\n        parent: self.inreq,\n        tracing: self.inreq.tracing,\n        checksum: self.inreq.checksum,\n        forwardTrace: true,\n        serviceName: self.inreq.serviceName,\n        headers: self.inreq.headers,\n        retryFlags: self.inreq.retryFlags\n    });\n    self.outreq.responseEvent.on(onResponse);\n    self.outreq.errorEvent.on(self.boundOnError);\n\n    if (self.outreq.streamed) {\n        self.outreq.sendStreams(self.inreq.arg1, self.inreq.arg2, self.inreq.arg3);\n    } else {\n        self.outreq.send(self.inreq.arg1, self.inreq.arg2, self.inreq.arg3);\n    }\n\n    self.channel.emitFastStat(\n        'tchannel.relay.latency',\n        'timing',\n        elapsed,\n        new stat.RelayLatencyTags()\n    );\n\n    function onResponse(res) {\n        self.onResponse(res);\n    }\n};\n\nRelayRequest.prototype.createOutResponse = function createOutResponse(options) {\n    var self = this;\n    if (self.outres) {\n        self.logger.warn('relay request already responded', self.extendLogInfo({\n            error: self.error,\n            options: options // TODO: seems like a Bad Idea ™\n        }));\n        return null;\n    }\n\n    // It is possible that the inreq gets reaped with a timeout\n    // It is also possible that the out request gets repead with a timeout\n    // Both the in & out req try to create an outgoing response\n    if (self.inreq.res && self.inreq.res.codeString === 'Timeout') {\n        self.logger.debug('relay request already timed out', {\n            codeString: self.inreq.res.codeString,\n            responseMessage: self.inreq.res.message,\n            serviceName: self.outreq && self.outreq.serviceName,\n            arg1: self.outreq && String(self.outreq.arg1),\n            outRemoteAddr: self.outreq && self.outreq.remoteAddr,\n            inRemoteAddr: self.inreq.remoteAddr,\n            inSocketRemoteAddr: self.inreq.connection.socketRemoteAddr,\n            error: self.error\n        });\n        return null;\n    }\n\n    self.outres = self.buildRes(options);\n\n    return self.outres;\n};\n\nRelayRequest.prototype.onResponse = function onResponse(res) {\n    var self = this;\n\n    if (self.inres) {\n        self.logger.warn('relay request got more than one response callback', {\n            // TODO: better context\n            remoteAddr: res.remoteAddr,\n            id: res.id\n        });\n        return;\n    }\n    self.inres = res;\n\n    if (!self.createOutResponse({\n        streamed: self.inres.streamed,\n        headers: self.inres.headers,\n        code: self.inres.code\n    })) {\n        return;\n    }\n\n    if (self.outres.streamed) {\n        self.inres.arg2.pipe(self.outres.arg2);\n        self.inres.arg3.pipe(self.outres.arg3);\n    } else {\n        self.outres.send(self.inres.arg2, self.inres.arg3);\n    }\n};\n\nRelayRequest.prototype.onError = function onError(err) {\n    var self = this;\n\n    if (self.error) {\n        self.logger.warn('Unexpected double onError', self.inreq.extendLogInfo({\n            error: err,\n            oldError: self.error\n        }));\n    }\n    self.error = err;\n\n    if (!self.createOutResponse()) {\n        return;\n    }\n    var codeName = errors.classify(err) || 'UnexpectedError';\n\n    self.outres.sendError(codeName, err.message);\n    self.logError(err, codeName);\n};\n\nRelayRequest.prototype.onInRequestTimeout =\nfunction onInRequestTimeout(err) {\n    var self = this;\n\n    var codeName = errors.classify(err) || 'UnexpectedError';\n    self.logError(err, codeName);\n};\n\nRelayRequest.prototype.extendLogInfo = function extendLogInfo(info) {\n    var self = this;\n\n    // XXX does inreq give:\n    // info.remoteAddr = self.inreq.remoteAddr;\n    // info.id = self.inreq.id;\n    info.outRemoteAddr = self.outreq && self.outreq.remoteAddr;\n    info = self.inreq.extendLogInfo(info);\n\n    return info;\n};\n\nRelayRequest.prototype.logError = function relayRequestLogError(err, codeName) {\n    var self = this;\n\n    logError(self.logger, err, codeName, self.boundExtendLogInfo);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/as/http.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar bufrw = require('bufrw');\nvar http = require('http');\nvar extend = require('xtend');\nvar extendInto = require('xtend/mutable');\nvar errors = require('../errors.js');\nvar stat = require('../stat-tags.js');\nvar getRawBody = require('raw-body');\n\nvar headerRW = bufrw.Repeat(bufrw.UInt16BE,\n    bufrw.Series(bufrw.str2, bufrw.str2));\n\nmodule.exports = TChannelHTTP;\n\nfunction HTTPReqArg2(method, url, headerPairs) {\n    var self = this;\n    self.method = method || '';\n    self.url = url || '';\n    self.headerPairs = headerPairs || [];\n}\n\nHTTPReqArg2.RW = bufrw.Struct(HTTPReqArg2, {\n    method: bufrw.str1,   // method~1\n    url: bufrw.strn,      // url~N\n    headerPairs: headerRW // numHeaders:2 (headerName~2 headerValue~2){numHeaders}\n});\n\nfunction HTTPResArg2(statusCode, message, headerPairs) {\n    var self = this;\n    self.statusCode = statusCode || 0;\n    self.message = message || '';\n    self.headerPairs = headerPairs || [];\n}\n\nHTTPResArg2.RW = bufrw.Struct(HTTPResArg2, {\n    statusCode: bufrw.UInt16BE, // statusCode:2\n    message: bufrw.strn,        // message~N\n    headerPairs: headerRW       // numHeaders:2 (headerName~2 headerValue~2){numHeaders}\n});\n\n// per RFC2616\n/*eslint-disable complexity*/\nHTTPReqArg2.prototype.getHeaders =\nHTTPResArg2.prototype.getHeaders =\nfunction getHeaders() {\n    var self = this;\n    var headers = {};\n    for (var i = 0; i < self.headerPairs.length; i++) {\n        var pair = self.headerPairs[i];\n        var key = pair[0];\n        var val = pair[1];\n        key = key.toLowerCase();\n        switch (key) {\n            case 'set-cookie':\n                if (headers[key] !== undefined) {\n                    headers[key].push(val);\n                } else {\n                    headers[key] = [val];\n                }\n                break;\n            case 'content-type':\n            case 'content-length':\n            case 'user-agent':\n            case 'referer':\n            case 'host':\n            case 'authorization':\n            case 'proxy-authorization':\n            case 'if-modified-since':\n            case 'if-unmodified-since':\n            case 'from':\n            case 'location':\n            case 'max-forwards':\n                // drop duplicates\n                if (headers[key] === undefined) {\n                    headers[key] = val;\n                }\n                break;\n            default:\n                // make comma-separated list\n                if (headers[key] !== undefined) {\n                    headers[key] += ', ' + val;\n                } else {\n                    headers[key] = val;\n                }\n        }\n    }\n    return headers;\n    /*eslint-enable complexity*/\n};\n\n/*eslint-disable complexity*/\nHTTPReqArg2.prototype.setHeaders =\nHTTPResArg2.prototype.setHeaders =\nfunction setHeaders(headers) {\n    var self = this;\n    self.headerPairs = [];\n    var keys = Object.keys(headers);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var val = headers[key];\n        switch (key) {\n            case 'set-cookie':\n                for (var j = 0; j < val.length; j++) {\n                    self.headerPairs.push([key, val[j]]);\n                }\n                break;\n            case 'content-type':\n            case 'content-length':\n            case 'user-agent':\n            case 'referer':\n            case 'host':\n            case 'authorization':\n            case 'proxy-authorization':\n            case 'if-modified-since':\n            case 'if-unmodified-since':\n            case 'from':\n            case 'location':\n            case 'max-forwards':\n                // no duplicates\n                self.headerPairs.push([key, val]);\n                break;\n            default:\n                // prase comma-separated list\n                val = val.split(', ');\n                for (var k = 0; k < val.length; k++) {\n                    self.headerPairs.push([key, val[k]]);\n                }\n        }\n    }\n};\n/*eslint-enable complexity*/\n\nfunction TChannelHTTP(options) {\n    if (!(this instanceof TChannelHTTP)) {\n        return new TChannelHTTP(options);\n    }\n    var self = this;\n    if (options) {\n        self.lbpool = options.lbpool;\n    }\n}\n\n/*eslint-disable max-statements*/\nTChannelHTTP.prototype.sendRequest = function send(treq, hreq, start, options, callback) {\n    var self = this;\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    var req;\n    var arg2res;\n\n    var head = new HTTPReqArg2(hreq.method, hreq.url);\n    head.setHeaders(hreq.headers);\n\n    var arg1 = ''; // TODO: left empty for now, could compute circuit names heuristically\n    arg2res = bufrw.toBufferResult(HTTPReqArg2.RW, head);\n    if (arg2res.err) {\n        self.logger.error('Buffer write for arg2 failed', {\n            error: arg2res.err\n        });\n        var toBufferErr = errors.HTTPReqArg2toBufferError(arg2res.err, {\n            head: head\n        });\n        callback(toBufferErr, null, null);\n        return null;\n    }\n    var arg2 = arg2res.value;\n\n    treq.headers.as = 'http';\n    if (treq.streamed) {\n        req = treq.sendStreams(arg1, arg2, hreq, onStreamResponse);\n        self.channel.emitFastStat(\n            'tchannel.http-handler.egress.request-build-latency',\n            'timing',\n            self.channel.timers.now() - start,\n            new stat.HTTPHanlderBuildLatencyTags(\n                treq.serviceName,\n                treq.callerName,\n                treq.streamed\n            )\n        );\n        return req;\n    }\n    getRawBody(hreq, {\n        length: hreq.headers['content-length'],\n        limit: '20mb'\n    }, onRawBody);\n\n    function onRawBody(err, body) {\n        if (err) {\n            callback(err, null, null, null);\n            return err;\n        }\n        req = treq.send(arg1, arg2, body, onResponse);\n        self.channel.emitFastStat(\n            'tchannel.http-handler.egress.request-build-latency',\n            'timing',\n            self.channel.timers.now() - start,\n            new stat.HTTPHanlderBuildLatencyTags(\n                treq.serviceName,\n                treq.callerName,\n                treq.streamed\n            )\n        );\n        return req;\n    }\n\n    function onResponse(err, tres, res1, res2) {\n        var now = self.channel.timers.now();\n        if (err) {\n            callback(err, null, null, null);\n        } else {\n            readArg2(tres, res1, now);\n        }\n    }\n\n    function onStreamResponse(err1, treq2, tres) {\n        var now = self.channel.timers.now();\n        if (err1) {\n            callback(err1, null, null, null);\n        } else if (tres.streamed) {\n            tres.arg2.onValueReady(arg2Ready);\n        } else {\n            arg2Ready(null, tres.arg2);\n        }\n        function arg2Ready(err2, res1) {\n            if (err2) {\n                callback(err2, null, null, null);\n            } else {\n                readArg2(tres, res1, now);\n            }\n        }\n    }\n\n    function readArg2(tres, res1, start2) {\n        arg2res = bufrw.fromBufferResult(HTTPResArg2.RW, res1);\n        if (arg2res.err) {\n            self.logger.error('Buffer read for arg2 failed', {\n                error: arg2res.err\n            });\n            var fromBufferErr = errors.HTTPReqArg2fromBufferError(arg2res.err, {\n                arg2: res1\n            });\n            callback(fromBufferErr, null, null, null);\n        } else {\n            if (tres.streamed) {\n                callback(null, arg2res.value, tres.arg3, null);\n            } else {\n                callback(null, arg2res.value, null, tres.arg3);\n            }\n            self.channel.emitFastStat(\n                'tchannel.http-handler.egress.response-build-latency',\n                'timing',\n                self.channel.timers.now() - start2,\n                new stat.HTTPHanlderBuildLatencyTags(\n                    treq.serviceName,\n                    treq.callerName,\n                    treq.streamed\n                )\n            );\n        }\n    }\n};\n/*eslint-enable max-statements*/\n\nTChannelHTTP.prototype.sendResponse = function send(buildResponse, hres, body, statTags, callback) {\n    // TODO: map http response codes onto error frames and application errors\n    var self = this;\n    var start = self.channel.timers.now();\n    var head = new HTTPResArg2(hres.statusCode, hres.statusMessage);\n    head.setHeaders(hres.headers);\n    var arg2res = bufrw.toBufferResult(HTTPResArg2.RW, head);\n    if (arg2res.err) {\n        self.logger.error('Buffer write for arg2 failed', {\n            error: arg2res.err\n        });\n        var toBufferErr = errors.HTTPResArg2toBufferError(arg2res.err, {\n            head: head\n        });\n        callback(toBufferErr);\n        return null;\n    }\n    var arg2 = arg2res.value;\n    if (body) {\n        buildResponse({\n            streamed: false,\n            headers: {\n                as: 'http'\n            }\n        }).sendOk(arg2, body);\n        callback(null);\n        self.channel.emitFastStat(\n            'tchannel.http-handler.ingress.response-build-latency',\n            'timing',\n            self.channel.timers.now() - start,\n            statTags\n        );\n        return null;\n    }\n\n    var res = buildResponse({\n        streamed: true,\n        headers: {\n            as: 'http'\n        }\n    }).sendStreams(arg2, hres, callback);\n    self.channel.emitFastStat(\n        'tchannel.http-handler.ingress.response-build-latency',\n        'timing',\n        self.channel.timers.now() - start,\n        statTags\n    );\n    return res;\n};\n\nTChannelHTTP.prototype.setHandler = function register(tchannel, handler) {\n    var self = this;\n    self.logger = tchannel.logger;\n    self.channel = tchannel;\n    tchannel.handler = new AsHTTPHandler(self, tchannel, handler);\n    return tchannel.handler;\n};\n\nTChannelHTTP.prototype.forwardToTChannel = function forwardToTChannel(tchannel, hreq, hres, requestOptions, callback) {\n    var self = this;\n    self.channel = self.channel || tchannel;\n    self.logger = self.logger || tchannel.logger;\n    var start = self.channel.timers.now();\n    var treq;\n    // TODO: more http state machine integration\n\n    var options = tchannel.requestOptions(extendInto({\n        hasNoParent: true\n    }, requestOptions));\n\n    if (!options.streamed) {\n        treq = tchannel.request(options);\n        return self.sendRequest(treq, hreq, start, forwarded);\n    }\n\n    var peer = tchannel.peers.choosePeer(null);\n    if (!peer) {\n        self._sendHTTPError(hres, errors.NoPeerAvailable());\n        callback(errors.NoPeerAvailable());\n        return null;\n    }\n\n    peer.waitForIdentified(onIdentified);\n    function onIdentified(err) {\n        if (err) {\n            self._sendHTTPError(hres, err);\n            callback(err);\n            return null;\n        }\n\n        options.host = peer.hostPort;\n        treq = tchannel.request(options);\n        self.sendRequest(treq, hreq, start, forwarded);\n    }\n\n    function forwarded(err, head, bodyStream, bodyArg) {\n        if (err) {\n            self._sendHTTPError(hres, err);\n        } else {\n            var headers = head.getHeaders();\n            // work-arround a node issue where default statusMessage is missing\n            // from the client side when server side set as optional parameter\n            if (head.message) {\n                hres.writeHead(head.statusCode, head.message, headers);\n            } else {\n                hres.writeHead(head.statusCode, headers);\n            }\n            if (bodyStream !== null) {\n                if (bodyStream._readableState.ended) {\n                    bodyStream.onValueReady(function onValue(err2, buffer) {\n                        if (err2) {\n                            return self._sendHTTPError(hres, err2);\n                        }\n\n                        hres.write(buffer);\n                        hres.end();\n                    });\n                } else {\n                    bodyStream.pipe(hres);\n                }\n            } else {\n                hres.end(bodyArg);\n            }\n        }\n        callback(err);\n    }\n};\n\nTChannelHTTP.prototype._sendHTTPError = function _sendHTTPError(hres, error) {\n    hres.setHeader('Content-Type', 'text/plain');\n    var codeName = errors.classify(error);\n    var httpInfo = errors.toHTTPCode(codeName);\n\n    hres.writeHead(httpInfo.statusCode, httpInfo.statusMessage);\n    hres.end(error.message);\n};\n\nTChannelHTTP.prototype.forwardToHTTP = function forwardToHTTP(tchannel, options, inreq, outres, callback) {\n    var self = this;\n    self.logger = self.logger || tchannel.logger;\n    var headers = inreq.head.getHeaders();\n    options = extend(options, {\n        method: inreq.head.method,\n        path: inreq.head.url,\n        headers: headers,\n        keepAlive: true\n    });\n    if (self.lbpool) {\n        self._forwardToLBPool(options, inreq, outres, callback);\n    } else {\n        self._forwardToNodeHTTP(options, inreq, outres, callback);\n    }\n};\n\nTChannelHTTP.prototype._forwardToLBPool = function _forwardToLBPool(options, inreq, outres, callback) {\n    var self = this;\n    var start = self.channel.timers.now();\n    if (!options) {\n        options = {};\n    }\n    options.encoding = null;\n    var data = inreq.bodyStream || inreq.bodyArg; // lb_pool likes polymorphism\n\n    if (inreq.bodyArg) {\n        delete options.headers['transfer-encoding'];\n    }\n\n    self.lbpool.request(options, data, onResponse);\n\n    function onResponse(err, res, body) {\n        if (err) {\n            self.logger.warn('Forwarding to LBPool failed', {\n                error: err\n            });\n            outres.sendError(err);\n            callback(err);\n            return;\n        }\n        outres.sendResponse(res, body);\n        callback(null);\n        self.channel.emitFastStat(\n            'tchannel.http-handler.ingress.service-call-latency',\n            'timing',\n            self.channel.timers.now() - start,\n            new stat.HTTPHanlderBuildLatencyTags(\n                inreq.serviceName,\n                inreq.callerName,\n                false\n            )\n        );\n    }\n};\n\nTChannelHTTP.prototype._forwardToNodeHTTP = function _forwardToNodeHTTP(options, inreq, outres, callback) {\n    var self = this;\n    var start = self.channel.timers.now();\n    var sent = false;\n    var outreq = http.request(options, onResponse);\n    outreq.on('error', onError);\n    // TODO: more http state machine integration\n\n    if (inreq.bodyStream !== null) {\n        inreq.bodyStream.pipe(outreq);\n    } else {\n        outreq.end(inreq.bodyArg);\n    }\n\n    function onResponse(inres) {\n        if (!sent) {\n            sent = true;\n            outres.sendResponse(inres);\n            callback(null);\n            self.channel.emitFastStat(\n                'tchannel.http-handler.ingress.service-call-latency',\n                'timing',\n                self.channel.timers.now() - start,\n                new stat.HTTPHanlderBuildLatencyTags(\n                    inreq.serviceName,\n                    inreq.callerName,\n                    true\n                )\n            );\n        }\n    }\n\n    function onError(err) {\n        if (!sent) {\n            sent = true;\n            self.logger.warn('Forwarding to HTTP failed', {\n                error: err\n            });\n            outres.sendError(err);\n            callback(err);\n        }\n    }\n};\n\nfunction AsHTTPHandler(asHTTP, channel, handler) {\n    if (typeof handler === 'function') {\n        handler = {handleRequest: handler}; // TODO: explicate type?\n    }\n    var self = this;\n    self.asHTTP = asHTTP;\n    self.channel = channel;\n    self.handler = handler;\n    self.logger = self.channel.logger;\n}\n\nAsHTTPHandler.prototype.handleRequest = function handleRequest(req, buildResponse) {\n    var self = this;\n    var start = self.channel.timers.now();\n    // TODO: explicate type\n    var hreq = {\n        url: req.arg1,\n        head: null,\n        bodyArg: null,\n        bodyStream: null\n    };\n    req.withArg2(onArg2);\n\n    function onArg2(err, arg2) {\n        if (err) {\n            sendError(err);\n            return;\n        }\n\n        var arg2res = bufrw.fromBufferResult(HTTPReqArg2.RW, arg2);\n        if (arg2res.err) {\n            self.logger.error('Buffer read for arg2 failed', {\n                error: arg2res.err\n            });\n            var fromBufferErr = errors.HTTPResArg2fromBufferError(arg2res.err, {\n                arg2: arg2\n            });\n            sendError(fromBufferErr);\n            return;\n        }\n\n        hreq.head = arg2res.value;\n        if (req.streamed) {\n            hreq.bodyStream = req.arg3;\n        } else {\n            hreq.bodyArg = req.arg3;\n        }\n\n        handle();\n    }\n\n    var sent = false;\n    req.errorEvent.on(onError);\n    function onError(err) {\n        sent = true;\n        self.logger.warn('Handling request failed', {\n            error: err\n        });\n    }\n\n    function handle() {\n        // TODO: explicate type\n        var hres = {\n            head: new HTTPResArg2(200, 'Ok'),\n            sendError: sendError,\n            sendResponse: sendResponse\n        };\n\n        self.channel.emitFastStat(\n            'tchannel.http-handler.ingress.request-build-latency',\n            'timing',\n            self.channel.timers.now() - start,\n            new stat.HTTPHanlderBuildLatencyTags(\n                req.serviceName,\n                req.callerName,\n                req.streamed\n            )\n        );\n        hreq.serviceName = req.serviceName;\n        hreq.callerName = req.callerName;\n        self.handler.handleRequest(hreq, hres);\n    }\n\n    function sendResponse(hres, body) {\n        if (!sent) {\n            sent = true;\n            var statsTag = new stat.HTTPHanlderBuildLatencyTags(\n                req.serviceName,\n                req.callerName,\n                body ? false : true\n            );\n            self.asHTTP.sendResponse(buildResponse, hres, body, statsTag, sendError);\n        }\n    }\n\n    function sendError(err) {\n        if (!sent) {\n            sent = true;\n            self.logger.warn('Handling request failed', {\n                error: err\n            });\n            var codeString = errors.classify(err);\n            buildResponse().sendError(\n                codeString ? codeString : 'UnexpectedError', err.message);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/bench_server.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = require('process');\nprocess.title = 'nodejs-benchmarks-bench_server';\n\nvar readBenchConfig = require('./read-bench-config.js');\nvar assert = require('assert');\nvar Statsd = require('uber-statsd-client');\nvar setTimeout = require('timers').setTimeout;\n\nvar Reporter = require('../tcollector/reporter.js');\nvar TChannel = require('../channel');\nvar RandomSample = require('./random_sample.js');\n\nvar argv = readBenchConfig({\n    boolean: ['trace']\n}, {\n    pingOverhead: 'none',\n    setOverhead: 'none',\n    getOverhead: 'none'\n});\n\nvar SERVER_HOST = '127.0.0.1';\n\nassert(argv.port, 'port needed');\nassert(argv.instances, 'instances needed');\n\nvar overhead = {};\noverhead.ping = parseOverhead(argv.pingOverhead);\noverhead.set = parseOverhead(argv.setOverhead);\noverhead.get = parseOverhead(argv.getOverhead);\n\nassert('trace' in argv, 'trace option needed');\nif (argv.trace) {\n    assert(argv.traceRelayHostPort, 'traceRelayHostPort needed');\n}\n\nvar INSTANCES = parseInt(argv.instances, 10);\nvar STATS_PORT = parseInt(argv.statsdPort, 10);\n\nfunction BenchServer(port) {\n    if (!(this instanceof BenchServer)) {\n        return new BenchServer(port);\n    }\n\n    var self = this;\n\n    self.port = port;\n    self.server = TChannel({\n        statTags: {\n            app: 'my-server'\n        },\n        trace: true,\n        logger: require('debug-logtron')('server'),\n        traceSample: argv.trace ? 1 : 0.01,\n        emitConnectionMetrics: false,\n        statsd: new Statsd({\n            host: '127.0.0.1',\n            port: STATS_PORT\n        })\n    });\n\n    if (argv.trace) {\n        self.setupReporter();\n    }\n\n    self.serverChan = self.server.makeSubChannel({\n        traceSample: argv.trace ? 1 : 0.01,\n        serviceName: 'benchmark'\n    });\n\n    self.keys = {};\n\n    self.registerEndpoints();\n}\n\nBenchServer.prototype.setupReporter = function setupReporter() {\n    var self = this;\n\n    var reporter = Reporter({\n        channel: self.server.makeSubChannel({\n            serviceName: 'tcollector',\n            peers: [argv.traceRelayHostPort]\n        }),\n        logger: self.server.logger,\n        callerName: 'my-server'\n    });\n\n    self.server.tracer.reporter = function report(span) {\n        reporter.report(span, {\n            timeout: 10 * 1000\n        });\n    };\n};\n\nBenchServer.prototype.registerEndpoints = function registerEndpoints() {\n    var self = this;\n\n    var pingEndpoint = onPing;\n    var setEndpoint = onSet;\n    var getEndpoint = onGet;\n\n    if (overhead.ping) {\n        pingEndpoint = withDelay(onPing, overhead.ping);\n    }\n    if (overhead.set) {\n        setEndpoint = withDelay(onSet, overhead.set);\n    }\n    if (overhead.get) {\n        getEndpoint = withDelay(onGet, overhead.get);\n    }\n\n    self.serverChan.register('ping', pingEndpoint);\n    self.serverChan.register('set', setEndpoint);\n    self.serverChan.register('get', getEndpoint);\n\n    self.serverChan.register('bad_set', onBad);\n    self.serverChan.register('bad_get', onBad);\n\n    function onSet(req, res, arg2, arg3) {\n        var key = arg2.toString('utf8');\n        var val = arg3.toString('utf8');\n        self.keys[key] = val;\n        res.headers.as = 'raw';\n        res.sendOk('ok', 'really ok');\n    }\n\n    function onGet(req, res, arg2, arg3) {\n        var key = arg2.toString('utf8');\n        res.headers.as = 'raw';\n        if (self.keys[key] !== undefined) {\n            var val = self.keys[key];\n            res.sendOk(val.length.toString(10), val);\n        } else {\n            res.sendNotOk('key not found', key);\n        }\n    }\n};\n\nfunction onPing(req, res) {\n    res.headers.as = 'raw';\n    res.sendOk('pong', null);\n}\n\nfunction onBad(req, res, arg2, arg3) {\n    res.headers.as = 'raw';\n    res.sendError('BadRequest', 'parse error');\n}\n\nBenchServer.prototype.listen = function listen() {\n    var self = this;\n\n    self.server.listen(self.port, SERVER_HOST);\n};\n\nfor (var i = 0; i < INSTANCES; i++) {\n    var port = parseInt(argv.port, 10) + i;\n\n    var benchServer = BenchServer(port);\n    benchServer.listen();\n}\n\nfunction parseOverhead(str) {\n    if (str === 'none') {\n        return null;\n    } else {\n        return RandomSample.fromString(str);\n    }\n}\n\nfunction withDelay(handler, delay) {\n    return delayedHandler;\n\n    function delayedHandler(req, res, arg2, arg3) {\n        var t = delay();\n        setTimeout(runHandler, t);\n        function runHandler() {\n            handler(req, res, arg2, arg3);\n        }\n    }\n}\n\n// setInterval(function () {\n//  Object.keys(keys).forEach(function (key) {\n//      console.log(key + '=' + keys[key].length + ' bytes');\n//  });\n// }, 1000);\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/read-bench-config.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* eslint-disable no-console, no-process-env */\n\nvar fs = require('fs');\nvar parseArgs = require('minimist');\nvar path = require('path');\nvar process = require('process');\n\nvar extractPartsList = require('../lib/part-list.js').extractPartsList;\n\nmodule.exports = readBenchConfig;\n\n// TODO: use a topo-sorter to correctly resolve merge order, due to cases like:\n//\n// A extends C\n// B extends C\n//\n// now say C sets foo => 1\n//         A sets foo => 2\n//\n// then the order \"A,B\" will have the incorrect foo value of 1 since B\n// inherited its parent, and then merged into A overriding it.\n\nfunction readBenchConfig(minimistOpts, defaults) {\n    var opts = defaults || {};\n    if (process.env.BENCH_CONFIG) {\n        var configParts = extractPartsList(process.env.BENCH_CONFIG);\n        opts = mergeConfig(opts, loadConfigParts(configParts.all()));\n    }\n    if (minimistOpts && minimistOpts.boolean) {\n        var def = minimistOpts.defaults || (minimistOpts.defaults = {});\n        for (var i = 0; i < minimistOpts.boolean.length; i++) {\n            var key = minimistOpts.boolean[i];\n            def[key] = opts[key] === undefined ? def[key] || false : opts[key];\n        }\n        delete minimistOpts.boolean;\n    }\n    opts = mergeConfig(opts, parseArgs(process.argv.slice(2), minimistOpts));\n    return opts;\n}\n\nfunction loadConfigParts(parts) {\n    var opts = {};\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n        var partPath = path.resolve(part);\n        opts = mergeConfig(opts, loadConfigPart(partPath));\n    }\n    return opts;\n}\n\nfunction loadConfigPart(part) {\n    var data = JSON.parse(fs.readFileSync(part));\n    if (data._extends) {\n        var extendsPath = path.resolve(path.dirname(part), data._extends);\n        data = mergeConfig(loadConfigPart(extendsPath), data);\n    }\n    return data;\n}\n\nfunction mergeConfig(a, b) {\n    a.remoteConfig = mergeRemoteConfig(a.remoteConfig, b.remoteConfig);\n    for (var key in b) {\n        if (b.hasOwnProperty(key)) {\n            if (key !== 'remoteConfig') {\n                a[key] = b[key];\n            }\n        }\n    }\n    return a;\n}\n\nfunction mergeRemoteConfig(a, b) {\n    if (!a || !a.length) {\n        return b || [];\n    }\n\n    if (!b || !b.length) {\n        return a;\n    }\n\n    var r = [];\n    var i;\n    var item;\n    var seen = {};\n\n    for (i = 0; i < b.length; i++) {\n        item = b[i];\n        if (!seen[item.key]) {\n            seen[item.key] = true;\n            r.push(item);\n        }\n    }\n\n    for (i = 0; i < a.length; i++) {\n        item = a[i];\n        if (!seen[item.key]) {\n            seen[item.key] = true;\n            r.push(item);\n        }\n    }\n\n    return r;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/part-list.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports.extractParts = extractParts;\nmodule.exports.extractPartsList = extractPartsList;\n\nfunction extractParts(str) {\n    var parts = [];\n    forEachPart(str, function eachPart(part) {\n        parts.push(part);\n    });\n    return new Parts(parts);\n}\n\nfunction extractPartsList(str) {\n    var list = [];\n    forEachSubstr(',', str, function eachComponent(component) {\n        var parts = extractParts(component);\n        list.push(parts);\n    });\n    return new PartsList(list);\n}\n\nfunction forEachSubstr(sep, str, each) {\n    var start = 0;\n    var level = 0;\n    for (var i = 0; i < str.length; i++) {\n        switch (str[i]) {\n            case '{':\n                level++;\n                break;\n            case '}':\n                if (--level < 0) {\n                    level = 0;\n                }\n                break;\n            case sep:\n                if (level === 0) {\n                    if (i > start) {\n                        each(str.slice(start, i));\n                    }\n                    start = i + 1;\n                }\n                break;\n            default:\n        }\n    }\n    if (start < str.length) {\n        each(str.slice(start));\n    }\n}\n\nfunction forEachPart(str, each) {\n    var i = 0;\n    var pat = /\\{(.+?)\\}/g;\n    var match = pat.exec(str);\n    while (match) {\n        var j = match.index;\n        var string = str.slice(i, j);\n        var choice = match[1].split(',');\n        each(new Part(string, choice));\n        i = j + match[0].length;\n        match = pat.exec(str);\n    }\n    each(new Part(str.slice(i), null));\n}\n\nfunction PartsList(list) {\n    this.list = list;\n}\n\nPartsList.prototype.inspect =\nPartsList.prototype.toString =\nfunction partsListToString() {\n    return 'PartsList(' + this.list.toString() + ')';\n};\n\nPartsList.prototype.each =\nfunction each(it) {\n    for (var i = 0; i < this.list.length; i++) {\n        this.list[i].each(it);\n    }\n};\n\nfunction Parts(parts) {\n    this.parts = parts;\n}\n\nParts.prototype.inspect =\nParts.prototype.toString =\nfunction partsToString() {\n    return 'Parts(' + this.parts.toString() + ')';\n};\n\nParts.prototype.each =\nfunction each(it) {\n    var self = this;\n\n    buildPart('', 0, it);\n\n    function buildPart(prefix, i, emit) {\n        var part = self.parts[i];\n        if (!part) {\n            emit(prefix);\n            return;\n        }\n        part.each(function eachSubPart(str) {\n            buildPart(prefix + str, i + 1, emit);\n        });\n    }\n};\n\nfunction Part(string, choice) {\n    this.string = string || '';\n    this.choice = choice || null;\n}\n\nPart.prototype.inspect =\nPart.prototype.toString =\nfunction partToString() {\n    return 'Part(' + this.string + ', ' + this.choice + ')';\n};\n\nPart.prototype.each =\nfunction each(it) {\n    if (!this.choice) {\n        it(this.string);\n        return;\n    }\n    for (var i = 0; i < this.choice.length; i++) {\n        it(this.string + this.choice[i]);\n    }\n};\n\nPartsList.prototype.all =\nParts.prototype.all =\nPart.prototype.all =\nallEach;\n\nfunction allEach() {\n    var items = [];\n    this.each(function each(item) {\n        items.push(item);\n    });\n    return items;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/compare.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar parseArgs = require('minimist');\nvar fs = require('fs');\nvar ldj = require('ldjson-stream');\nvar parallel = require('run-parallel');\nvar util = require('util');\nvar process = require('process');\nvar console = require('console');\n\n/*eslint no-console: 0*/\n\nvar argv = parseArgs(process.argv.slice(2), {\n    default: {\n         stat: 'rate'\n    }\n});\n\nif (argv._.length !== 2) {\n    console.error('usage: compare.js a.json b.json');\n    /*eslint-disable no-process-exit*/\n    process.exit(1);\n    /*eslint-enable no-process-exit*/\n}\n\nreadSamples(argv._, function onSamples(err, samples) {\n    if (err) {\n        throw err;\n    }\n\n    var keys = {};\n    var maxKeyLen = 0;\n    samples.forEach(function forSample(sample) {\n        Object.keys(sample).forEach(function forSampleKey(key) {\n            maxKeyLen = Math.max(maxKeyLen, key.length);\n            keys[key] = true;\n        });\n    });\n\n    var sampleA = samples[0];\n    var sampleB = samples[1];\n    Object.keys(keys).sort().forEach(function compareSample(key) {\n        var aData = sampleA[key];\n        var bData = sampleB[key];\n        if (aData === undefined) {\n            console.error(util.format('sampleA data missing for key %j', key));\n            return;\n        }\n        if (bData === undefined) {\n            console.error(util.format('sampleB data missing for key %j', key));\n            return;\n        }\n\n        aData = extractDim(argv.stat, aData);\n        if (aData.missing) {\n            console.error(util.format(\n                'sampleA data missing %s values for stat %s for key %j',\n                aData.missing, argv.stat, key));\n            return;\n        }\n        aData = aData.data;\n\n        bData = extractDim(argv.stat, bData);\n        if (bData.missing) {\n            console.error(util.format(\n                'sampleB data missing %s values for stat %s for key %j',\n                bData.missing, argv.stat, key));\n            return;\n        }\n        bData = bData.data;\n\n        // TODO: improve on this\n        var aStats = descStats(aData);\n        var bStats = descStats(bData);\n        var diff = bStats.whi - aStats.whi;\n        var diffPct = diff / aStats.whi;\n        console.log(util.format(\n            '%s %s: hi-diff: %s (%s%%)',\n            rpad(key, maxKeyLen),\n            argv.stat,\n            lpad(diff.toFixed(2), 9),\n            lpad((100 * diffPct).toFixed(1), 5)\n        ));\n    });\n});\n\n// return basic descriptive stats of some numerical sample\nfunction descStats(sample) {\n    var S = [].concat(sample);\n    S.sort(function sortOrder(a, b) {\n        return a - b;\n    });\n    var N = S.length;\n    var q1 = S[Math.floor(0.25 * N)];\n    var q2 = S[Math.floor(0.50 * N)];\n    var q3 = S[Math.floor(0.70 * N)];\n    var iqr = q3 - q1;\n    var tol = 3 * iqr / 2;\n    var hi = q3 + tol;\n    var whiIndex = N;\n    while (--whiIndex > 0) {\n        if (S[whiIndex] <= hi) {\n            break;\n        }\n    }\n    var whiPct = (whiIndex + 1) / N;\n    var whi = S[whiIndex];\n    return {\n        min: S[0],\n        max: S[N - 1],\n        q1: q1,\n        q2: q2,\n        q3: q3,\n        hi: hi,\n        whi: whi,\n        whiPct: whiPct\n    };\n}\n\nfunction readSamples(files, callback) {\n    parallel(files.map(function forEachFile(file) {\n        return function thunk(done) {\n            var sample = {};\n            fs.createReadStream(file)\n                .pipe(ldj.parse())\n                .on('data', storeResultInto(sample))\n                .on('error', finish)\n                .on('end', finish);\n\n            function finish(err) {\n                sample = combineSamples(sample);\n\n                done(err, sample);\n            }\n        };\n    }), callback);\n}\n\nfunction combineSamples(sample) {\n    var keys = Object.keys(sample);\n\n    // For each type of test\n    for (var i = 0; i < keys.length; i++) {\n        var instancesData = sample[keys[i]];\n        var results = [];\n\n        // For each child process\n        var subKeys = Object.keys(instancesData);\n        for (var j = 0; j < subKeys.length; j++) {\n            var value = instancesData[subKeys[j]];\n\n            // For each run of that test\n            for (var k = 0; k < value.length; k++) {\n                var statObj = value[k];\n\n                if (!results[k]) {\n                    results[k] = {\n                        numRequests: statObj.numRequests,\n                        elapsed: statObj.elapsed,\n                        rate: statObj.numRequests / (statObj.elapsed / 1000)\n                    };\n                } else {\n                    results[k].numRequests += statObj.numRequests;\n                    results[k].elapsed = Math.min(\n                        results[k].elapsed, statObj.elapsed\n                    );\n                    results[k].rate = results[k].numRequests / (results[k].elapsed / 1000);\n                }\n            }\n        }\n\n        sample[keys[i]] = results;\n    }\n\n    return sample;\n}\n\nfunction storeResultInto(sample) {\n    return function storeResult(result) {\n        var key = util.format('%s, %s/%s',\n            result.descr, result.pipeline, result.numClients\n        );\n\n        var results = sample[key];\n        if (!results) {\n            results = sample[key] = {};\n        }\n\n        var instanceArray = results[result.instanceNumber];\n        if (!instanceArray) {\n            instanceArray = results[result.instanceNumber] = [];\n        }\n\n        instanceArray.push(result);\n    };\n}\n\nfunction lpad(input, len, chr) {\n    var str = input.toString();\n    chr = chr || ' ';\n    while (str.length < len) {\n        str = chr + str;\n    }\n    return str;\n}\n\nfunction rpad(input, len, chr) {\n    var str = input.toString();\n    chr = chr || ' ';\n    while (str.length < len) {\n        str = str + chr;\n    }\n    return str;\n}\n\nfunction extractDim(name, sample) {\n    var missing = 0;\n    var data = sample.map(function forSample(item) {\n        var d = item[name];\n        if (d === undefined) {\n            ++missing;\n        }\n        return d;\n    });\n    return {\n        missing: missing,\n        data: data\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/d8_peer_heap.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nfunction Range(lo, hi) {\n    var self = this;\n\n    self.lo = lo;\n    self.hi = hi;\n}\n\n// Scale this range by another range\nRange.prototype.multiply = function multiply(range) {\n    var self = this;\n\n    var diff = self.hi - self.lo;\n\n    self.hi = self.lo + (range.hi * diff);\n    self.lo += (range.lo * diff);\n};\n\nRange.prototype.inspect = \nRange.prototype.toString = function toString() {\n    var self = this;\n\n    return \"Range(\" + self.lo + \", \" + self.hi + \")\";\n};\n\n// A max-score (pre-computed) for peer selection\n\n// This is used for every DFS. It will end up being the size of the largest\n// peer list.\nvar dfsStack = [0, 1, 2];\n\nfunction PeerHeap() {\n    var self = this;\n\n    self.array = [];\n    self.rangehis = [];\n    self.rangelos = [];\n}\n\nPeerHeap.prototype.chooseWeightedRandom = function chooseWeightedRandom(threshold, filter) {\n    var self = this;\n\n    var chosenPeer = null;\n    var maxRangeStart = self.array[0].range.lo;\n    var highestProbability = 0;\n    var firstScore = self.array[0].peer.getScore();\n    var stackBegin = 0;\n    var stackEnd = 0;\n\n    if (firstScore > threshold && (!filter || filter(self.array[0].peer))) {\n        chosenPeer = self.array[0].peer;\n        highestProbability = firstScore;\n        stackBegin = 1;\n        stackEnd = 2;\n    } \n\n    while (stackBegin <= stackEnd) {\n        var i = dfsStack[stackBegin];\n        stackBegin++;\n\n        var el = self.array[i];\n\n        if (self.rangehis[i] <= maxRangeStart) {\n            // This range ends before the range with the largest start begins,\n            // so it can't possibly be chosen over any of the ranges we've\n            // seen. All ranges below this one have a smaller end, so this\n            // range and any below it can't be chosen.\n            continue;\n        } else if (!filter || filter(el.peer)) {\n            maxRangeStart = Math.max(maxRangeStart, self.rangelos[i]);\n\n            var lo = self.rangelos[i];\n            var hi = self.rangehis[i];\n            var probability = lo + ((hi - lo) * Math.random());\n\n            if ((probability > highestProbability) && (probability > threshold)) {\n                highestProbability = probability;\n                chosenPeer = el.peer;\n            }\n        }\n\n        var left = 2 * i + 1;\n        var right = left + 1;\n        if (left < self.array.length) {\n            dfsStack[++stackEnd] = left;\n            if (right < self.array.length) {\n                dfsStack[++stackEnd] = right;\n            }\n        }\n    }\n\n    return chosenPeer;\n};\n\nPeerHeap.prototype.choose = function choose(threshold, filter) {\n    var self = this;\n\n    if (!self.array.length) {\n        return null;\n    }\n\n    return self.chooseWeightedRandom(threshold, filter);\n};\n\nPeerHeap.prototype.clear = function clear() {\n    var self = this;\n\n    for (var i = 0; i < self.array.length; i++) {\n        var el = self.array[i];\n        el.heap = null;\n        el.peer = null;\n        el.score = 0;\n        el.index = 0;\n        el.range = null;\n    }\n    self.array.length = 0;\n};\n\nPeerHeap.prototype.add = function add(peer) {\n    var self = this;\n\n    var range = peer.scoreRange;\n    var i = self.push(peer, range);\n    var el = self.array[i];\n    return el;\n};\n\nPeerHeap.prototype.rescore = function rescore() {\n    var self = this;\n\n    for (var i = 0; i < self.array.length; i++) {\n        var el = self.array[i];\n        el.range = el.peer.getScoreRange();\n        el.score = el.range.hi;\n    }\n    self.heapify();\n};\n\nPeerHeap.prototype.heapify = function heapify() {\n    var self = this;\n\n    if (self.array.length <= 1) {\n        return;\n    }\n\n    for (var i = Math.floor(self.array.length / 2 - 1); i >= 0; i--) {\n        self.siftdown(i);\n    }\n};\n\nPeerHeap.prototype.remove = function remove(i) {\n    var self = this;\n\n    if (i >= self.array.length) {\n        return;\n    }\n\n    if (self.array.length === 1) {\n        self.array.pop();\n        return;\n    }\n\n    var j = self.array.length - 1;\n    if (i === j) {\n        self.array.pop();\n        return;\n    }\n\n    self.swap(i, j);\n    self.array.pop();\n    self.siftup(i);\n};\n\nPeerHeap.prototype.push = function push(peer, range) {\n    var self = this;\n\n    var el = new PeerHeapElement(self);\n    el.peer = peer;\n    el.range = range;\n    el.score = range.hi;\n    el.index = self.array.length;\n\n    self.array.push(el);\n    return self.siftup(el.index);\n};\n\nPeerHeap.prototype.pop = function pop() {\n    var self = this;\n    var peer = null;\n\n    if (!self.array.length) {\n        return peer;\n    }\n\n    if (self.array.length === 1) {\n        peer = self.array.pop();\n        return peer;\n    }\n\n    peer = self.array[0].peer;\n    self.array[0] = self.array.pop();\n    self.siftdown(0);\n\n    return peer;\n};\n\nPeerHeap.prototype.siftdown = function siftdown(i) {\n    var self = this;\n\n    while (true) {\n        var left = (2 * i) + 1;\n        if (left >= self.array.length) {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            return i;\n        }\n\n        var right = left + 1;\n        var child = left;\n        if (right < self.array.length &&\n            self.array[right].score > self.array[left].score) {\n            child = right;\n        }\n\n        if (self.array[child].score > self.array[i].score) {\n            self.swap(i, child);\n            i = child;\n        } else {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            return i;\n        }\n    }\n};\n\nPeerHeap.prototype.siftup = function siftup(i) {\n    var self = this;\n\n    while (i > 0) {\n        var par = Math.floor((i - 1) / 2);\n        if (self.array[i].score > self.array[par].score) {\n            self.swap(i, par);\n            i = par;\n        } else {\n            self.rangehis[i] = self.array[i].range.hi;\n            self.rangelos[i] = self.array[i].range.lo;\n            return i;\n        }\n    }\n\n    self.rangehis[0] = self.array[0].range.hi;\n    self.rangelos[0] = self.array[0].range.lo;\n\n    return 0;\n};\n\nPeerHeap.prototype.swap = function swap(i, j) {\n    var self = this;\n\n    var a = self.array[i];\n    var b = self.array[j];\n\n    self.array[i] = b;\n    self.array[j] = a;\n    b.index = i;\n    a.index = j;\n};\n\nfunction PeerHeapElement(heap) {\n    var self = this;\n\n    self.heap = heap;\n    self.peer = null;\n    self.score = 0;\n    self.index = 0;\n    self.range = null;\n}\n\nPeerHeapElement.prototype.rescore = function rescore(range) {\n    var self = this;\n\n    if (!self.heap) {\n        return;\n    }\n\n    if (!range) {\n        self.range = self.peer.scoreRange;\n    } else {\n        self.range = range;\n    }\n\n    self.score = self.range.hi;\n    self.index = self.heap.siftup(self.index);\n    self.index = self.heap.siftdown(self.index);\n};\n\nfunction rand(lo, hi) {\n    return Math.floor(Math.random() * (hi - lo + 1) + lo);\n    //return (lcg.rand() % (hi - lo + 1)) + lo;\n}\n\nfunction Peer() {\n    if (!(this instanceof Peer)) {\n        return new Peer();\n    }\n    var self = this;\n\n    self.scoreRange = null;\n    self.pendingCount = 0;\n    self.randPending();\n    self.el = null;\n}\n\nPeer.prototype.getScoreRange = function getScoreRange() {\n    var self = this;\n\n    return self.scoreRange;\n};\n\nPeer.prototype.randPending = function randPending() {\n    var self = this;\n\n    self.pendingCount = rand(0, 10);\n    //var nums = [rand(0, 100), rand(0, 100)];\n    var nums = [Math.random(), Math.random()];\n    self.scoreRange = new Range(\n        Math.min(nums[0], nums[1]),\n        Math.max(nums[0], nums[1])\n    );\n};\n\nPeer.prototype.getScore = function getScore() {\n    var self = this;\n    var diff = self.scoreRange.hi - self.scoreRange.lo;\n    //var num = rand(self.scoreRange.lo, self.scoreRange.hi);\n    var score = self.scoreRange.lo + diff * Math.random();\n    return score;\n};\n\nfunction benchmark(numPeers, numChoices) {\n    var heap = new PeerHeap();\n    var i;\n    var peers = [];\n    var heapEls = [];\n    var newPeer;\n    var el;\n\n    for (i = 0; i < numPeers; i++) {\n        newPeer = new Peer();\n        el = heap.add(newPeer);\n        heapEls.push(el);\n        newPeer.el = el;\n        peers.push(newPeer);\n    }\n\n    var start = Date.now();\n\n    for (i = 0; i < numChoices; i++) {\n        var choice = heap.choose(0, noop);\n        if (choice) {\n            choice.randPending();\n            choice.el.rescore();\n        } else {\n            print(\"no choice!\");\n        }\n    }\n\n    var time = Date.now() - start;\n\n    return time;\n}\n\nfunction noop () { return true; }\n\n//while (true) {\n    print(\"benchmark(1000, 50000):\", benchmark(1000, 1000000));\n//}\n//print(\"benchmark(1000, 10000000):\", benchmark(1000, 1000000000));\n\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/multi_bench.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n/* eslint no-console:0 no-process-exit:0 */\n\nvar Statsd = require('uber-statsd-client');\nvar metrics = require('metrics');\nvar process = require('process');\nvar setTimeout = require('timers').setTimeout;\nvar Buffer = require('buffer').Buffer;\nvar console = require('console');\n\nprocess.title = 'nodejs-benchmarks-multi_bench';\n\nvar readBenchConfig = require('./read-bench-config.js');\nvar TChannel = require('../channel');\nvar Reporter = require('../tcollector/reporter.js');\nvar base2 = require('../test/lib/base2');\nvar LCGStream = require('../test/lib/rng_stream');\nvar errors = require('../errors.js');\n\n// TODO: disentangle the global closure of numClients and numRequestss and move\n// these after the harness class declaration\nvar argv = readBenchConfig({\n    alias: {\n        m: 'multiplicity',\n        c: 'numClients',\n        r: 'numRequests',\n        p: 'pipeline',\n        s: 'sizes'\n    },\n    boolean: ['relay', 'trace', 'bad']\n}, {\n    multiplicity: 1,\n    numClients: 5,\n    numRequests: 20000,\n    pipeline: '10,100,1000,20000',\n    sizes: '4,4096'\n});\n\nvar multiplicity = parseInt(argv.multiplicity, 10);\nvar numClients = parseInt(argv.numClients, 10);\nvar numRequests = parseInt(argv.numRequests, 10);\nargv.pipeline = parseIntList(argv.pipeline);\nargv.sizes = parseIntList(argv.sizes);\n\nvar DESTINATION_SERVER;\nvar DESTINATION_PORT;\nvar TRACE_SERVER;\nvar CLIENT_PORT = argv.clientPort;\nvar INSTANCES = 0;\n\nif (argv.relay) {\n    DESTINATION_SERVER = '127.0.0.1:' + argv.relayServerPort;\n} else {\n    DESTINATION_SERVER = '127.0.0.1:' + argv.benchPort;\n    DESTINATION_PORT = argv.benchPort;\n    INSTANCES = parseInt(argv.instances, 10);\n}\n\nif (argv.trace) {\n    TRACE_SERVER = '127.0.0.1:7037';\n}\n\n// -- test harness\n\nfunction Test(args) {\n    this.args = args;\n\n    this.arg1 = new Buffer(args.command);\n    this.arg2 = args.arg2 || null;\n    this.arg3 = args.arg3 || null;\n\n    this.callback = null;\n    this.clients = [];\n    this.clientsReady = 0;\n    this.commandsSent = 0;\n    this.commandsCompleted = 0;\n    this.maxPipeline = this.args.pipeline || numRequests;\n    this.clientOptions = args.clientOptions || {\n        returnBuffers: false\n    };\n\n    this.connectLatency = new metrics.Histogram();\n    this.readyLatency = new metrics.Histogram();\n    this.commandLatency = new metrics.Histogram();\n\n    this.expectedError = args.expectedError;\n}\n\nTest.prototype.copy = function copy() {\n    return new Test(this.args);\n};\n\nTest.prototype.run = function run(callback) {\n    var self = this;\n    var i;\n\n    this.callback = callback;\n\n    var counter = numClients;\n    for (i = 0; i < numClients; i++) {\n        self.newClient(i, onReady);\n    }\n\n    function onReady(err) {\n        if (err) {\n            // TODO: wrap error \"failed to setup clients\"\n            callback(err);\n            return;\n        }\n\n        counter--;\n        if (counter === 0) {\n            self.start(callback);\n        }\n    }\n};\n\nTest.prototype.newClient = function newClient(id, callback) {\n    var self = this;\n    var port = CLIENT_PORT + id;\n    var clientChan = TChannel({\n        statTags: {\n            app: 'my-client'\n        },\n        logger: require('debug-logtron')('client'),\n        emitConnectionMetrics: false,\n        trace: true,\n        traceSample: argv.trace ? 1 : 0.01,\n        statsd: new Statsd({\n            host: '127.0.0.1',\n            port: 7036\n        })\n    });\n\n    // // useful for demonstrating (lack of) tombstone leak\n    // var OpKindMonitor = require('../monitor').OpKindMonitor;\n    // (new OpKindMonitor(clientChan, {\n    //     log: console.error,\n    //     desc: 'client:' + id,\n    //     interval: 5000,\n    // })).run();\n\n    if (argv.trace) {\n        var reporter = Reporter({\n            channel: clientChan.makeSubChannel({\n                serviceName: 'tcollector',\n                peers: [TRACE_SERVER]\n            }),\n            logger: clientChan.logger,\n            callerName: 'my-client'\n        });\n\n        clientChan.tracer.reporter = function report(span) {\n            reporter.report(span, {\n                timeout: 10 * 1000\n            });\n        };\n    }\n\n    var peers = [DESTINATION_SERVER];\n    if (INSTANCES > 0) {\n        peers = [];\n        var basePort = DESTINATION_PORT;\n        for (var i = 0; i < INSTANCES; i++) {\n            peers.push('127.0.0.1:' + (basePort + i));\n        }\n    }\n\n    var client = clientChan.makeSubChannel({\n        serviceName: 'benchmark',\n        peers: peers,\n        traceSample: argv.trace ? 1 : 0.01,\n        minConnections: INSTANCES > 0 ? 10 : 1\n    });\n    client.createTime = Date.now();\n    clientChan.listen(port, '127.0.0.1', function listened(err) {\n        if (err) {\n            return callback(err);\n        }\n        self.clients[id] = client;\n        // sending a ping to pre-connect the socket\n        client\n            .request({\n                serviceName: 'benchmark',\n                hasNoParent: true,\n                timeout: 30 * 1000,\n                headers: {\n                    as: 'raw',\n                    cn: 'multi_bench'\n                }\n            })\n            .send('ping', null, null, function pinged(err2) {\n                if (err2) {\n                    return callback(err2);\n                }\n                self.connectLatency.update(Date.now() - client.createTime);\n                self.readyLatency.update(Date.now() - client.createTime);\n                callback();\n            });\n    });\n};\n\nTest.prototype.start = function start(callback) {\n    this.testStart = Date.now();\n    this.fillPipeline(callback);\n};\n\nTest.prototype.fillPipeline = function fillPipeline(callback) {\n    var pipeline = this.commandsSent - this.commandsCompleted;\n\n    while (this.commandsSent < numRequests && pipeline < this.maxPipeline) {\n        this.commandsSent++;\n        pipeline++;\n        this.sendNext();\n    }\n\n    if (this.commandsCompleted === numRequests) {\n        this.printStats();\n        this.stopClients(callback);\n    }\n};\n\nTest.prototype.stopClients = function stopClients(callback) {\n    var self = this;\n\n    var count = 1;\n\n    setTimeout(function delayCloseByFudgeFactor() {\n        self.clients.forEach(function each(client) {\n            count++;\n            (client.topChannel || client).quit(closed);\n        });\n        closed();\n    }, 1000);\n\n    function closed() {\n        if (--count <= 0) {\n            self.callback(null);\n        }\n    }\n};\n\nTest.prototype.sendNext = function sendNext() {\n    var self = this;\n    var curClient = this.commandsSent % this.clients.length;\n    var start = Date.now();\n\n    var req = this.clients[curClient].request({\n        serviceName: 'benchmark',\n        hasNoParent: true,\n        timeout: 30000,\n        headers: {\n            as: 'raw',\n            cn: 'multi_bench',\n            benchHeader1: 'bench value one',\n            benchHeader2: 'bench value two',\n            benchHeader3: 'bench value three'\n        }\n    });\n    req.send(this.arg1, this.arg2, this.arg3, done);\n\n    function done(err, res) {\n        if (err) {\n            if (!self.expectedError ||\n                !self.expectedError(err, req, res)) {\n                throw err;\n            }\n        }\n        self.commandsCompleted++;\n        self.commandLatency.update(Date.now() - start);\n        self.fillPipeline(onRageQuit);\n    }\n};\n\nTest.prototype.getStats = function getStats() {\n    var obj = this.commandLatency.printObj();\n    obj.descr = this.args.descr;\n    obj.instanceNumber = argv.instanceNumber;\n    obj.pipeline = this.args.pipeline;\n    obj.numClients = this.clientsReady;\n    obj.elapsed = Date.now() - this.testStart;\n    obj.numRequests = numRequests;\n    obj.rate = numRequests / (obj.elapsed / 1000);\n    return obj;\n};\n\nTest.prototype.printStats = function printStats() {\n    var obj = this.getStats();\n    process.stdout.write(JSON.stringify(obj) + '\\n');\n};\n\n// -- define tests\n\nvar tests = [];\n\nif (!argv.skipPing) {\n    argv.pipeline.forEach(function each(pipeline) {\n        tests.push(new Test({\n            descr: 'PING',\n            command: 'ping',\n            args: null,\n            pipeline: pipeline\n        }));\n    });\n}\n\nvar randBytes = new LCGStream({\n    seed: 1234,\n    limit: Infinity\n});\n\nargv.sizes.forEach(function each(size) {\n    var sizeDesc = base2.pretty(size, 'B');\n    var key = 'foo_rand000000000000';\n\n    // 4 base64 encoded bytes per 3 raw bytes\n    var buf = randBytes.read(Math.ceil(size / 4 * 3));\n    if (!buf) {\n        throw new Error('can\\'t have size ' + sizeDesc);\n    }\n\n    // chop off any \"==\" trailer\n    var str = buf.toString('base64').slice(0, size);\n\n    var expectedErrorTypes = {};\n    if (argv.expectedError) {\n        argv.expectedError\n            .split(/,\\s*/)\n            .forEach(function eachLine(errType) {\n                expectedErrorTypes[errType] = true;\n            });\n    }\n    if (argv.bad) {\n        expectedErrorTypes.BadRequest = true;\n    }\n\n    argv.pipeline.forEach(function eachPipe(pipeline) {\n        tests.push(new Test({\n            descr: 'SET ' + sizeDesc,\n            command: 'set' + (argv.bad ? '_bad' : ''),\n            arg2: key,\n            arg3: str,\n            pipeline: pipeline,\n            expectedError: expectedError\n        }));\n        tests.push(new Test({\n            descr: 'GET ' + sizeDesc,\n            command: 'get' + (argv.bad ? '_bad' : ''),\n            arg2: key,\n            pipeline: pipeline,\n            expectedError: expectedError\n        }));\n    });\n\n    function expectedError(err) {\n        var type = errors.classify(err) || err.type;\n        return expectedErrorTypes[type] || false;\n    }\n});\n\nfunction next(i, j, done) {\n    if (i >= tests.length) {\n        return done(null);\n    }\n    if (j >= multiplicity) {\n        return next(i + 1, 0, done);\n    }\n\n    var test = tests[i].copy();\n    test.run(function runit(err) {\n        if (err) {\n            done(err);\n            return;\n        }\n        setTimeout(function delayNext() {\n            next(i, j + 1, done);\n        }, 1000);\n    });\n}\n\nfunction onRageQuit(err) {\n    if (err) {\n        console.error(err);\n        process.exit(1);\n    }\n}\n\nnext(0, 0, function finish(err) {\n    if (err) {\n        console.error(err);\n        process.exit(1);\n    }\n    process.exit(0);\n});\n\nfunction parseIntList(str) {\n    if (typeof str === 'number') {\n        return [str];\n    }\n    if (Array.isArray(str)) {\n        return str;\n    }\n    return str\n        .split(/\\s*,\\s*/)\n        .map(function each(part) {\n            return parseInt(part, 10);\n        });\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/random_sample.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n// Random sampling functions borrowed from python standard library\n\nvar RandomSample = module.exports;\nRandomSample.variate = {};\n\nRandomSample.variate.norm = function normalvariate(mu, sigma, random) {\n    var nvMagicConst = 4 * Math.exp(-0.5) / Math.sqrt(2.0);\n    return function sampleNormalRandom() {\n        for (;;) {\n            var u1 = random();\n            var u2 = 1.0 - random();\n            var z = nvMagicConst * (u1 - 0.5) / u2;\n            var zz = z * z / 4.0;\n            if (zz <= -Math.log(u2)) {\n                return mu + z * sigma;\n            }\n        }\n    };\n};\n\nRandomSample.variate.expo = function expovariate(mu, random) {\n    return function sampleExponentialRandom() {\n        return -Math.log(1 - random()) * mu;\n    };\n};\n\nRandomSample.fromString = function fromString(str, random) {\n    if (!random) {\n        random = Math.random;\n    }\n\n    // norm:mu,sigma\n    // expo:mu\n    var match = /^(\\w+):(.+)$/.exec(str);\n    if (!match) {\n        throw new Error('invalid random sample spec, expected \"kind:arg[,arg[,...]]\"');\n    }\n    var kind = match[1];\n    str = match[2];\n\n    var variate = RandomSample.variate[kind];\n    if (!variate) {\n        throw new Error('invalid random sample kind ' + kind);\n    }\n\n    var args = str.split(',');\n    if (args.length !== variate.length - 1) {\n        throw new Error('wrong number of args for random sample kind ' + kind);\n    }\n\n    for (var i = 0; i < args.length; i++) {\n        var n = parseFloat(args[i]);\n        if (isNaN(n)) {\n            throw new Error('invalid argument, not a number: ' + args[i]);\n        }\n        args[i] = n;\n    }\n\n    args.push(random);\n    return variate.apply(null, args);\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/relay_server.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar Statsd = require('uber-statsd-client');\nvar readBenchConfig = require('./read-bench-config.js');\nvar process = require('process');\nvar assert = require('assert');\n\nvar TChannel = require('../channel.js');\nvar RelayHandler = require('../relay_handler.js');\n\nvar STATSD_PORT = 7036;\n\nvar argv = readBenchConfig({\n    boolean: ['trace']\n});\n\nif (argv.type === 'bench-relay') {\n    process.title = 'nodejs-benchmarks-relay_bench_server';\n} else if (argv.type === 'trace-relay') {\n    process.title = 'nodejs-benchmarks-relay_trace_server';\n}\n\nRelayServer(argv);\n\nfunction RelayServer(opts) {\n    /*eslint max-statements: [2, 25]*/\n    if (!(this instanceof RelayServer)) {\n        return new RelayServer(opts);\n    }\n\n    var self = this;\n\n    assert(opts.benchPort, 'benchPort required');\n    assert(opts.benchRelayPort, 'benchRelayPort required');\n    assert(opts.tracePort, 'tracePort required');\n    assert(opts.traceRelayPort, 'traceRelayPort required');\n    assert(\n        opts.type === 'bench-relay' || opts.type === 'trace-relay',\n        'a valid type required'\n    );\n    assert('trace' in opts, 'trace is a required options');\n    assert('debug' in opts, 'debug is a required options');\n\n    // var benchRelayHostPort = '127.0.0.1:' + opts.benchRelayPort;\n    // var traceRelayHostPort = '127.0.0.1:' + opts.traceRelayPort;\n\n    self.relay = TChannel({\n        statTags: {\n            app: 'relay-server'\n        },\n        emitConnectionMetrics: false,\n        logger: require('debug-logtron')('relay'),\n        trace: false,\n        statsd: new Statsd({\n            host: '127.0.0.1',\n            port: STATSD_PORT\n        }),\n        choosePeerWithHeap: true\n    });\n\n    self.relay.setChoosePeerWithHeap(true);\n    self.relay.setLazyRelaying(true);\n    self.relay.setLazyHandling(true);\n\n    // // useful for demonstrating tombstone leak\n    // var OpKindMonitor = require('../monitor').OpKindMonitor;\n    // (new OpKindMonitor(self.relay, {\n    //     desc: 'relay',\n    //     interval: 5000,\n    // })).run();\n\n    // self.relay.handler = ServiceProxy({\n    //     channel: self.relay,\n    //     egressNodes: FakeEgressNodes({\n    //         hostPort: opts.type === 'bench-relay' ?\n    //             benchRelayHostPort : opts.type === 'trace-relay' ?\n    //             traceRelayHostPort : null,\n    //         topology: {\n    //             'benchmark': [benchRelayHostPort],\n    //             'tcollector': [traceRelayHostPort]\n    //         }\n    //     })\n    // });\n\n    self.serviceName = opts.type === 'bench-relay' ? 'benchmark' :\n        opts.type === 'trace-relay' ? 'tcollector' :\n        'unknown';\n    self.port = opts.type === 'bench-relay' ? opts.benchRelayPort :\n        opts.type === 'trace-relay' ? opts.traceRelayPort :\n        null;\n    self.targetPort = opts.type === 'bench-relay' ? opts.benchPort :\n        opts.type === 'trace-relay' ? opts.tracePort :\n        null;\n\n    self.relaySubChan = self.relay.makeSubChannel({\n        serviceName: self.serviceName\n    });\n    self.relaySubChan.handler = new RelayHandler(self.relaySubChan);\n\n    self.type = opts.type;\n    self.instances = opts.instances;\n\n    self.relay.listen(self.port, '127.0.0.1', onListen);\n\n    function onListen() {\n        self.connect();\n    }\n}\n\nRelayServer.prototype.connect = function connect() {\n    var self = this;\n\n    var basePort = parseInt(self.targetPort, 10);\n\n    for (var i = 0; i < self.instances; i++) {\n        var targetHostPort = '127.0.0.1:' + (basePort + i);\n\n        // var peer = self.relay.handler.getServicePeer(\n        //     self.serviceName, targetHostPort\n        // );\n        var peer = self.relaySubChan.peers.add(targetHostPort);\n        peer.connect();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/trace_server.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = require('process');\nprocess.title = 'nodejs-benchmarks-trace_server';\n\nvar Statsd = require('uber-statsd-client');\nvar Buffer = require('buffer').Buffer;\n\nvar TRACE_SERVER_PORT = 7039;\nvar STATSD_PORT = 7036;\n\nvar TChannel = require('../channel');\nvar server = TChannel({\n    statTags: {\n        app: 'tcollector'\n    },\n    emitConnectionMetrics: false,\n    trace: false,\n    statsd: new Statsd({\n        host: '127.0.0.1',\n        port: STATSD_PORT\n    })\n});\n\nvar tcollectorChan = server.makeSubChannel({\n    serviceName: 'tcollector'\n});\n\nserver.listen(TRACE_SERVER_PORT, '127.0.0.1');\n\ntcollectorChan.register('TCollector::submit', function onSubmit(req, res) {\n    var arg2 = new Buffer([0x00, 0x00]);\n    // 0c00 0002 0001 0100 00\n    var arg3 = new Buffer([\n        0x0c, 0x00, 0x00, 0x02,\n        0x00, 0x01, 0x01, 0x00,\n        0x00\n    ]);\n\n    res.headers.as = 'raw';\n    res.sendOk(arg2, arg3);\n});\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/bin/adhoc.js":"#!/usr/bin/env node\n// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/*global process */\n\n// Usage: node bin/adhoc.js <serviceName> <port> <host>\n// Creates a service on localhost, connected to Autobahn on localhost.\n\nvar os = require('os');\nvar console = require('console');\n\nvar TChannel = require('../');\nvar HyperbahnClient = require('../hyperbahn/');\n\nif (require.main === module) {\n    main();\n}\n\nfunction main() {\n    if (!process.argv[2]) {\n        throw new Error('need serviceName');\n    }\n    if (!process.argv[3]) {\n        throw new Error('need a port');\n    }\n\n    /*eslint no-console: 0*/\n    var serviceName = process.argv[2];\n    var port = +process.argv[3];\n    var host = process.argv[4] || getHost();\n    var autobahnPort = 21300;\n    var autobahnHost = host;\n\n    var tchannel = new TChannel({});\n\n    var logtron = tchannel.logger;\n\n    tchannel.makeSubChannel({\n        serviceName: serviceName\n    }).register('echo', function echo(req, res, arg2, arg3) {\n        res.headers.as = 'raw';\n        res.sendOk(arg2, arg3);\n    });\n\n    var hyperbahnClient = new HyperbahnClient({\n        tchannel: tchannel,\n        serviceName: serviceName,\n        hostPortList: [\n            autobahnHost + ':' + autobahnPort\n        ],\n        forwardRetries: 5,\n        checkForwardListInterval: 60000,\n        advertisementTimeout: 5000,\n        logger: logtron\n    });\n\n    console.log('service', serviceName, 'port', port);\n\n    tchannel.listen(port, host, function onListen(err) {\n        if (err) {\n            throw err;\n        }\n\n        console.log('listening', tchannel.address());\n        console.log('advertising', autobahnHost, autobahnPort);\n\n        hyperbahnClient.on('advertised', function onAdvertised(err2) {\n            if (err2) {\n                throw err2;\n            }\n\n            console.log('advertised');\n        });\n        hyperbahnClient.advertise();\n    });\n}\n\nfunction getHost() {\n    var ifaces = os.networkInterfaces();\n    var ifaceNames = Object.keys(ifaces);\n    for (var index = 0; index < ifaceNames.length; index++) {\n        var ifaceName = ifaceNames[index];\n        var ports = ifaces[ifaceName];\n        for (var portIndex = 0; portIndex < ports.length; portIndex++) {\n            var port = ports[portIndex];\n            if (!port.internal && port.family === 'IPv4') {\n                return port.address;\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/hyperbahn/index.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar HyperbahnClient = require('../hyperbahn-client.js');\n\nmodule.exports = HyperbahnClient;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/bin/adhoc-multi.js":"#!/usr/bin/env node\n// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n// require('format-stack').set({\n//   traces: 'short' // 'long' works too, maybe.. ;)\n// });\n\n/*global process */\n\n// Usage: node bin/adhoc_multi.js <relay_count> <serviceName> <port>\n// Creates relay_count services on localhost, connected to Autobahn on\n// localhost. The services call each other to do echo.\n\nvar os = require('os');\nvar console = require('console');\nvar fs = require('fs');\nvar path = require('path');\nvar CountedReadySignal = require('ready-signal/counted');\n\nvar TChannel = require('../');\nvar TChannelAsThrift = require('../as/thrift');\nvar HyperbahnClient = require('../hyperbahn/');\nvar DebugLogger = require('debug-logtron');\n\nif (require.main === module) {\n    main();\n}\n\nvar EP_NAME;\n\nfunction main() {\n    if (process.argv[2] === '-h' || process.argv[2] === '--help') {\n        console.log('adhoc_multi [relay_count] [serviceName] [port]');\n        return;\n    }\n\n    /*eslint no-console: 0*/\n    var rcount = Math.abs(process.argv[2] || 1);\n    var opts = {};\n    opts.listenReady = CountedReadySignal(rcount);\n    opts.advertiseReady = CountedReadySignal(rcount);\n    opts.serviceName = process.argv[3] || 'service';\n    opts.port = +process.argv[4] || 6000;\n    opts.host = getHost();\n    opts.autobahnList = getAutobahnHost();\n    opts.logger = DebugLogger('adhocMulti');\n    var spec = fs.readFileSync(path.join(__dirname, 'adhoc-multi.thrift'), 'utf8');\n    EP_NAME = 'echo';\n    opts.asThrift = [];\n    for (var i = 0; i < rcount; i++) {\n        opts.asThrift.push(new TChannelAsThrift({source: spec.replace(EP_NAME, EP_NAME + '_' + i)}));\n    }\n\n    start(opts, rcount);\n}\n\nfunction start(opts, rcount) {\n    var clients = [];\n    for (var i = 0; i < rcount; i++) {\n        opts.i = i;\n        if (i === rcount - 1) {\n            opts.isLast = true;\n        }\n        clients.push(createClient(opts));\n    }\n\n    opts.listenReady(function onListen() {\n        console.log('All channel listen started.');\n        for (i = 0; i < rcount; i++) {\n            advertise(opts, clients[i]);\n        }\n    });\n\n    opts.advertiseReady(function onAdvertised() {\n        console.log('All clients advertised.');\n        var chan = createChannel(opts);\n        var service = opts.serviceName + '_0';\n        var req = chan.makeSubChannel({\n            serviceName: service,\n            peers: opts.autobahnList\n        }).request({\n            headers: {\n                cn: opts.serviceName\n            },\n            hasNoParent: true,\n            serviceName: service\n        });\n        opts.asThrift[0].send(\n            req,\n            'AdhocMulti::' + EP_NAME + '_0',\n            null,\n            {value: 'hello'},\n            function onRes(err, res) {\n                if (err) {\n                    console.log(err);\n                } else {\n                    console.log(String(res.body));\n                }\n            }\n        );\n    });\n}\n\nfunction createChannel(options) {\n    var tchannel = new TChannel({\n        trace: true,\n        logger: options.logger,\n        traceSample: 1\n    });\n\n    return tchannel;\n}\n\nfunction createClient(options) {\n    var tchannel = createChannel(options);\n    var onResponse = options.isLast ? finish : forwardChannel;\n    var count = options.i;\n\n    console.log('advertising ' + enumerated(EP_NAME));\n    options.asThrift[count].register(\n        tchannel.makeSubChannel({\n            serviceName: enumerated(options.serviceName)\n        }),\n        enumerated('AdhocMulti::' + EP_NAME),\n        options,\n        onResponse\n    );\n\n    var hyperbahnClient = new HyperbahnClient({\n        tchannel: tchannel,\n        serviceName: enumerated(options.serviceName),\n        callerName: enumerated(options.serviceName, count - 1),\n        hostPortList: options.autobahnList,\n        forwardRetries: 5,\n        checkForwardListInterval: 60000,\n        adverisementTimeout: 5000,\n        logger: options.logger\n    });\n\n    console.log('Starting to listen service',\n        options.serviceName, 'port', options.port + count);\n    tchannel.listen(options.port + count, options.host, onListen);\n    return {\n        channel: tchannel,\n        client: hyperbahnClient\n    };\n\n    function onListen(err) {\n        if (err) {\n            throw err;\n        }\n\n        console.log('listening', tchannel.address());\n        options.listenReady.signal();\n    }\n\n    function enumerated(name, index) {\n        index = index || count;\n        return name + '_' + index;\n    }\n\n    function forwardChannel(opts, req, head, body, cb) {\n        var fchan = createChannel(options);\n        var service = enumerated(options.serviceName, count + 1);\n\n        var request = fchan.makeSubChannel({\n            serviceName: service,\n            peers: options.autobahnList\n        }).request({\n            headers: {\n                cn: enumerated(options.serviceName, count)\n            },\n            serviceName: service,\n            parent: req\n        });\n        opts.asThrift[count + 1].send(\n            request,\n            enumerated('AdhocMulti::' + EP_NAME, count + 1),\n            null,\n            body,\n            function onRet(e, r) {\n                if (e) {\n                    console.log(e);\n                } else {\n                    return cb(null, {\n                        ok: true,\n                        body: enumerated(options.serviceName) + ' says \"' + String(r.body) + '\"'\n                    });\n                }\n            }\n        );\n    }\n\n    function finish(opts, req, head, body, cb) {\n        return cb(null, {\n            ok: true,\n            body: enumerated(options.serviceName) + ' says \"' + String(body.value) + '\"'\n        });\n    }\n}\n\nfunction advertise(options, pair) {\n    var hyperbahnClient = pair.client;\n    console.log('Advertising at Hyperbahn', hyperbahnClient.hostPortList[0]);\n\n    hyperbahnClient.on('advertised', onAdvertised);\n    hyperbahnClient.advertise();\n    function onAdvertised(err2) {\n        if (err2) {\n            throw err2;\n        }\n        console.log('Advertised at Hyperbahn', hyperbahnClient.hostPortList[0]);\n        options.advertiseReady.signal();\n    }\n}\n\nfunction getAutobahnHost() {\n    try {\n        var hostPortListString =\n        fs.readFileSync('/etc/uber/autobahn/ringpop-v2.json', 'utf8');\n        return JSON.parse(hostPortListString);\n    } catch (err) {\n        if (err.code !== 'ENOENT') {\n            throw err;\n        }\n        var host = getHost();\n        return [host + ':21300', host + ':21301'];\n    }\n}\n\nfunction getHost() {\n    var ifaces = os.networkInterfaces();\n    var ifaceNames = Object.keys(ifaces);\n    for (var index = 0; index < ifaceNames.length; index++) {\n        var ifaceName = ifaceNames[index];\n        var ports = ifaces[ifaceName];\n        for (var portIndex = 0; portIndex < ports.length; portIndex++) {\n            var port = ports[portIndex];\n            if (!port.internal && port.family === 'IPv4') {\n                return port.address;\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/lcg.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar Buffer = require('buffer').Buffer;\n\n// NOTE: this RNG is not suitable for real usage, it exists only for a\n// predictable test/benchmark fixture.\n\nfunction LCG(seed) {\n    var self = this;\n    if (typeof seed === 'number') {\n        self.last = seed;\n    } else {\n        self.last = Math.floor(Math.pow(2, 32) * Math.random());\n    }\n    self.mod = Math.pow(2, 32);\n    self.mul = 214013;\n    self.add = 253101;\n}\n\nLCG.prototype.rand = function rand() {\n    var self = this;\n    self.last = (self.mul * self.last + self.add) % self.mod;\n    return self.last;\n};\n\nLCG.prototype.rand64 = function rand64() {\n    var self = this;\n    var ret = new Buffer(8);\n    ret.writeUInt32BE(self.rand(), 0);\n    ret.writeUInt32BE(self.rand(), 4);\n    return ret;\n};\n\nmodule.exports = LCG;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/lib/multicast_ctl.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n/* Provides a class for sending and handling multicast UDP messages of one or\n * more caller specified types (maximum 256).\n *\n * The format on the wire is:\n *     type:1 {body} checksum:4\n * - body is arbitrary and read/written by the specified body RW corresponding\n *   to the type.\n * - checksum is the CRC32-C checksum of all prior bytes (type + body\n *\n * Example \"chat\" application:\n *\n *     var bufrw = require('bufrw');\n *\n *     var myid = Math.floor(Math.random() * 0xffffffff);\n *\n *     var ctl = new MultiCTL({\n *         1: bufrw.Struct({\n *             id: bufrw.UInt32BE,\n *             msg: bufrw.str2\n *         }),\n *     }, 12345, ['239.0.0.1']);\n *     ctl.send(1, {id: myid, msg: '(joins)'});\n *\n *     ctl.on('frame', function onFrame(type, body) {\n *         if (body.id !== myid) {\n *             console.log('%s> %s', body.id, body.msg);\n *         }\n *     });\n *\n *     var lines = process.stdin.pipe(require('split2')());\n *     lines.on('data', function onLine(line) {\n *         ctl.send(1, {id: myid, msg: line});\n *     });\n *     lines.on('end', function onEnd() {\n *         ctl.send(1, {id: myid, msg: '(leaves)'});\n *         ctl.close();\n *     });\n *\n */\n\nvar CRC32C = require('sse4_crc32').calculate;\nvar EventEmitter = require('events').EventEmitter;\nvar bufrw = require('bufrw');\nvar dgram = require('dgram');\nvar inherits = require('util').inherits;\n\n// note assumes that buffer being read is rooted @0\nvar ChecksumPrior = {\n    byteLength: function checksumLength() {\n        return bufrw.UInt32BE.byteLength();\n    },\n    writeInto: function writePriorChecksum(obj, buffer, offset) {\n        var checksum = CRC32C(buffer.slice(0, offset));\n        return bufrw.UInt32BE.writeInto(checksum, buffer, offset);\n    },\n    readFrom: function readPriorChecksum(obj, buffer, offset) {\n        var res = bufrw.UInt32BE.readFrom(buffer, offset);\n        if (!res.err) {\n            var expected = res.value;\n            var got = CRC32C(buffer.slice(0, offset));\n            if (got !== expected) {\n                return bufrw.ReadResult.rangedError(new Error(\n                    'checksum mismatch, expected ' + expected + ' got ' + got\n                ), offset, res.offset);\n            }\n        }\n        return res;\n    }\n};\n\nfunction MultiCTL(bodyCases, port, addresses) {\n    var self = this;\n    EventEmitter.call(self);\n\n    // type:1 {body} checksum:4\n    self.frameRW = bufrw.Struct([\n        {call: bufrw.Switch(bufrw.UInt8, bodyCases, {\n            valKey: 'type',\n            dataKey: 'body',\n            structMode: true\n        })},\n        {name: 'checksum', call: ChecksumPrior}\n    ]);\n\n    self.port = port;\n    self.addresses = addresses;\n    self.socket = dgram.createSocket('udp4', onMessage);\n    self.socket.bind(port, function onBound() {\n        for (var i = 0; i < self.addresses.length; i++) {\n            self.socket.addMembership(self.addresses[i]);\n        }\n    });\n    function onMessage(buf, rinfo) {\n        self.onMessage(buf, rinfo);\n    }\n}\ninherits(MultiCTL, EventEmitter);\n\nMultiCTL.prototype.close = function close(callback) {\n    var self = this;\n    self.socket.close(callback);\n};\n\nMultiCTL.prototype.onMessage = function onMessage(buf, rinfo) {\n    var self = this;\n    bufrw.fromBufferResult(self.frameRW, buf).toCallback(function parsed(err, frame) {\n        if (err) {\n            self.emit('error', err);\n            return;\n        }\n        self.emit('frame', frame.type, frame.body, rinfo);\n    });\n};\n\nMultiCTL.prototype.send = function send(type, body) {\n    var self = this;\n    var frame = {\n        type: type,\n        body: body,\n        checksum: 0\n    };\n    bufrw.toBufferResult(self.frameRW, frame).toCallback(function wrote(err, buf) {\n        if (err) {\n            self.emit('error', err);\n            return;\n        }\n        for (var i = 0; i < self.addresses.length; i++) {\n            self.socket.send(buf, 0, buf.length, self.port, self.addresses[i]);\n        }\n    });\n};\n\nmodule.exports = MultiCTL;\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v1/frame.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar farmhash = require('farmhash');\nvar Header = require('./header');\n\nvar emptyBuffer = Buffer(0);\n\nmodule.exports = TChannelFrame;\n\nfunction TChannelFrame() {\n    this.header = new Header();\n    // TODO this field is unused. It should be removed.\n    this.options = null;\n    this.arg1 = null;\n    this.arg2 = null;\n    this.arg3 = null;\n}\n\nTChannelFrame.prototype.set = function (arg1, arg2, arg3) {\n    if (arg1 === undefined || arg1 === null) {\n        arg1 = '';\n    }\n    if (arg2 === undefined || arg2 === null) {\n        arg2 = '';\n    }\n    if (arg3 === undefined || arg3 === null) {\n        arg3 = '';\n    }\n\n    if (Buffer.isBuffer(arg1)) {\n        this.arg1 = arg1;\n    } else {\n        this.arg1 = new Buffer(arg1.toString());\n    }\n    this.header.arg1len = this.arg1.length;\n\n    if (Buffer.isBuffer(arg2)) {\n        this.arg2 = arg2;\n    } else if (typeof arg2 === 'string') {\n        this.arg2 = new Buffer(arg2);\n    } else if (arg2 === null || arg2 === undefined) {\n        this.arg2 = emptyBuffer;\n    } else {\n        throw new Error('arg2 must be a buffer or string');\n    }\n    this.header.arg2len = this.arg2.length;\n\n    if (Buffer.isBuffer(arg3)) {\n        this.arg3 = arg3;\n    } else if (typeof arg3 === 'string') {\n        this.arg3 = new Buffer(arg3);\n    } else if (arg3 === null || arg3 === undefined) {\n        this.arg3 = emptyBuffer;\n    } else {\n        throw new Error('arg3 must be a buffer or string');\n    }\n    this.header.arg3len = this.arg3.length;\n    this.header.csum = this.checksum();\n};\n\nTChannelFrame.prototype.checksum = function () {\n    var csum = farmhash.hash32(this.arg1);\n    if (this.arg2.length > 0) {\n        csum = farmhash.hash32WithSeed(this.arg2, csum);\n    }\n    if (this.arg3.length > 0) {\n        csum = farmhash.hash32WithSeed(this.arg3, csum);\n    }\n    return csum;\n};\n\nTChannelFrame.prototype.verifyChecksum = function () {\n    var self = this;\n    var err = null;\n    var actual = self.checksum();\n    var expected = self.header.csum;\n    if (expected !== actual) {\n        err = new Error('tchannel checksum validation failed');\n        err.actual = actual;\n        err.expected = expected;\n    }\n    return err;\n};\n\nTChannelFrame.prototype.toBuffer = function () {\n    var header = this.header;\n    var buf = new Buffer(25 + header.arg1len + header.arg2len + header.arg3len);\n    var offset = 0;\n\n    buf.writeUInt8(header.type, offset, true);\n    offset += 1;\n    buf.writeUInt32BE(header.id, offset, true);\n    offset += 4;\n    buf.writeUInt32BE(header.seq, offset, true);\n    offset += 4;\n    buf.writeUInt32BE(header.arg1len, offset, true);\n    offset += 4;\n    buf.writeUInt32BE(header.arg2len, offset, true);\n    offset += 4;\n    buf.writeUInt32BE(header.arg3len, offset, true);\n    offset += 4;\n    buf.writeUInt32BE(header.csum, offset, true);\n    offset += 4;\n\n    this.arg1.copy(buf, offset);\n    offset += this.arg1.length;\n    this.arg2.copy(buf, offset);\n    offset += this.arg2.length;\n    this.arg3.copy(buf, offset);\n    offset += this.arg3.length;\n\n    return buf;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v1/header.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = TChannelHeader;\n\nfunction TChannelHeader() {\n    this.type = null;\n    this.id = null;\n    this.seq = null;\n    this.arg1len = null;\n    this.arg2len = null;\n    this.arg3len = null;\n    this.csum = null;\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v1/handler.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar v1 = require('./index');\nmodule.exports = TChannelHandler;\n\nfunction TChannelHandler(channel, options) {\n    if (!(this instanceof TChannelHandler)) {\n        return new TChannelHandler(channel, options);\n    }\n    EventEmitter.call(this);\n    var self = this;\n    self.channel = channel;\n    self.writeFrame = options.writeFrame;\n    // TODO: may be better suited to pull out an operation collection\n    // abstraction and then encapsulate through that rather than this\n    // run/complete approach\n    self.runInOp = options.runInOp;\n    self.completeOutOp = options.completeOutOp;\n    self.remoteName = null; // filled in by identify message\n    self.lastSentFrameId = 0;\n}\n\nutil.inherits(TChannelHandler, EventEmitter);\n\nTChannelHandler.prototype.nextFrameId = function nextFrameId() {\n    var self = this;\n    self.lastSentFrameId = (self.lastSentFrameId + 1) % 0xffffffff;\n    return self.lastSentFrameId;\n};\n\nTChannelHandler.prototype.handleFrame = function handleFrame(frame) {\n    var self = this;\n    switch (frame.header.type) {\n        case v1.Types.reqCompleteMessage:\n            return self.handleCallRequest(frame);\n        case v1.Types.resCompleteMessage:\n            return self.handleCallResponse(frame);\n        case v1.Types.resError:\n            return self.handleError(frame);\n        default:\n            self.logger.error('unhandled frame type', {\n                type: frame.header.type\n            });\n    }\n};\n\nTChannelHandler.prototype.handleInitRequest = function handleInitRequest(reqFrame) {\n    var self = this;\n    if (self.remoteName !== null) {\n        self.emit('error', new Error('duplicate init request'));\n        return;\n    }\n    var hostPort = reqFrame.arg2.toString();\n    self.remoteName = hostPort;\n    self.emit('identify.in', hostPort);\n    self.sendInitResponse(reqFrame);\n};\n\nTChannelHandler.prototype.handleInitResponse = function handleInitResponse(resFrame) {\n    var self = this;\n    if (self.remoteName !== null) {\n        self.emit('error', new Error('duplicate init response'));\n        return;\n    }\n    var remote = String(resFrame.arg2);\n    self.remoteName = remote;\n    self.emit('identify.out', remote);\n};\n\nTChannelHandler.prototype.handleCallRequest = function handleCallRequest(reqFrame) {\n    var self = this;\n    var id = reqFrame.header.id;\n    var name = reqFrame.arg1.toString();\n\n    if (name === 'TChannel identify') {\n        self.handleInitRequest(reqFrame);\n        return;\n    }\n\n    if (self.remoteName === null) {\n        self.emit('error', new Error('call request before init request'));\n        return;\n    }\n\n    var handler = self.channel.getEndpointHandler(name);\n    self.runInOp(handler, {\n        id: id,\n        arg1: reqFrame.arg1,\n        arg2: reqFrame.arg2,\n        arg3: reqFrame.arg3,\n    }, function sendResponseFrame(err, res1, res2, callback) {\n        self.sendResponseFrame(reqFrame, err, res1, res2, callback);\n    });\n};\n\nTChannelHandler.prototype.handleCallResponse = function handleCallResponse(resFrame) {\n    var self = this;\n\n    if (String(resFrame.arg1) === 'TChannel identify') {\n        self.handleInitResponse(resFrame);\n        return;\n    }\n\n    if (self.remoteName === null) {\n        self.emit('error', new Error('call response before init response'));\n        return;\n    }\n\n    var id = resFrame.header.id;\n    var arg2 = resFrame.arg2;\n    var arg3 = resFrame.arg3;\n    self.completeOutOp(null, id, arg2, arg3);\n};\n\nTChannelHandler.prototype.handleError = function handleError(errFrame) {\n    var self = this;\n    var id = errFrame.header.id;\n    var message = errFrame.arg1;\n    var err = new Error(message);\n    self.completeOutOp(err, id, null, null);\n};\n\nTChannelHandler.prototype.sendInitRequest = function sendInitRequest() {\n    var self = this;\n    var reqFrame = new v1.Frame();\n    var id = self.nextFrameId();\n    reqFrame.header.id = id;\n    reqFrame.header.seq = 0;\n    reqFrame.set('TChannel identify', self.channel.hostPort, null);\n    reqFrame.header.type = v1.Types.reqCompleteMessage;\n    self.writeFrame(reqFrame);\n};\n\nTChannelHandler.prototype.sendInitResponse = function sendInitResponse(reqFrame) {\n    var self = this;\n    var id = reqFrame.header.id;\n    var arg1 = reqFrame.arg1;\n    var resFrame = new v1.Frame();\n    resFrame.header.id = id;\n    resFrame.header.seq = 0;\n    resFrame.set(arg1, self.channel.hostPort, null);\n    resFrame.header.type = v1.Types.resCompleteMessage;\n    self.writeFrame(resFrame);\n};\n\nTChannelHandler.prototype.sendRequestFrame = function sendRequestFrame(options, arg1, arg2, arg3, callback) {\n    var self = this;\n    var id = self.nextFrameId();\n    var reqFrame = new v1.Frame();\n    reqFrame.header.id = id;\n    reqFrame.header.seq = 0;\n    reqFrame.set(arg1, arg2, arg3);\n    reqFrame.header.type = v1.Types.reqCompleteMessage;\n    self.writeFrame(reqFrame, callback);\n    return id;\n};\n\nTChannelHandler.prototype.sendResponseFrame = function sendResponseFrame(reqFrame, err, res1, res2, callback) {\n    var self = this;\n    var resFrame = new v1.Frame();\n    var id = reqFrame.header.id;\n    var name = reqFrame.arg1.toString();\n    resFrame.header.id = id;\n    resFrame.header.seq = 0;\n    if (err) {\n        // TODO should the error response contain a head ?\n        // Is there any value in sending meta data along with\n        // the error.\n        resFrame.set(isError(err) ? err.message : err, null, null);\n        resFrame.header.type = v1.Types.resError;\n    } else {\n        resFrame.set(name, res1, res2);\n        resFrame.header.type = v1.Types.resCompleteMessage;\n    }\n    self.writeFrame(resFrame, callback);\n};\n\nfunction isError(obj) {\n    return typeof obj === 'object' && (\n        Object.prototype.toString.call(obj) === '[object Error]' ||\n        obj instanceof Error);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v1/index.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports.VERSION = 1;\n\nmodule.exports.Frame = require('./frame');\nmodule.exports.Header = require('./header');\nmodule.exports.Parser = require('./parser');\nmodule.exports.Handler = require('./handler');\n\n\nvar types = module.exports.Types = {};\ntypes.reqCompleteMessage = types.req_complete_message = 0x01;\ntypes.reqMessageFragment = types.req_message_fragment = 0x02;\ntypes.reqLastFragment = types.req_last_fragment = 0x03;\ntypes.resCompleteMessage = types.res_complete_message = 0x80;\ntypes.resMessageFragment = types.res_message_fragment = 0x81;\ntypes.resLastFragment = types.res_last_fragment = 0x82;\ntypes.resError = types.res_error = 0xC0;\n\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/v1/parser.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = TChannelParser;\n\nvar emptyBuffer = new Buffer(0);\n\nvar TChannelFrame = require('./frame');\n\nvar states = TChannelParser.States = {};\nstates.readType = 1;\nstates.readId = 2;\nstates.readSeq = 3;\nstates.readArg1len = 4;\nstates.readArg2len = 5;\nstates.readArg3len = 6;\nstates.readCsum = 7;\nstates.readArg1 = 8;\nstates.readArg2 = 9;\nstates.readArg3 = 10;\nstates.error = 255;\n\nfunction TChannelParser(connection) {\n    this.newFrame = new TChannelFrame();\n\n    this.logger = connection.logger;\n    this.state = states.readType;\n\n    this.tmpInt = null;\n    this.tmpIntBuf = new Buffer(4);\n    this.tmpIntPos = 0;\n    this.tmpStr = null;\n    this.tmpStrPos = 0;\n\n    this.pos = null;\n    this.chunk = null;\n}\n\nrequire('util').inherits(TChannelParser, require('events').EventEmitter);\n\nTChannelParser.prototype.parseError = function(msg) {\n    this.emit('error', new Error(msg));\n    this.logger.error('parse error: ' + msg);\n    this.pos = this.chunk.length;\n    this.state = states.error;\n};\n\nTChannelParser.prototype.readType = function () {\n    var newType = this.chunk[this.pos++];\n    this.state = states.readId;\n    this.newFrame.header.type = newType;\n};\n\nTChannelParser.prototype.readInt = function () {\n    if (this.tmpIntPos === 0 && this.chunk.length >= this.pos + 4) {\n        this.tmpInt = this.chunk.readUInt32BE(this.pos, true);\n        this.pos += 4;\n        return;\n    }\n    while (this.tmpIntPos < 4 && this.pos < this.chunk.length) {\n        this.tmpIntBuf[this.tmpIntPos++] = this.chunk[this.pos++];\n    }\n    if (this.tmpIntPos === 4) {\n        this.tmpInt = this.tmpIntBuf.readUInt32BE(0, true);\n        this.tmpIntPos = 0;\n    }\n};\n\nTChannelParser.prototype.readStr = function (len) {\n    if (this.tmpStr === null) {\n        if ((this.chunk.length - this.pos) >= len) {\n            this.tmpStr = this.chunk.slice(this.pos, this.pos + len);\n            this.pos += len;\n            this.tmpStrPos = len;\n        } else {\n            this.tmpStr = new Buffer(len);\n            this.chunk.copy(this.tmpStr, 0, this.pos, this.chunk.length);\n            this.tmpStrPos = this.chunk.length - this.pos;\n            this.pos += (this.chunk.length - this.pos);\n        }\n    } else {\n        var bytesToCopy = Math.min(this.chunk.length, (len - this.tmpStrPos));\n        this.chunk.copy(this.tmpStr, this.tmpStrPos, this.pos, this.pos + bytesToCopy);\n        this.tmpStrPos += bytesToCopy;\n        this.pos += bytesToCopy;\n    }\n};\n\nTChannelParser.prototype.execute = function (chunk) {\n    this.pos = 0;\n    this.chunk = chunk;\n    var header = this.newFrame.header;\n\n    while (this.pos < chunk.length) {\n        if (this.state === states.readType) {\n            this.readType();\n        } else if (this.state === states.readId) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.id = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readSeq;\n            }\n        } else if (this.state === states.readSeq) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.seq = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readArg1len;\n            }\n        } else if (this.state === states.readArg1len) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.arg1len = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readArg2len;\n            }\n        } else if (this.state === states.readArg2len) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.arg2len = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readArg3len;\n            }\n        } else if (this.state === states.readArg3len) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.arg3len = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readCsum;\n            }\n        } else if (this.state === states.readCsum) {\n            this.readInt();\n            if (typeof this.tmpInt === 'number') {\n                header.csum = this.tmpInt;\n                this.tmpInt = null;\n                this.state = states.readArg1;\n            }\n        } else if (this.state === states.readArg1) {\n            this.readStr(header.arg1len);\n            if (this.tmpStrPos === header.arg1len) {\n                this.newFrame.arg1 = this.tmpStr;\n                this.tmpStr = null;\n                this.tmpStrPos = 0;\n                if (header.arg2len === 0 && header.arg3len === 0) {\n                    this.emitAndReset();\n                    header = this.newFrame.header;\n                } else {\n                    this.state = states.readArg2;\n                }\n            }\n        } else if (this.state === states.readArg2) {\n            this.readStr(header.arg2len);\n            if (this.tmpStrPos === header.arg2len) {\n                this.newFrame.arg2 = this.tmpStr;\n                this.tmpStr = null;\n                this.tmpStrPos = 0;\n                if (header.arg3len === 0) {\n                    this.emitAndReset();\n                    header = this.newFrame.header;\n                } else {\n                    this.state = states.readArg3;\n                }\n            }\n        } else if (this.state === states.readArg3) {\n            this.readStr(header.arg3len);\n            if (this.tmpStrPos === header.arg3len) {\n                this.newFrame.arg3 = this.tmpStr;\n                this.emitAndReset();\n                header = this.newFrame.header;\n            }\n        } else if (this.state !== states.error) {\n            throw new Error('unknown state ' + this.state);\n        }\n    }\n};\n\nTChannelParser.prototype.emitAndReset = function () {\n    this.tmpStr = null;\n    this.tmpStrPos = 0;\n    if (this.newFrame.header.arg2len === 0) {\n        this.newFrame.arg2 = emptyBuffer;\n    }\n    if (this.newFrame.header.arg3len === 0) {\n        this.newFrame.arg3 = emptyBuffer;\n    }\n    var err = this.newFrame.verifyChecksum();\n    if (err) {\n        this.emit('error', err);\n        return;\n    }\n    this.emit('frame', this.newFrame);\n    this.newFrame = new TChannelFrame();\n    this.state = states.readType;\n    this.chunk = null;\n};\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/micro/reading-all-important-fields.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = global.process;\nvar bufrw = require('bufrw');\nvar setTimeout = require('timers').setTimeout;\nvar console = require('console');\nvar Buffer = require('buffer').Buffer;\n\n/*eslint no-console: 0*/\nvar v2 = require('../../v2/index.js');\n\nvar spanId = [0, 1];\nvar CN_BUFFER = new Buffer('cn');\nvar RD_BUFFER = new Buffer('rd');\nvar parentId = [2, 3];\nvar traceId = [4, 5];\nvar tracing = new v2.Tracing(\n    spanId, parentId, traceId\n);\n\nvar frame = new v2.Frame(24,    // frame id\n    new v2.CallRequest(\n        42,                     // flags\n        99,                     // ttl\n        tracing,                // tracing\n        'castle',               // service\n        {                       // headers\n            'cn': 'mario',      // headers.cn\n            'as': 'plumber'     // headers.as\n        },                      //\n        v2.Checksum.Types.None, // csum\n        ['door', 'key', 'turn'] // args\n    )\n);\n\nfunction main(mode, ITER) {\n    var buf = bufrw.toBuffer(v2.Frame.RW, frame);\n\n    runLoop(buf, mode, 1000);\n    console.log('done warmup');\n    setTimeout(pastWarmup, 250);\n\n    function pastWarmup() {\n        console.log('running bench', process.pid);\n        var start = Date.now();\n        runLoop(buf, mode, ITER);\n        var end = Date.now();\n        console.log('finised bench', end - start);\n    }\n}\n\nfunction runLoop(buf, mode, ITER) {\n    if (mode === 'optimized') {\n        runOptimizedLoop(buf, ITER);\n    } else if (mode === 'default') {\n        runDefaultLoop(buf, ITER);\n    } else {\n        console.warn('noop');\n    }\n}\n\nfunction runDefaultLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var res = lazyFrame.bodyRW.lazy.readService(lazyFrame);\n        var serviceName = res.value;\n\n        res = lazyFrame.bodyRW.lazy.readHeaders(lazyFrame);\n        var headers = res.value;\n        var callerName = String(headers.getValue(CN_BUFFER));\n        var routingDelegate = headers.getValue(RD_BUFFER);\n\n        res = lazyFrame.bodyRW.lazy.readArg1(lazyFrame, headers);\n        var endpoint = String(res.value);\n\n        resArr[i % 10] = new FrameData(\n            serviceName, callerName, routingDelegate, endpoint\n        );\n\n        // Naughty; reset cache\n        lazyFrame.cache.serviceStr = null;\n        lazyFrame.cache.callerNameStr = null;\n        lazyFrame.cache.routingDelegateStr = null;\n        lazyFrame.cache.arg1Str = null;\n\n        lazyFrame.cache.headerStartOffset = null;\n        lazyFrame.cache.csumStartOffset = null;\n\n        lazyFrame.cache.cnValueOffset = null;\n        lazyFrame.cache.rdValueOffset = null;\n    }\n}\n\nfunction runOptimizedLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var serviceName = lazyFrame.bodyRW.lazy.readServiceStr(lazyFrame);\n        var callerName = lazyFrame.bodyRW.lazy.readCallerNameStr(lazyFrame);\n        var routingDelegate = lazyFrame.bodyRW.lazy\n            .readRoutingDelegateStr(lazyFrame);\n        var endpoint = lazyFrame.bodyRW.lazy.readArg1Str(lazyFrame);\n\n        resArr[i % 10] = new FrameData(\n            serviceName, callerName, routingDelegate, endpoint\n        );\n\n        // Naughty; reset cache\n        lazyFrame.cache.serviceStr = null;\n        lazyFrame.cache.callerNameStr = null;\n        lazyFrame.cache.routingDelegateStr = null;\n        lazyFrame.cache.arg1Str = null;\n\n        lazyFrame.cache.headerStartOffset = null;\n        lazyFrame.cache.csumStartOffset = null;\n\n        lazyFrame.cache.cnValueOffset = null;\n        lazyFrame.cache.rdValueOffset = null;\n    }\n}\n\nfunction FrameData(serviceName, callerName, routingDelegate, endpoint) {\n    this.serviceName = serviceName;\n    this.callerName = callerName;\n    this.routingDelegate = routingDelegate;\n    this.endpoint = endpoint;\n}\n\nif (require.main === module) {\n    var arg = process.argv[2];\n    var mode = process.argv[3] || 'optimized';\n    var ITERATIONS = 1000 * 1000 * 1;\n    if (arg) {\n        ITERATIONS = 1000 * 1000 * 1 * parseInt(arg, 10);\n    }\n\n    main(mode, ITERATIONS);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/micro/reading-arg1-str.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = global.process;\nvar bufrw = require('bufrw');\nvar setTimeout = require('timers').setTimeout;\nvar console = require('console');\n\n/*eslint no-console: 0*/\nvar v2 = require('../../v2/index.js');\n\nvar spanId = [0, 1];\nvar parentId = [2, 3];\nvar traceId = [4, 5];\nvar tracing = new v2.Tracing(\n    spanId, parentId, traceId\n);\n\nvar frame = new v2.Frame(24,    // frame id\n    new v2.CallRequest(\n        42,                     // flags\n        99,                     // ttl\n        tracing,                // tracing\n        'castle',               // service\n        {                       // headers\n            'cn': 'mario',      // headers.cn\n            'as': 'plumber'     // headers.as\n        },                      //\n        v2.Checksum.Types.None, // csum\n        ['door', 'key', 'turn'] // args\n    )\n);\n\nfunction main(mode, ITER) {\n    var buf = bufrw.toBuffer(v2.Frame.RW, frame);\n\n    runLoop(buf, mode, 1000);\n    console.log('done warmup');\n    setTimeout(pastWarmup, 250);\n\n    function pastWarmup() {\n        console.log('running bench', process.pid);\n        var start = Date.now();\n        runLoop(buf, mode, ITER);\n        var end = Date.now();\n        console.log('finised bench', end - start);\n    }\n}\n\nfunction runLoop(buf, mode, ITER) {\n    if (mode === 'optimized') {\n        runOptimizedLoop(buf, ITER);\n    } else if (mode === 'default') {\n        runDefaultLoop(buf, ITER);\n    } else {\n        console.warn('noop');\n    }\n}\n\nfunction runDefaultLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var res = lazyFrame.bodyRW.lazy.readArg1(lazyFrame);\n        var endpoint = res.value;\n\n        resArr[i % 10] = new FrameData(String(endpoint));\n\n        // Naughty; reset cache\n        lazyFrame.cache.arg1Str = null;\n        lazyFrame.cache.csumStartOffset = null;\n    }\n}\n\nfunction runOptimizedLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var endpoint = lazyFrame.bodyRW.lazy.readArg1Str(lazyFrame);\n\n        resArr[i % 10] = new FrameData(endpoint);\n\n        // Naughty; reset cache\n        lazyFrame.cache.arg1Str = null;\n        lazyFrame.cache.csumStartOffset = null;\n    }\n}\n\nfunction FrameData(endpoint) {\n    this.endpoint = endpoint;\n}\n\nif (require.main === module) {\n    var arg = process.argv[2];\n    var mode = process.argv[3] || 'optimized';\n    var ITERATIONS = 1000 * 1000 * 2;\n    if (arg) {\n        ITERATIONS = 1000 * 1000 * 2 * parseInt(arg, 10);\n    }\n\n    main(mode, ITERATIONS);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/micro/reading-caller-name-str.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = global.process;\nvar bufrw = require('bufrw');\nvar setTimeout = require('timers').setTimeout;\nvar console = require('console');\nvar Buffer = require('buffer').Buffer;\n\n/*eslint no-console: 0*/\nvar v2 = require('../../v2/index.js');\n\nvar spanId = [0, 1];\nvar CN_BUFFER = new Buffer('cn');\nvar parentId = [2, 3];\nvar traceId = [4, 5];\nvar tracing = new v2.Tracing(\n    spanId, parentId, traceId\n);\n\nvar frame = new v2.Frame(24,    // frame id\n    new v2.CallRequest(\n        42,                     // flags\n        99,                     // ttl\n        tracing,                // tracing\n        'castle',               // service\n        {                       // headers\n            'cn': 'mario',      // headers.cn\n            'as': 'plumber'     // headers.as\n        },                      //\n        v2.Checksum.Types.None, // csum\n        ['door', 'key', 'turn'] // args\n    )\n);\n\nfunction main(mode, ITER) {\n    var buf = bufrw.toBuffer(v2.Frame.RW, frame);\n\n    runLoop(buf, mode, 1000);\n    console.log('done warmup');\n    setTimeout(pastWarmup, 250);\n\n    function pastWarmup() {\n        console.log('running bench', process.pid);\n        var start = Date.now();\n        runLoop(buf, mode, ITER);\n        var end = Date.now();\n        console.log('finised bench', end - start);\n    }\n}\n\nfunction runLoop(buf, mode, ITER) {\n    if (mode === 'optimized') {\n        runOptimizedLoop(buf, ITER);\n    } else if (mode === 'default') {\n        runDefaultLoop(buf, ITER);\n    } else {\n        console.warn('noop');\n    }\n}\n\nfunction runDefaultLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var res = lazyFrame.bodyRW.lazy.readHeaders(lazyFrame);\n        var headers = res.value;\n\n        resArr[i % 10] = new FrameData(\n            String(headers.getValue(CN_BUFFER))\n        );\n\n        // Naughty; reset cache\n        lazyFrame.cache.callerNameStr = null;\n        lazyFrame.cache.headerStartOffset = null;\n        lazyFrame.cache.csumStartOffset = null;\n        lazyFrame.cache.cnValueOffset = null;\n    }\n}\n\nfunction runOptimizedLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var callerName = lazyFrame.bodyRW.lazy.readCallerNameStr(lazyFrame);\n\n        resArr[i % 10] = new FrameData(callerName);\n\n        // Naughty; reset cache\n        lazyFrame.cache.callerNameStr = null;\n        lazyFrame.cache.headerStartOffset = null;\n        lazyFrame.cache.csumStartOffset = null;\n        lazyFrame.cache.cnValueOffset = null;\n    }\n}\n\nfunction FrameData(callerName) {\n    this.callerName = callerName;\n}\n\nif (require.main === module) {\n    var arg = process.argv[2];\n    var mode = process.argv[3] || 'optimized';\n    var ITERATIONS = 1000 * 1000 * 2;\n    if (arg) {\n        ITERATIONS = 1000 * 1000 * 2 * parseInt(arg, 10);\n    }\n\n    main(mode, ITERATIONS);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/micro/reading-service-name-str.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = global.process;\nvar bufrw = require('bufrw');\nvar setTimeout = require('timers').setTimeout;\nvar console = require('console');\n\n/*eslint no-console: 0*/\nvar v2 = require('../../v2/index.js');\n\nvar spanId = [0, 1];\nvar parentId = [2, 3];\nvar traceId = [4, 5];\nvar tracing = new v2.Tracing(\n    spanId, parentId, traceId\n);\n\nvar frame = new v2.Frame(24,    // frame id\n    new v2.CallRequest(\n        42,                     // flags\n        99,                     // ttl\n        tracing,                // tracing\n        'castle',               // service\n        {                       // headers\n            'cn': 'mario',      // headers.cn\n            'as': 'plumber'     // headers.as\n        },                      //\n        v2.Checksum.Types.None, // csum\n        ['door', 'key', 'turn'] // args\n    )\n);\n\nfunction main(mode, ITER) {\n    var buf = bufrw.toBuffer(v2.Frame.RW, frame);\n\n    runLoop(buf, mode, 1000);\n    console.log('done warmup');\n    setTimeout(pastWarmup, 250);\n\n    function pastWarmup() {\n        console.log('running bench', process.pid);\n        var start = Date.now();\n        runLoop(buf, mode, ITER);\n        var end = Date.now();\n        console.log('finised bench', end - start);\n    }\n}\n\nfunction runLoop(buf, mode, ITER) {\n    if (mode === 'optimized') {\n        runOptimizedLoop(buf, ITER);\n    } else if (mode === 'default') {\n        runDefaultLoop(buf, ITER);\n    } else {\n        console.warn('noop');\n    }\n}\n\nfunction runDefaultLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var res = lazyFrame.bodyRW.lazy.readService(lazyFrame);\n\n        resArr[i % 10] = new FrameData(res.value);\n\n        // Naughty; reset cache\n        lazyFrame.cache.serviceStr = null;\n        lazyFrame.cache.headerStartOffset = null;\n    }\n}\n\nfunction runOptimizedLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var serviceName = lazyFrame.bodyRW.lazy.readServiceStr(lazyFrame);\n\n        resArr[i % 10] = new FrameData(serviceName);\n\n        // Naughty; reset cache\n        lazyFrame.cache.serviceStr = null;\n        lazyFrame.cache.headerStartOffset = null;\n    }\n}\n\nfunction FrameData(serviceName) {\n    this.serviceName = serviceName;\n}\n\nif (require.main === module) {\n    var arg = process.argv[2];\n    var mode = process.argv[3] || 'optimized';\n    var ITERATIONS = 1000 * 1000 * 5;\n    if (arg) {\n        ITERATIONS = 1000 * 1000 * 5 * parseInt(arg, 10);\n    }\n\n    main(mode, ITERATIONS);\n}\n","/home/travis/build/npmtest/node-npmtest-tchannel/node_modules/tchannel/benchmarks/micro/reading-tracing-value.js":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar process = global.process;\nvar bufrw = require('bufrw');\nvar setTimeout = require('timers').setTimeout;\nvar console = require('console');\n\n/*eslint no-console: 0*/\nvar v2 = require('../../v2/index.js');\n\nvar spanId = [0, 1];\nvar parentId = [2, 3];\nvar traceId = [4, 5];\nvar _tracing = new v2.Tracing(\n    spanId, parentId, traceId\n);\n\nvar frame = new v2.Frame(24,    // frame id\n    new v2.CallRequest(\n        42,                     // flags\n        99,                     // ttl\n        _tracing,                // tracing\n        'castle',               // service\n        {                       // headers\n            'cn': 'mario',      // headers.cn\n            'as': 'plumber'     // headers.as\n        },                      //\n        v2.Checksum.Types.None, // csum\n        ['door', 'key', 'turn'] // args\n    )\n);\n\nfunction main(mode, ITER) {\n    var buf = bufrw.toBuffer(v2.Frame.RW, frame);\n\n    runLoop(buf, mode, 1000);\n    console.log('done warmup');\n    setTimeout(pastWarmup, 250);\n\n    function pastWarmup() {\n        console.log('running bench', process.pid);\n        var start = Date.now();\n        runLoop(buf, mode, ITER);\n        var end = Date.now();\n        console.log('finised bench', end - start);\n    }\n}\n\nfunction runLoop(buf, mode, ITER) {\n    if (mode === 'optimized') {\n        runOptimizedLoop(buf, ITER);\n    } else if (mode === 'default') {\n        runDefaultLoop(buf, ITER);\n    } else {\n        console.warn('noop');\n    }\n}\n\nfunction runDefaultLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var res = lazyFrame.bodyRW.lazy.readTracing(lazyFrame);\n        var tracing = res.value;\n\n        resArr[i % 10] = new FrameData(String(tracing));\n\n        // Naughty; reset cache\n        lazyFrame.cache.tracingValue = null;\n    }\n}\n\nfunction runOptimizedLoop(buf, ITER) {\n    var resArr = new Array(10);\n    var lazyFrame = bufrw.fromBuffer(v2.LazyFrame.RW, buf);\n\n    for (var i = 0; i < ITER; i++) {\n        var tracing = lazyFrame.bodyRW.lazy.readTracingValue(lazyFrame);\n\n        resArr[i % 10] = new FrameData(tracing);\n\n        // Naughty; reset cache\n        lazyFrame.cache.tracingValue = null;\n    }\n}\n\nfunction FrameData(tracing) {\n    this.tracing = tracing;\n}\n\nif (require.main === module) {\n    var arg = process.argv[2];\n    var mode = process.argv[3] || 'optimized';\n    var ITERATIONS = 1000 * 1000 * 2;\n    if (arg) {\n        ITERATIONS = 1000 * 1000 * 2 * parseInt(arg, 10);\n    }\n\n    main(mode, ITERATIONS);\n}\n"}